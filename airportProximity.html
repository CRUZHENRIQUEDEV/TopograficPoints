<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <!-- Vers√£o: 2.2 -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>An√°lise de Zonas de Drone para Pontes</title>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #2c3e50 0%, #34495e 50%, #2c3e50 100%);
      min-height: 100vh;
      color: #ffffff;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 20px;
      padding: 2rem;
      margin-bottom: 2rem;
    }

    h1, h2, h3 {
      color: #ffffff;
      font-weight: 700;
      margin-bottom: 1.5rem;
      background: linear-gradient(45deg, #ffffff, #e3f2fd);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    h1 {
      font-size: 2rem;
      text-align: center;
    }

    h2 {
      font-size: 1.5rem;
    }

    h3 {
      font-size: 1.2rem;
    }

    .upload-section {
      text-align: center;
      padding: 2rem;
      border: 2px dashed #3498db;
      border-radius: 15px;
      background: rgba(52, 152, 219, 0.1);
      margin-bottom: 2rem;
    }

    button {
      background: linear-gradient(45deg, #3498db, #2ecc71);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 15px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      margin: 10px 5px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
    }

    button:disabled {
      background: linear-gradient(45deg, #95a5a6, #7f8c8d);
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .btn-clear {
      background: linear-gradient(45deg, #e74c3c, #c0392b);
    }

    .btn-clear:hover {
      background: linear-gradient(45deg, #c0392b, #a93226);
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-bottom: 2rem;
    }

    .stat-card {
      background: rgba(255, 255, 255, 0.1);
      padding: 1rem;
      border-radius: 10px;
      text-align: center;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .stat-value {
      font-size: 2rem;
      font-weight: bold;
      color: #64b5f6;
    }

    .stat-label {
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.8);
      margin-top: 0.5rem;
    }

    .progress-bar {
      width: 100%;
      background: rgba(255, 255, 255, 0.2);
      padding: 3px;
      border-radius: 15px;
      margin: 20px 0;
      display: none;
    }

    .progress-bar.active {
      display: block;
    }

    .progress {
      background: linear-gradient(45deg, #3498db, #2ecc71);
      height: 25px;
      border-radius: 12px;
      transition: width 0.3s ease;
      text-align: center;
      line-height: 25px;
      color: white;
      font-weight: 600;
    }

    /* Debug log */
    .debug-log {
      background: rgba(0, 0, 0, 0.3);
      padding: 1rem;
      border-radius: 10px;
      margin: 1rem 0;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .debug-log-title {
      font-weight: 600;
      color: #64b5f6;
      margin-bottom: 0.5rem;
    }

    .debug-line {
      margin: 2px 0;
      color: rgba(255, 255, 255, 0.8);
    }

    .debug-line.error {
      color: #e74c3c;
    }

    .debug-line.success {
      color: #2ecc71;
    }

    .debug-line.warning {
      color: #f39c12;
    }

    /* Se√ß√£o de Filtros */
    .filter-section {
      background: rgba(255, 255, 255, 0.08);
      padding: 1.5rem;
      border-radius: 15px;
      margin-bottom: 1.5rem;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .filter-title {
      font-size: 1.2rem;
      font-weight: 600;
      margin-bottom: 1rem;
      color: #64b5f6;
    }

    .filter-controls {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr 1fr auto;
      gap: 1rem;
      align-items: end;
    }

    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .filter-group label {
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.9);
      font-weight: 500;
    }

    .filter-group input,
    .filter-group select {
      padding: 10px 15px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.1);
      color: white;
      font-size: 14px;
      transition: all 0.3s ease;
    }

    .filter-group input:focus,
    .filter-group select:focus {
      outline: none;
      border-color: #3498db;
      background: rgba(255, 255, 255, 0.15);
    }

    .filter-group input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }

    .filter-group select option {
      background: #2c3e50;
      color: white;
    }

    .filter-results {
      margin-top: 1rem;
      padding: 0.8rem;
      background: rgba(52, 152, 219, 0.2);
      border-radius: 10px;
      text-align: center;
      font-weight: 600;
      color: #64b5f6;
    }

    .no-results {
      text-align: center;
      padding: 2rem;
      color: #e74c3c;
      font-size: 1.1rem;
      font-weight: 600;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      overflow: hidden;
      font-size: 13px;
    }

    th, td {
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 10px;
      text-align: left;
    }

    th {
      background: rgba(52, 152, 219, 0.3);
      font-weight: 600;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    td {
      background: rgba(255, 255, 255, 0.05);
    }

    tbody tr:hover td {
      background: rgba(255, 255, 255, 0.1);
    }

    tbody tr.hidden {
      display: none;
    }

    .zone-prohibited {
      background: rgba(231, 76, 60, 0.3) !important;
      color: #fff;
      font-weight: bold;
    }

    .zone-restricted {
      background: rgba(241, 196, 15, 0.3) !important;
      color: #fff;
      font-weight: bold;
    }

    .zone-permitted {
      background: rgba(46, 204, 113, 0.3) !important;
      color: #fff;
      font-weight: bold;
    }

    .zone-badge {
      padding: 4px 8px;
      border-radius: 5px;
      font-size: 11px;
      font-weight: bold;
      display: inline-block;
    }

    .badge-prohibited {
      background: #e74c3c;
    }

    .badge-restricted {
      background: #f39c12;
    }

    .badge-permitted {
      background: #27ae60;
    }

    .legend {
      display: flex;
      justify-content: center;
      gap: 2rem;
      margin: 1rem 0;
      flex-wrap: wrap;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .legend-color {
      width: 20px;
      height: 20px;
      border-radius: 5px;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .table-container {
      max-height: 600px;
      overflow-y: auto;
      border-radius: 15px;
    }

    .footer {
      text-align: center;
      padding: 1rem;
      margin-top: 2rem;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    .note {
      background: rgba(255, 235, 59, 0.2);
      padding: 15px;
      border-left: 4px solid #ffd600;
      margin: 15px 0;
      border-radius: 10px;
    }

    .info-box {
      background: rgba(52, 152, 219, 0.2);
      padding: 20px;
      border-left: 4px solid #3498db;
      margin: 20px 0;
      border-radius: 10px;
    }

    .info-box h3 {
      margin-bottom: 1rem;
      font-size: 1.3rem;
    }

    .info-box p {
      margin-bottom: 0.8rem;
      line-height: 1.6;
    }

    .info-box ul {
      margin-left: 20px;
      margin-top: 10px;
    }

    .info-box li {
      margin-bottom: 8px;
      line-height: 1.5;
    }

    .criteria-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }

    .criteria-card {
      background: rgba(255, 255, 255, 0.05);
      padding: 1.2rem;
      border-radius: 10px;
      border: 2px solid;
    }

    .criteria-card.prohibited {
      border-color: #e74c3c;
    }

    .criteria-card.restricted {
      border-color: #f39c12;
    }

    .criteria-card.permitted {
      border-color: #27ae60;
    }

    .criteria-card h4 {
      font-size: 1.1rem;
      margin-bottom: 0.8rem;
      color: #fff;
    }

    .criteria-card p {
      margin-bottom: 0.5rem;
      font-size: 0.95rem;
    }

    .criteria-card .distance {
      font-size: 1.3rem;
      font-weight: bold;
      color: #64b5f6;
      margin: 0.5rem 0;
    }

    input[type="file"] {
      display: none;
    }

    /* Estilos para checkboxes de filtro */
    .checkbox-container {
      max-height: 200px;
      overflow-y: auto;
      background: rgba(255, 255, 255, 0.05);
      padding: 10px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .checkbox-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 8px;
      margin: 4px 0;
      border-radius: 5px;
      transition: background 0.2s;
    }

    .checkbox-item:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .checkbox-item input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
      accent-color: #3498db;
    }

    .checkbox-item label {
      cursor: pointer;
      user-select: none;
      flex: 1;
      font-size: 0.9rem;
    }

    .checkbox-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    }

    .checkbox-header-title {
      font-weight: 600;
      color: #64b5f6;
      font-size: 0.95rem;
    }

    .checkbox-actions {
      display: flex;
      gap: 8px;
    }

    .checkbox-action-btn {
      background: none;
      border: none;
      color: #3498db;
      font-size: 0.8rem;
      padding: 2px 8px;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .checkbox-action-btn:hover {
      background: rgba(52, 152, 219, 0.2);
      color: #64b5f6;
    }

    /* Responsividade para filtros */
    @media (max-width: 768px) {
      .filter-controls {
        grid-template-columns: 1fr;
      }
      
      .criteria-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üöÅ An√°lise de Zonas de Drone para Pontes</h1>

    <div class="info-box">
      <h3>üìã Crit√©rios de Classifica√ß√£o das Zonas</h3>
      <p><strong>Este sistema utiliza os crit√©rios estabelecidos pela ICA 100-40 (DECEA) e RBAC-E n¬∫ 94/2017 (ANAC):</strong></p>
      
      <div class="criteria-grid">
        <div class="criteria-card prohibited">
          <h4>üö´ ZONA DE APROXIMA√á√ÉO/DECOLAGEM (ZAD)</h4>
          <div class="distance">0 a 9 km</div>
          <p><strong>Dist√¢ncia do aeroporto/heliponto:</strong> 0 a 9 quil√¥metros</p>
          <p><strong>Base Legal:</strong> ICA 100-40/2023 - <strong>Item 2.1.57</strong> (vers√£o 2020) ou <strong>Item 2.1.69</strong> (vers√£o 2023)</p>
          <p style="font-size: 0.85rem; font-style: italic; margin-top: 8px;">
            "Para fins de entendimento do constante desta Instru√ß√£o, considera-se Zona de Aproxima√ß√£o ou de Decolagem 
            a √°rea compreendida entre a cabeceira da pista at√© a dist√¢ncia de 9 km (nove quil√¥metros)."
          </p>
          <p><strong>Restri√ß√£o:</strong> Voo de drone <strong>REQUER M√öLTIPLAS AUTORIZA√á√ïES</strong>:</p>
          <ul style="margin-left: 20px; margin-top: 8px;">
            <li>Administrador do Aer√≥dromo</li>
            <li>√ìrg√£o Regional DECEA</li>
            <li>√ìrg√£o ATS local (se houver)</li>
            <li>Paralisa√ß√£o de opera√ß√µes tripuladas pode ser necess√°ria</li>
          </ul>
        </div>

        <div class="criteria-card permitted">
          <h4>‚úÖ ZONA PERMITIDA</h4>
          <div class="distance">> 9 km</div>
          <p><strong>Dist√¢ncia do aeroporto/heliponto:</strong> Mais de 9 quil√¥metros</p>
          <p><strong>Base Legal:</strong> RBAC-E n¬∫ 94/2017 e ICA 100-40/2023</p>
          <p><strong>Restri√ß√£o:</strong> Voo de drone <strong>PERMITIDO</strong> seguindo regras gerais:</p>
          <ul style="margin-left: 20px; margin-top: 8px;">
            <li>Cadastro no SISANT (drones >250g)</li>
            <li>Altura m√°xima: 120m (400 p√©s)</li>
            <li>Dist√¢ncia m√≠nima de 30m de pessoas</li>
            <li>Opera√ß√£o VLOS (linha de visada visual)</li>
          </ul>
        </div>
      </div>

      <p style="margin-top: 1.5rem;"><strong>üìñ Base Legal:</strong></p>
      <ul>
        <li><strong>ICA 100-40/2023</strong> - Item 2.1.69 (vers√£o 2023) ou Item 2.1.57 (vers√£o 2020) - Aeronaves n√£o Tripuladas e o Acesso ao Espa√ßo A√©reo Brasileiro (DECEA)</li>
        <li><strong>RBAC-E n¬∫ 94/2017</strong> - Regulamento Brasileiro de Avia√ß√£o Civil Especial (ANAC)</li>
        <li><strong>ICA 100-12</strong> - Regras do Ar (DECEA)</li>
        <li><strong>Lei 7.565/1986</strong> - C√≥digo Brasileiro de Aeron√°utica</li>
      </ul>

      <p style="margin-top: 1rem; font-size: 0.9rem; color: rgba(255, 255, 255, 0.8);">
        <strong>‚ö†Ô∏è Importante:</strong> A ICA 100-40 especifica que a ZAD possui "dist√¢ncia vari√°vel em rela√ß√£o √† cabeceira 
        e em fun√ß√£o da altura do voo". Os 9km s√£o o par√¢metro geral, mas dist√¢ncias exatas podem variar conforme altura, 
        tipo de aer√≥dromo e procedimentos espec√≠ficos. Para opera√ß√µes reais com drones, sempre consulte o 
        <strong>SARPAS (Sistema de Solicita√ß√£o de Acesso de RPAS)</strong> do DECEA e a ANAC para obter autoriza√ß√µes espec√≠ficas.
      </p>
    </div>

    <div class="note">
      <p><strong>üìã Como usar:</strong></p>
      <p>1. Fa√ßa upload do CSV com dados das pontes (aceita m√∫ltiplos formatos)</p>
      <p>2. O sistema detectar√° automaticamente o formato do CSV</p>
      <p>3. Consulta aeroportos pr√≥ximos via OpenStreetMap</p>
      <p>4. Visualize o relat√≥rio com zonas de restri√ß√£o baseadas na legisla√ß√£o</p>
      <p>5. Use os filtros para localizar obras espec√≠ficas</p>
      <p>6. Exporte o resultado completo em CSV</p>
    </div>

    <div class="upload-section">
      <h3>üìÅ Upload do CSV</h3>
      <input type="file" id="csvInput" accept=".csv" />
      <button onclick="document.getElementById('csvInput').click()">
        Selecionar CSV
      </button>
      <p id="fileName" style="margin-top: 1rem; color: #64b5f6;"></p>
    </div>

    <!-- Debug Log -->
    <div id="debugSection" style="display: none;">
      <div class="debug-log">
        <div class="debug-log-title">üìä Log de Importa√ß√£o</div>
        <div id="debugLog"></div>
      </div>
    </div>

    <div class="progress-bar" id="progressBar">
      <div class="progress" id="progress">0%</div>
    </div>

    <div id="statsSection" style="display: none;">
      <h2>üìä Estat√≠sticas</h2>
      <div class="stats">
        <div class="stat-card">
          <div class="stat-value" id="totalPontes">0</div>
          <div class="stat-label">Total de Pontes</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="pontesProibidas">0</div>
          <div class="stat-label">üö´ ZAD (0-9km)</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="pontesPermitidas">0</div>
          <div class="stat-label">‚úÖ Zona Permitida (>9km)</div>
        </div>
      </div>

      <div class="legend">
        <div class="legend-item">
          <div class="legend-color" style="background: rgba(231, 76, 60, 0.7);"></div>
          <span>üö´ ZAD - Requer Autoriza√ß√£o (0-9km)</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: rgba(46, 204, 113, 0.7);"></div>
          <span>‚úÖ Permitido (>9km)</span>
        </div>
      </div>

      <button id="exportBtn" onclick="exportarCSV()" style="background: linear-gradient(45deg, #9b59b6, #8e44ad);">
        üì• Exportar Relat√≥rio CSV
      </button>
    </div>

    <div id="resultsSection" style="display: none;">
      <h2>üóÇÔ∏è Resultados da An√°lise</h2>
      
      <!-- Se√ß√£o de Filtros -->
      <div class="filter-section">
        <div class="filter-title">üîç Filtrar Obras</div>
        <div class="filter-controls">
          <div class="filter-group">
            <label for="filterCodigo">C√≥digo</label>
            <input 
              type="text" 
              id="filterCodigo" 
              placeholder="Digite o c√≥digo..."
              oninput="aplicarFiltros()"
            />
          </div>
          
          <div class="filter-group">
            <label>Regi√£o do Brasil</label>
            <div class="checkbox-container" id="regiaoContainer">
              <div class="checkbox-header">
                <span class="checkbox-header-title">Selecione as regi√µes</span>
                <div class="checkbox-actions">
                  <button type="button" class="checkbox-action-btn" onclick="selecionarTodosRegiao(true)">Todos</button>
                  <button type="button" class="checkbox-action-btn" onclick="selecionarTodosRegiao(false)">Limpar</button>
                </div>
              </div>
              <div class="checkbox-item">
                <input type="checkbox" id="regiao-norte" value="Norte" onchange="aplicarFiltros()">
                <label for="regiao-norte">Norte</label>
              </div>
              <div class="checkbox-item">
                <input type="checkbox" id="regiao-nordeste" value="Nordeste" onchange="aplicarFiltros()">
                <label for="regiao-nordeste">Nordeste</label>
              </div>
              <div class="checkbox-item">
                <input type="checkbox" id="regiao-centro-oeste" value="Centro-Oeste" onchange="aplicarFiltros()">
                <label for="regiao-centro-oeste">Centro-Oeste</label>
              </div>
              <div class="checkbox-item">
                <input type="checkbox" id="regiao-sudeste" value="Sudeste" onchange="aplicarFiltros()">
                <label for="regiao-sudeste">Sudeste</label>
              </div>
              <div class="checkbox-item">
                <input type="checkbox" id="regiao-sul" value="Sul" onchange="aplicarFiltros()">
                <label for="regiao-sul">Sul</label>
              </div>
            </div>
          </div>

          <div class="filter-group">
            <label>Estado (UF)</label>
            <div class="checkbox-container" id="ufContainer">
              <div class="checkbox-header">
                <span class="checkbox-header-title">Selecione os estados</span>
                <div class="checkbox-actions">
                  <button type="button" class="checkbox-action-btn" onclick="selecionarTodosUF(true)">Todos</button>
                  <button type="button" class="checkbox-action-btn" onclick="selecionarTodosUF(false)">Limpar</button>
                </div>
              </div>
              <div id="ufCheckboxList"></div>
            </div>
          </div>

          <div class="filter-group">
            <label for="filterZona">Zona</label>
            <select id="filterZona" onchange="aplicarFiltros()">
              <option value="">Todas as zonas</option>
              <option value="prohibited">üö´ ZAD (0-9km)</option>
              <option value="permitted">‚úÖ Permitido (>9km)</option>
            </select>
          </div>
          
          <button class="btn-clear" onclick="limparFiltros()" style="align-self: end;">
            üóëÔ∏è Limpar Tudo
          </button>
        </div>
        
        <div class="filter-results" id="filterResults">
          Mostrando 0 de 0 obras
        </div>
      </div>

      <div class="table-container">
        <table id="resultsTable">
          <thead>
            <tr>
              <th>C√≥digo</th>
              <th>Identifica√ß√£o</th>
              <th>Munic√≠pio</th>
              <th>UF</th>
              <th>Rodovia</th>
              <th>Km</th>
              <th>Latitude</th>
              <th>Longitude</th>
              <th>Zona</th>
              <th>Dist√¢ncia (km)</th>
              <th>Aeroporto Pr√≥ximo</th>
            </tr>
          </thead>
          <tbody id="resultsBody">
          </tbody>
        </table>
        <div id="noResults" class="no-results" style="display: none;">
          ‚ùå Nenhuma obra encontrada com os filtros aplicados
        </div>
      </div>
    </div>
  </div>

  <div class="footer">
    <p><strong>ZenithSolutions</strong> - An√°lise de Zonas de Drone</p>
    <p>&copy; 2025 Ferramentas Profissionais</p>
  </div>

  <script>
    // Vers√£o: 2.2
    
    // Vari√°veis globais
    let pontesData = [];
    let aeroportosCache = new Map();
    let resultadosAnalise = [];
    let debugMessages = [];
    let formatoCSV = null; // 'tipo1' ou 'tipo2'
    let separadorCSV = ','; // Detectado automaticamente

    // Mapeamento de UF para Regi√£o
    const ufParaRegiao = {
      // Norte
      'AC': 'Norte', 'AP': 'Norte', 'AM': 'Norte', 'PA': 'Norte', 'RO': 'Norte', 'RR': 'Norte', 'TO': 'Norte',
      // Nordeste
      'AL': 'Nordeste', 'BA': 'Nordeste', 'CE': 'Nordeste', 'MA': 'Nordeste', 'PB': 'Nordeste', 
      'PE': 'Nordeste', 'PI': 'Nordeste', 'RN': 'Nordeste', 'SE': 'Nordeste',
      // Centro-Oeste
      'DF': 'Centro-Oeste', 'GO': 'Centro-Oeste', 'MT': 'Centro-Oeste', 'MS': 'Centro-Oeste',
      // Sudeste
      'ES': 'Sudeste', 'MG': 'Sudeste', 'RJ': 'Sudeste', 'SP': 'Sudeste',
      // Sul
      'PR': 'Sul', 'RS': 'Sul', 'SC': 'Sul'
    };

    // Fun√ß√£o para adicionar mensagens de debug
    function addDebugLog(message, type = 'info') {
      const debugLog = document.getElementById('debugLog');
      const debugSection = document.getElementById('debugSection');
      
      debugSection.style.display = 'block';
      
      const line = document.createElement('div');
      line.className = `debug-line ${type}`;
      line.textContent = message;
      
      debugLog.appendChild(line);
      debugLog.scrollTop = debugLog.scrollHeight;
      
      console.log(`[${type.toUpperCase()}] ${message}`);
    }

    // Detectar separador do CSV (v√≠rgula, ponto e v√≠rgula ou tab)
    function detectarSeparador(primeiraLinha) {
      const separadores = [';', ',', '\t'];
      let melhorSeparador = ',';
      let maiorContagem = 0;
      
      separadores.forEach(sep => {
        const contagem = (primeiraLinha.match(new RegExp(sep.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g')) || []).length;
        if (contagem > maiorContagem) {
          maiorContagem = contagem;
          melhorSeparador = sep;
        }
      });
      
      const nomeSeparador = melhorSeparador === ';' ? 'ponto e v√≠rgula (;)' : 
                           melhorSeparador === '\t' ? 'tab (\\t)' : 'v√≠rgula (,)';
      addDebugLog(`Separador detectado: ${nomeSeparador}`, 'success');
      
      return melhorSeparador;
    }

    // Event listener para upload de CSV
    document.getElementById('csvInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;

      document.getElementById('fileName').textContent = `Arquivo: ${file.name}`;
      
      // Limpar debug log anterior
      document.getElementById('debugLog').innerHTML = '';
      debugMessages = [];
      formatoCSV = null;
      
      const reader = new FileReader();
      reader.onload = function(event) {
        const csvContent = event.target.result;
        parseCSV(csvContent);
      };
      reader.readAsText(file, 'UTF-8');
    });

    // Detectar formato do CSV baseado nos headers
    function detectarFormatoCSV(headers) {
      addDebugLog('Detectando formato do CSV...', 'info');
      
      // Formato Tipo 1: Tem "C√≥digo SGO"
      const temCodigoSGO = headers.some(h => h.toLowerCase().includes('c√≥digo sgo'));
      
      // Formato Tipo 2: Tem "Via / UF / km" ou similar
      const temViaUFKm = headers.some(h => 
        h.toLowerCase().includes('via') && 
        h.toLowerCase().includes('uf') && 
        h.toLowerCase().includes('km')
      );
      
      if (temCodigoSGO) {
        formatoCSV = 'tipo1';
        addDebugLog('‚úì Formato detectado: CSV Tipo 1 (formato antigo)', 'success');
        return 'tipo1';
      } else if (temViaUFKm || headers.some(h => h.toLowerCase() === 'c√≥digo')) {
        formatoCSV = 'tipo2';
        addDebugLog('‚úì Formato detectado: CSV Tipo 2 (formato novo)', 'success');
        return 'tipo2';
      } else {
        formatoCSV = 'tipo1';
        addDebugLog('‚ö†Ô∏è Formato n√£o identificado claramente - usando Tipo 1 como padr√£o', 'warning');
        return 'tipo1';
      }
    }

    // Extrair Rodovia, UF e Km da coluna "Via / UF / km"
    function extrairViaUFKm(texto) {
      // Padr√£o: "BR-319 / AM / 734,31"
      const regex = /^([A-Z]{2}-\d+)\s*\/\s*([A-Z]{2})\s*\/\s*([\d,\.]+)$/;
      const match = texto.trim().match(regex);
      
      if (match) {
        return {
          rodovia: match[1],      // BR-319
          uf: match[2],            // AM
          km: match[3]             // 734,31
        };
      }
      
      // Tentar extrair pelo menos a UF (segundo elemento)
      const partes = texto.split('/').map(p => p.trim());
      if (partes.length >= 2) {
        return {
          rodovia: partes[0] || '',
          uf: partes[1] || '',
          km: partes[2] || ''
        };
      }
      
      return { rodovia: '', uf: '', km: '' };
    }

    // Normalizar dados do CSV para formato interno √∫nico
    function normalizarDados(ponte, formato) {
      const normalizado = {};
      
      if (formato === 'tipo1') {
        // Mapeamento direto Tipo 1
        normalizado.codigo = ponte['C√≥digo SGO'] || ponte['Codigo SGO'] || '';
        normalizado.identificacao = ponte['Identifica√ß√£o'] || ponte['Identificacao'] || '';
        normalizado.municipio = ponte['Munic√≠pio'] || ponte['Municipio'] || '';
        normalizado.uf = ponte['UF'] || '';
        normalizado.regiao = ponte['Regi√£o'] || ponte['Regiao'] || '';
        normalizado.rodovia = ponte['Rodovia'] || '';
        normalizado.km = ponte['Km'] || '';
        normalizado.natureza = ponte['Natureza'] || '';
        normalizado.comprimento = ponte['Comprimento'] || '';
        normalizado.largura = ponte['Largura'] || '';
        normalizado.ano = ponte['Ano'] || '';
        normalizado.latitude = ponte['Latitude'] || '';
        normalizado.longitude = ponte['Longitude'] || '';
        
      } else if (formato === 'tipo2') {
        // Mapeamento Tipo 2 com extra√ß√£o
        normalizado.codigo = ponte['C√≥digo'] || ponte['Codigo'] || '';
        normalizado.identificacao = ponte['Identifica√ß√£o da OAE'] || ponte['Identificacao da OAE'] || '';
        normalizado.municipio = ''; // N√£o dispon√≠vel no Tipo 2
        normalizado.regiao = ''; // N√£o dispon√≠vel no Tipo 2
        normalizado.natureza = ''; // N√£o dispon√≠vel no Tipo 2
        normalizado.ano = ''; // N√£o dispon√≠vel no Tipo 2
        
        // Extrair Via/UF/Km
        const viaUFKm = ponte['Via / UF / km'] || ponte['Via / UF / Km'] || '';
        const extraido = extrairViaUFKm(viaUFKm);
        normalizado.rodovia = extraido.rodovia;
        normalizado.uf = extraido.uf;
        normalizado.km = extraido.km;
        
        // Extens√£o = Comprimento
        normalizado.comprimento = ponte['Extens√£o (m)'] || ponte['Extensao (m)'] || '';
        normalizado.largura = ponte['Largura (m)'] || '';
        
        normalizado.latitude = ponte['Latitude'] || '';
        normalizado.longitude = ponte['Longitude'] || '';
        
        // Campos extras do Tipo 2
        normalizado.codigoSNV = ponte['C√≥digo SNV'] || ponte['Codigo SNV'] || '';
        normalizado.versaoSNV = ponte['Vers√£o SNV'] || ponte['Versao SNV'] || '';
        normalizado.dataVistoria = ponte['Data da Vistoria'] || '';
        normalizado.notaTecnica = ponte['Nota T√©cnica'] || ponte['Nota Tecnica'] || '';
      }
      
      return normalizado;
    }

    // Parser CSV robusto que respeita campos com aspas
    function parseCSVLine(line) {
      const result = [];
      let current = '';
      let inQuotes = false;
      
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        const nextChar = line[i + 1];
        
        if (char === '"') {
          if (inQuotes && nextChar === '"') {
            // Aspas escapadas ""
            current += '"';
            i++; // Pular pr√≥ximo caractere
          } else {
            // Alternar estado de aspas
            inQuotes = !inQuotes;
          }
        } else if (char === separadorCSV && !inQuotes) {
          // Separador fora de aspas = novo campo
          result.push(current.trim());
          current = '';
        } else {
          current += char;
        }
      }
      
      // Adicionar √∫ltimo campo
      result.push(current.trim());
      
      return result;
    }

    // Parse do CSV com detec√ß√£o autom√°tica de formato
    function parseCSV(csvContent) {
      addDebugLog('Iniciando parse do CSV...', 'info');
      
      const lines = csvContent.split('\n');
      addDebugLog(`Total de linhas no arquivo: ${lines.length}`, 'info');
      
      if (lines.length === 0) {
        addDebugLog('Arquivo CSV vazio!', 'error');
        alert('Arquivo CSV vazio!');
        return;
      }
      
      // Parse da primeira linha (cabe√ßalho) - detectar separador primeiro
      const headerLine = lines[0].trim();
      separadorCSV = detectarSeparador(headerLine);
      const headers = parseCSVLine(headerLine);
      
      addDebugLog(`Cabe√ßalhos encontrados: ${headers.join(', ')}`, 'success');
      
      // Detectar formato do CSV
      const formato = detectarFormatoCSV(headers);
      
      // Verificar se tem colunas Latitude e Longitude
      const hasLatitude = headers.some(h => h.toLowerCase().includes('latitude'));
      const hasLongitude = headers.some(h => h.toLowerCase().includes('longitude'));
      
      if (!hasLatitude || !hasLongitude) {
        addDebugLog('ERRO: CSV n√£o cont√©m colunas Latitude e Longitude!', 'error');
        alert('Erro: O CSV precisa ter colunas "Latitude" e "Longitude"');
        return;
      }
      
      pontesData = [];
      let linhasProcessadas = 0;
      let linhasComErro = 0;
      let linhasValidas = 0;
      let linhasSemCoordenadas = 0;
      
      // Processar cada linha de dados
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        
        // Pular linhas vazias
        if (!line) continue;
        
        linhasProcessadas++;
        
        try {
          const values = parseCSVLine(line);
          
          // Criar objeto da ponte
          const ponte = {};
          headers.forEach((header, index) => {
            ponte[header] = values[index] || '';
          });
          
          // Normalizar dados baseado no formato
          const ponteNormalizada = normalizarDados(ponte, formato);
          
          // Validar coordenadas
          const lat = parseFloat(ponteNormalizada.latitude.replace(',', '.'));
          const lng = parseFloat(ponteNormalizada.longitude.replace(',', '.'));
          
          if (isNaN(lat) || isNaN(lng)) {
            linhasSemCoordenadas++;
            if (linhasSemCoordenadas <= 5) {
              addDebugLog(`Linha ${i + 1}: Coordenadas inv√°lidas (Lat: ${ponteNormalizada.latitude}, Lng: ${ponteNormalizada.longitude})`, 'warning');
            }
            continue;
          }
          
          if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
            linhasSemCoordenadas++;
            if (linhasSemCoordenadas <= 5) {
              addDebugLog(`Linha ${i + 1}: Coordenadas fora do range (Lat: ${lat}, Lng: ${lng})`, 'warning');
            }
            continue;
          }
          
          // Adicionar coordenadas num√©ricas
          ponteNormalizada.latitudeNum = lat;
          ponteNormalizada.longitudeNum = lng;
          
          pontesData.push(ponteNormalizada);
          linhasValidas++;
          
        } catch (error) {
          linhasComErro++;
          if (linhasComErro <= 5) {
            addDebugLog(`Linha ${i + 1}: Erro ao processar - ${error.message}`, 'error');
          }
        }
      }
      
      // Resumo do parse
      addDebugLog('=== RESUMO DO PARSE ===', 'info');
      addDebugLog(`Formato detectado: ${formato === 'tipo1' ? 'CSV Tipo 1' : 'CSV Tipo 2'}`, 'info');
      addDebugLog(`Total de linhas processadas: ${linhasProcessadas}`, 'info');
      addDebugLog(`Linhas v√°lidas importadas: ${linhasValidas}`, 'success');
      addDebugLog(`Linhas sem coordenadas v√°lidas: ${linhasSemCoordenadas}`, 'warning');
      addDebugLog(`Linhas com erro: ${linhasComErro}`, linhasComErro > 0 ? 'error' : 'info');
      
      if (pontesData.length > 0) {
        addDebugLog(`‚úì ${pontesData.length} pontes prontas para an√°lise!`, 'success');
        iniciarAnalise();
      } else {
        addDebugLog('‚úó Nenhuma ponte v√°lida encontrada!', 'error');
        alert('Nenhuma ponte v√°lida encontrada no CSV. Verifique:\n\n' +
              '1. Se as colunas Latitude e Longitude existem\n' +
              '2. Se os valores s√£o num√©ricos\n' +
              '3. Se as coordenadas est√£o no formato correto (decimal)');
      }
    }

    // Iniciar an√°lise
    async function iniciarAnalise() {
      document.getElementById('progressBar').classList.add('active');
      document.getElementById('statsSection').style.display = 'none';
      document.getElementById('resultsSection').style.display = 'none';
      
      resultadosAnalise = [];
      
      addDebugLog('Iniciando an√°lise de zonas de drone...', 'info');
      
      // Calcular bbox global para todas as pontes
      let minLat = Infinity, maxLat = -Infinity;
      let minLng = Infinity, maxLng = -Infinity;
      
      pontesData.forEach(ponte => {
        minLat = Math.min(minLat, ponte.latitudeNum);
        maxLat = Math.max(maxLat, ponte.latitudeNum);
        minLng = Math.min(minLng, ponte.longitudeNum);
        maxLng = Math.max(maxLng, ponte.longitudeNum);
      });
      
      // Expandir bbox em 20km (~0.2 graus)
      const margem = 0.2;
      const bbox = `${minLat - margem},${minLng - margem},${maxLat + margem},${maxLng + margem}`;
      
      addDebugLog(`Bbox calculado: ${bbox}`, 'info');
      
      // Consultar aeroportos
      updateProgress(10, 'Consultando aeroportos...');
      const aeroportos = await consultarAeroportosOverpass(bbox);
      
      addDebugLog(`${aeroportos.length} aeroportos encontrados na regi√£o`, aeroportos.length > 0 ? 'success' : 'warning');
      
      if (aeroportos.length === 0) {
        addDebugLog('‚ö†Ô∏è Nenhum aeroporto encontrado - todas as pontes ser√£o marcadas como "Permitido"', 'warning');
      }
      
      // Processar cada ponte
      addDebugLog(`Analisando ${pontesData.length} pontes...`, 'info');
      
      for (let i = 0; i < pontesData.length; i++) {
        const ponte = pontesData[i];
        const progresso = 10 + ((i + 1) / pontesData.length) * 90;
        updateProgress(progresso, `Analisando ponte ${i + 1}/${pontesData.length}...`);
        
        const analise = analisarPonte(ponte, aeroportos);
        resultadosAnalise.push(analise);
        
        // Pequena pausa para n√£o travar a UI
        if (i % 50 === 0) {
          await new Promise(resolve => setTimeout(resolve, 10));
        }
      }
      
      updateProgress(100, 'An√°lise conclu√≠da!');
      addDebugLog(`‚úì An√°lise conclu√≠da com sucesso!`, 'success');
      
      exibirResultados();
    }

    // Consultar aeroportos via Overpass API
    async function consultarAeroportosOverpass(bbox) {
      const query = `
        [out:json][timeout:30];
        (
          node["aeroway"="aerodrome"](${bbox});
          node["aeroway"="helipad"](${bbox});
          node["aeroway"="heliport"](${bbox});
          way["aeroway"="aerodrome"](${bbox});
          relation["aeroway"="aerodrome"](${bbox});
        );
        out center;
      `;

      try {
        const response = await fetch('https://overpass-api.de/api/interpreter', {
          method: 'POST',
          body: query,
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded'
          }
        });

        if (!response.ok) {
          throw new Error(`Erro na API Overpass: ${response.status}`);
        }

        const data = await response.json();
        return processarAeroportos(data.elements);
      } catch (error) {
        addDebugLog(`Erro ao consultar aeroportos: ${error.message}`, 'error');
        return [];
      }
    }

    // Processar dados de aeroportos
    function processarAeroportos(elements) {
      const aeroportos = [];
      
      elements.forEach(element => {
        let lat, lng, name, type;
        
        if (element.type === 'node') {
          lat = element.lat;
          lng = element.lon;
        } else if (element.center) {
          lat = element.center.lat;
          lng = element.center.lon;
        } else {
          return;
        }

        name = element.tags?.name || element.tags?.ref || 'Sem nome';
        type = element.tags?.aeroway || 'aerodrome';
        
        aeroportos.push({
          lat,
          lng,
          name,
          type,
          icao: element.tags?.icao || '',
          iata: element.tags?.iata || ''
        });
      });

      return aeroportos;
    }

    // Analisar uma ponte
    function analisarPonte(ponte, aeroportos) {
      let menorDistancia = Infinity;
      let aeroportoMaisProximo = null;

      aeroportos.forEach(aeroporto => {
        const distancia = calcularDistanciaHaversine(
          ponte.latitudeNum, 
          ponte.longitudeNum, 
          aeroporto.lat, 
          aeroporto.lng
        );
        
        if (distancia < menorDistancia) {
          menorDistancia = distancia;
          aeroportoMaisProximo = aeroporto;
        }
      });

      let zona, descricao;
      if (menorDistancia <= 9) {
        zona = 'prohibited';
        descricao = 'üö´ ZAD (0-9km)';
      } else {
        zona = 'permitted';
        descricao = '‚úÖ Permitido (>9km)';
      }

      return {
        ...ponte,
        zona,
        descricao,
        distanciaAeroporto: menorDistancia === Infinity ? null : menorDistancia,
        aeroportoProximo: aeroportoMaisProximo ? aeroportoMaisProximo.name : 'N/A'
      };
    }

    // Calcular dist√¢ncia Haversine em km
    function calcularDistanciaHaversine(lat1, lng1, lat2, lng2) {
      const R = 6371; // Raio da Terra em km
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLng / 2) * Math.sin(dLng / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    // Atualizar barra de progresso
    function updateProgress(percent, message) {
      const progress = document.getElementById('progress');
      progress.style.width = percent + '%';
      progress.textContent = message || `${Math.round(percent)}%`;
    }

    // Exibir resultados
    function exibirResultados() {
      // Calcular estat√≠sticas
      const total = resultadosAnalise.length;
      const proibidas = resultadosAnalise.filter(r => r.zona === 'prohibited').length;
      const permitidas = resultadosAnalise.filter(r => r.zona === 'permitted').length;

      document.getElementById('totalPontes').textContent = total;
      document.getElementById('pontesProibidas').textContent = proibidas;
      document.getElementById('pontesPermitidas').textContent = permitidas;

      addDebugLog(`Estat√≠sticas: ${total} total | ${proibidas} ZAD (0-9km) | ${permitidas} permitidas (>9km)`, 'success');

      // Preencher tabela
      const tbody = document.getElementById('resultsBody');
      tbody.innerHTML = '';

      resultadosAnalise.forEach((resultado, index) => {
        const row = tbody.insertRow();
        row.className = `zone-${resultado.zona}`;
        row.dataset.index = index;
        row.dataset.codigo = resultado.codigo || '';
        row.dataset.uf = resultado.uf || '';
        row.dataset.zona = resultado.zona || '';

        row.insertCell(0).textContent = resultado.codigo || '-';
        row.insertCell(1).textContent = resultado.identificacao || '-';
        row.insertCell(2).textContent = resultado.municipio || '-';
        row.insertCell(3).textContent = resultado.uf || '-';
        row.insertCell(4).textContent = resultado.rodovia || '-';
        row.insertCell(5).textContent = resultado.km || '-';
        row.insertCell(6).textContent = resultado.latitude || '-';
        row.insertCell(7).textContent = resultado.longitude || '-';
        
        const zonaCell = row.insertCell(8);
        zonaCell.innerHTML = `<span class="zone-badge badge-${resultado.zona}">${resultado.descricao}</span>`;
        
        const distanciaCell = row.insertCell(9);
        distanciaCell.textContent = resultado.distanciaAeroporto !== null 
          ? resultado.distanciaAeroporto.toFixed(2) 
          : 'N/A';
        
        row.insertCell(10).textContent = resultado.aeroportoProximo || 'N/A';
      });

      // Popular checkboxes de UFs
      popularCheckboxesUF();

      // Mostrar se√ß√µes
      document.getElementById('statsSection').style.display = 'block';
      document.getElementById('resultsSection').style.display = 'block';
      
      // Atualizar contador de filtros
      atualizarContadorFiltros();
      
      // Esconder progress bar
      setTimeout(() => {
        document.getElementById('progressBar').classList.remove('active');
      }, 1000);
    }

    // Popular checkboxes de UFs com valores √∫nicos
    function popularCheckboxesUF() {
      const ufsUnicas = [...new Set(resultadosAnalise.map(r => r.uf).filter(uf => uf))].sort();
      const container = document.getElementById('ufCheckboxList');
      
      // Limpar checkboxes existentes
      container.innerHTML = '';
      
      ufsUnicas.forEach(uf => {
        const div = document.createElement('div');
        div.className = 'checkbox-item';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `uf-${uf}`;
        checkbox.value = uf;
        checkbox.onchange = aplicarFiltros;
        
        const label = document.createElement('label');
        label.htmlFor = `uf-${uf}`;
        label.textContent = uf;
        
        div.appendChild(checkbox);
        div.appendChild(label);
        container.appendChild(div);
      });
    }

    // Selecionar/Desselecionar todas as regi√µes
    function selecionarTodosRegiao(selecionar) {
      const checkboxes = document.querySelectorAll('#regiaoContainer input[type="checkbox"]');
      checkboxes.forEach(cb => cb.checked = selecionar);
      aplicarFiltros();
    }

    // Selecionar/Desselecionar todos os UFs
    function selecionarTodosUF(selecionar) {
      const checkboxes = document.querySelectorAll('#ufCheckboxList input[type="checkbox"]');
      checkboxes.forEach(cb => cb.checked = selecionar);
      aplicarFiltros();
    }

    // Aplicar filtros
    function aplicarFiltros() {
      const filterCodigo = document.getElementById('filterCodigo').value.toLowerCase().trim();
      const filterZona = document.getElementById('filterZona').value;
      
      // Obter regi√µes selecionadas
      const regioesSelecionadas = Array.from(
        document.querySelectorAll('#regiaoContainer input[type="checkbox"]:checked')
      ).map(cb => cb.value);
      
      // Obter UFs selecionadas
      const ufsSelecionadas = Array.from(
        document.querySelectorAll('#ufCheckboxList input[type="checkbox"]:checked')
      ).map(cb => cb.value);
      
      const tbody = document.getElementById('resultsBody');
      const rows = tbody.getElementsByTagName('tr');
      let visibleCount = 0;

      for (let row of rows) {
        const codigo = row.dataset.codigo.toLowerCase();
        const uf = row.dataset.uf;
        const zona = row.dataset.zona;
        
        // Verificar se passa nos filtros
        const codigoMatch = !filterCodigo || codigo.includes(filterCodigo);
        
        // Filtro de regi√£o
        const regiaoMatch = regioesSelecionadas.length === 0 || 
                           regioesSelecionadas.includes(ufParaRegiao[uf]);
        
        // Filtro de UF
        const ufMatch = ufsSelecionadas.length === 0 || 
                       ufsSelecionadas.includes(uf);
        
        // Filtro de zona
        const zonaMatch = !filterZona || zona === filterZona;
        
        if (codigoMatch && regiaoMatch && ufMatch && zonaMatch) {
          row.classList.remove('hidden');
          visibleCount++;
        } else {
          row.classList.add('hidden');
        }
      }

      // Atualizar contador
      atualizarContadorFiltros(visibleCount);
      
      // Mostrar/ocultar mensagem de "sem resultados"
      const noResults = document.getElementById('noResults');
      if (visibleCount === 0) {
        noResults.style.display = 'block';
      } else {
        noResults.style.display = 'none';
      }
    }

    // Atualizar contador de filtros
    function atualizarContadorFiltros(visible) {
      const total = resultadosAnalise.length;
      const visibleCount = visible !== undefined ? visible : total;
      
      const filterResults = document.getElementById('filterResults');
      filterResults.textContent = `Mostrando ${visibleCount} de ${total} obras`;
      
      if (visibleCount < total) {
        filterResults.style.background = 'rgba(241, 196, 15, 0.3)';
      } else {
        filterResults.style.background = 'rgba(52, 152, 219, 0.2)';
      }
    }

    // Limpar filtros
    function limparFiltros() {
      document.getElementById('filterCodigo').value = '';
      document.getElementById('filterZona').value = '';
      
      // Desmarcar todas as regi√µes
      document.querySelectorAll('#regiaoContainer input[type="checkbox"]').forEach(cb => cb.checked = false);
      
      // Desmarcar todas as UFs
      document.querySelectorAll('#ufCheckboxList input[type="checkbox"]').forEach(cb => cb.checked = false);
      
      aplicarFiltros();
    }

    // Exportar CSV
    function exportarCSV() {
      if (resultadosAnalise.length === 0) return;

      // Cabe√ßalhos adaptados ao formato
      let headers;
      if (formatoCSV === 'tipo2') {
        headers = [
          'C√≥digo', 'Identifica√ß√£o da OAE', 'Via / UF / km', 'Extens√£o (m)', 
          'Largura (m)', 'Latitude', 'Longitude', 'Zona_Drone', 'Descri√ß√£o_Zona', 
          'Dist√¢ncia_Aeroporto_km', 'Aeroporto_Pr√≥ximo'
        ];
      } else {
        headers = [
          'C√≥digo SGO', 'Identifica√ß√£o', 'Munic√≠pio', 'UF', 'Regi√£o', 
          'Rodovia', 'Km', 'Natureza', 'Comprimento', 'Largura', 'Ano', 
          'Latitude', 'Longitude', 'Zona_Drone', 'Descri√ß√£o_Zona', 
          'Dist√¢ncia_Aeroporto_km', 'Aeroporto_Pr√≥ximo'
        ];
      }

      let csvContent = headers.join(',') + '\n';

      resultadosAnalise.forEach(resultado => {
        let row;
        
        if (formatoCSV === 'tipo2') {
          // Reconstruir coluna Via / UF / km
          const viaUFKm = `${resultado.rodovia} / ${resultado.uf} / ${resultado.km}`;
          
          row = [
            resultado.codigo || '',
            `"${(resultado.identificacao || '').replace(/"/g, '""')}"`,
            `"${viaUFKm}"`,
            resultado.comprimento || '',
            resultado.largura || '',
            resultado.latitude || '',
            resultado.longitude || '',
            resultado.zona || '',
            `"${resultado.descricao || ''}"`,
            resultado.distanciaAeroporto !== null ? resultado.distanciaAeroporto.toFixed(2) : '',
            `"${(resultado.aeroportoProximo || '').replace(/"/g, '""')}"`
          ];
        } else {
          row = [
            resultado.codigo || '',
            `"${(resultado.identificacao || '').replace(/"/g, '""')}"`,
            resultado.municipio || '',
            resultado.uf || '',
            resultado.regiao || '',
            resultado.rodovia || '',
            resultado.km || '',
            resultado.natureza || '',
            resultado.comprimento || '',
            resultado.largura || '',
            resultado.ano || '',
            resultado.latitude || '',
            resultado.longitude || '',
            resultado.zona || '',
            `"${resultado.descricao || ''}"`,
            resultado.distanciaAeroporto !== null ? resultado.distanciaAeroporto.toFixed(2) : '',
            `"${(resultado.aeroportoProximo || '').replace(/"/g, '""')}"`
          ];
        }

        csvContent += row.join(',') + '\n';
      });

      // Download
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      
      link.setAttribute('href', url);
      link.setAttribute('download', 'relatorio_zonas_drone_pontes.csv');
      link.style.visibility = 'hidden';
      
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      addDebugLog('‚úì CSV exportado com sucesso!', 'success');
    }
  </script>
</body>
</html>