<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OAE Support</title>
    <!-- Chart.js é a única dependência externa -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <style>
      /* Versão: 5.0 - Estilo simplificado e robusto */
      :root {
        --bg-color: #1e3d59;
        --text-color: #ffffff;
        --card-bg: rgba(255, 255, 255, 0.1);
        --highlight: #3498db;
        --success: #27ae60;
        --warning: #f39c12;
        --danger: #e74c3c;
        --info: #3498db;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: Arial, sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        line-height: 1.6;
        padding: 20px;
      }

      .summary-container {
        margin-bottom: 20px;
      }

      .summary-content {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
      }

      .summary-section {
        flex: 1 0 200px;
      }

      .summary-section ul {
        list-style-type: none;
        padding-left: 10px;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
      }

      header {
        text-align: center;
        margin-bottom: 30px;
      }

      h1 {
        font-size: 2rem;
        margin-bottom: 5px;
      }

      h2 {
        font-size: 1.5rem;
        margin-bottom: 15px;
      }

      h3 {
        font-size: 1.2rem;
        margin-bottom: 10px;
      }

      .card {
        background-color: var(--card-bg);
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 20px;
      }

      textarea {
        width: 100%;
        height: 200px;
        padding: 10px;
        background-color: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: var(--text-color);
        border-radius: 4px;
        margin-bottom: 15px;
      }

      button {
        background-color: var(--highlight);
        color: white;
        border: none;
        padding: 10px 15px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 16px;
      }

      button:hover {
        opacity: 0.9;
      }

      button#exportBtn {
        background-color: var(--success);
      }

      button:disabled {
        background-color: #95a5a6;
        cursor: not-allowed;
      }

      .button-group {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
      }

      .tabs {
        display: flex;
        margin-bottom: 20px;
      }

      .tab {
        padding: 10px 20px;
        background-color: rgba(255, 255, 255, 0.1);
        cursor: pointer;
        border-radius: 4px 4px 0 0;
        margin-right: 2px;
      }

      .tab.active {
        background-color: rgba(255, 255, 255, 0.2);
        font-weight: bold;
      }

      .tab-content {
        display: none;
      }

      .tab-content.active {
        display: block;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 20px;
      }

      th,
      td {
        padding: 12px;
        text-align: left;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      th {
        background-color: rgba(255, 255, 255, 0.1);
        font-weight: bold;
      }

      tr:nth-child(even) {
        background-color: rgba(255, 255, 255, 0.03);
      }

      /* Status colors */
      .status-avaliacao {
        background-color: rgba(243, 156, 18, 0.2);
      }
      .status-aprovada {
        background-color: rgba(39, 174, 96, 0.2);
      }
      .status-reprovada {
        background-color: rgba(231, 76, 60, 0.2);
      }
      .status-reavaliacao {
        background-color: rgba(52, 152, 219, 0.2);
      }

      .filter-container {
        margin-bottom: 15px;
      }

      .filter-row {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-bottom: 10px;
      }

      select,
      input[type="text"],
      input[type="date"] {
        padding: 10px;
        background-color: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: var(--text-color);
        border-radius: 4px;
      }

      select {
        appearance: none;
        background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
        background-repeat: no-repeat;
        background-position: right 10px center;
        background-size: 16px;
        padding-right: 30px;
      }

      select option {
        background-color: var(--bg-color);
        color: var(--text-color);
      }

      .status-invalida {
        background-color: rgba(158, 20, 20, 0.3);
        position: relative;
      }

      .invalid-badge {
        background-color: #c0392b;
        color: white;
        padding: 2px 5px;
        border-radius: 3px;
        font-size: 0.8em;
        font-weight: bold;
      }

      .invalid-approval-warning {
        background-color: rgba(231, 76, 60, 0.2);
        padding: 10px;
        border-left: 4px solid #e74c3c;
        margin-bottom: 15px;
      }

      .invalid-approval {
        color: #e74c3c;
        font-weight: bold;
      }

      .charts-container {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        margin-bottom: 20px;
      }

      .chart-box {
        flex: 1 0 300px;
        background-color: rgba(255, 255, 255, 0.05);
        padding: 15px;
        border-radius: 8px;
        height: 300px; /* Altura fixa para evitar esticamento */
        position: relative; /* Importante para posicionamento do canvas */
      }

      .chart-title {
        text-align: center;
        margin-bottom: 10px;
        font-weight: bold;
      }

      canvas {
        width: 100% !important;
        height: 220px !important; /* Altura fixa para o canvas */
        max-height: 220px !important; /* Garantir altura máxima */
      }

      .message-card {
        background-color: rgba(255, 255, 255, 0.05);
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 15px;
        border-left: 3px solid var(--highlight);
      }

      .message-header {
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
        font-weight: bold;
      }

      .message-content {
        white-space: pre-wrap;
        margin-left: 15px;
        color: rgba(255, 255, 255, 0.8);
      }

      .missing-fields {
        background-color: rgba(231, 76, 60, 0.2);
        padding: 5px;
        border-radius: 4px;
        font-size: 0.9em;
      }

      @media (max-width: 768px) {
        .filter-row {
          flex-direction: column;
        }

        .chart-box {
          flex: 1 0 100%;
        }
      }


      /* Adicionar isso ao bloco de estilos CSS existente */
.view-icon {
  cursor: pointer;
  color: var(--highlight);
  font-size: 1.2em;
  display: flex;
  justify-content: center;
  align-items: center;
}

.view-icon:hover {
  color: white;
  transform: scale(1.2);
  transition: all 0.2s ease-in-out;
}

.modal {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgba(0, 0, 0, 0.7);
}

.modal-content {
  background-color: var(--bg-color);
  margin: 10% auto;
  padding: 20px;
  border: 1px solid var(--highlight);
  border-radius: 8px;
  width: 80%;
  max-width: 800px;
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
}

.close-modal {
  color: var(--text-color);
  float: right;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
}

.close-modal:hover {
  color: var(--highlight);
}

.message-view {
  margin-top: 15px;
  white-space: pre-wrap;
  background-color: rgba(255, 255, 255, 0.05);
  padding: 15px;
  border-radius: 5px;
  border-left: 3px solid var(--highlight);
}

.message-header {
  margin-bottom: 10px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  padding-bottom: 10px;
}




    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>OAE Support</h1>
        <p>Ferramenta de geração de estatisticas de avaliação de OAEs</p>
      </header>

      <div class="card">

        <!-- Adicionar isso dentro da div "card", antes do textarea -->
<div class="format-selector">
  <label for="dateFormatSelect">Formato de Data:</label>
  <select id="dateFormatSelect">
    <option value="auto">Detecção Automática</option>
    <option value="DD/MM/YYYY">Dia/Mês/Ano (DD/MM/YYYY)</option>
    <option value="MM/DD/YYYY">Mês/Dia/Ano (MM/DD/YYYY)</option>
  </select>
  <span id="detectedFormat"></span>
</div>

        <textarea
          id="whatsappText"
          placeholder="Cole aqui as mensagens exportadas do WhatsApp..."
        ></textarea>
        <div class="button-group">
          <button id="processBtn">Processar Mensagens</button>
          <button id="exportBtn" disabled>Exportar para CSV</button>
        </div>
      </div>

      <div class="tabs">
        <div class="tab active" data-tab="dados">Dados</div>
        <div class="tab" data-tab="estatisticas">Estatísticas</div>
        <div class="tab" data-tab="despadronizadas">Despadronizadas</div>
      </div>

      <!-- Tab: Dados -->
      <div id="dados-tab" class="tab-content active">
        <div class="card">
          <div class="filter-container">
            <div class="filter-row">
              <select id="filterLote">
                <option value="">Todos os Lotes</option>
              </select>
              <select id="filterStatus">
                <option value="">Todos os Status</option>
              </select>
              <select id="filterTipo">
                <option value="">Todos os Tipos</option>
              </select>
              <input
                type="text"
                id="filterCodigo"
                placeholder="Filtrar por Código"
              />

              <div class="summary-container">
                <h3>Sumário dos Dados</h3>
                <div id="dataSummary" class="summary-content"></div>
              </div>
            </div>

            <div class="filter-row">
              <label for="startDate">Data inicial:</label>
              <input type="text" id="startDate" placeholder="DD/MM/AAAA" />
              <label for="endDate">Data final:</label>
              <input type="text" id="endDate" placeholder="DD/MM/AAAA" />
              <button id="applyFiltersBtn">Aplicar Filtros</button>
              <button id="clearFiltersBtn">Limpar Filtros</button>
            </div>
          </div>

          <table id="resultTable">
            <thead>
              <tr>
                <th>Data</th>
                <th>Remetente</th>
                <th>Lote</th>
                <th>Código OAE</th>
                <th>Tipo de Inspeção</th>
                <th>Data de Entrega/Envio</th>
                <th>Data de Recebimento</th>
                <th>Data de Devolução/Retorno</th>
                <th>Status</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td colspan="9" style="text-align: center">
                  Nenhum dado processado. Cole as mensagens e clique em
                  "Processar".
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- Tab: Despadronizadas -->
      <div id="despadronizadas-tab" class="tab-content">
        <div class="card">
          <h2>Mensagens com Formato Irregular</h2>
          <p>
            Abaixo estão listadas mensagens que não seguem completamente o
            padrão esperado:
          </p>
          <div id="irregularMessages">
            <p>Nenhuma mensagem irregular encontrada.</p>
          </div>
        </div>
      </div>
    </div>

    <!-- Tab: Estatísticas -->
    <div id="estatisticas-tab" class="tab-content">
      <div class="filter-container stats-filter">
        <div class="filter-row">
          <select id="statsTipoFilter">
            <option value="">Todos os Tipos de Inspeção</option>
            <option value="CADASTRAL">CADASTRAL</option>
            <option value="ROTINEIRA">ROTINEIRA</option>
            <option value="CORREÇÃO DE CADASTRO">CORREÇÃO DE CADASTRO</option>
          </select>
          <select id="statsLoteFilter">
            <option value="">Todos os Lotes</option>
          </select>
          <button id="applyStatsFiltersBtn">Aplicar Filtros</button>
          <button id="clearStatsFiltersBtn">Limpar Filtros</button>
        </div>
      </div>
      <div id="statsFilterInfo"><h3>Estatísticas</h3></div>
      <div class="charts-container">
        <div class="chart-box">
          <div class="chart-title">Quantidade por Status</div>
          <canvas id="statusChart"></canvas>
        </div>
        <div class="chart-box">
          <div class="chart-title">Reprovações por Código OAE</div>
          <canvas id="reprovacaoChart"></canvas>
        </div>
      </div>
      <div class="charts-container">
        <div class="chart-box">
          <div class="chart-title">Quem mais Aprova</div>
          <canvas id="aprovadorChart"></canvas>
        </div>
        <div class="chart-box">
          <div class="chart-title">Quem mais Reprova</div>
          <canvas id="reprovadorChart"></canvas>
        </div>
      </div>
      <div class="charts-container">
        <div class="chart-box">
          <div class="chart-title">Tempo Médio de Avaliação (Dias)</div>
          <canvas id="tempoChart"></canvas>
        </div>
        <div class="chart-box">
          <div class="chart-title">Tipo de Inspeção</div>
          <canvas id="tipoChart"></canvas>
        </div>
      </div>

      <!-- Adicionar este código após a última tag div de fechamento -->
<div id="messageModal" class="modal">
  <div class="modal-content">
    <span class="close-modal">&times;</span>
    <div class="message-header">
      <h3>Detalhes da Mensagem</h3>
      <p id="messageInfo"></p>
    </div>
    <div id="messageView" class="message-view"></div>
  </div>
</div>

    </div>

    <script>
      // Versão: 6.0 - Correções para processamento de mensagens OAE

      // Adicionar depois do DOMContentLoaded no início do script
document.getElementById("dateFormatSelect").addEventListener("change", function() {
    userSelectedFormat = this.value;
    localStorage.setItem("oaePreferredDateFormat", userSelectedFormat);
    
    if (processedData.length > 0) {
        // Reprocessar os dados se necessário
        updateTable();
    }
});

// Carregar configuração salva (adicionar antes de document.addEventListener("DOMContentLoaded"...))
if (localStorage.getItem("oaePreferredDateFormat")) {
    userSelectedFormat = localStorage.getItem("oaePreferredDateFormat");
    // Definir o valor selecionado depois do DOM estar carregado
    document.addEventListener("DOMContentLoaded", function() {
        document.getElementById("dateFormatSelect").value = userSelectedFormat;
    });
}


      document.addEventListener("DOMContentLoaded", function () {
        // Função de formatação de data para o formato brasileiro
        function formatDateBR(dateStr) {
          if (!dateStr) return "";

          // Se já estiver no formato DD/MM/YYYY, retornar como está
          if (/^\d{2}\/\d{2}\/\d{4}$/.test(dateStr)) {
            return dateStr;
          }

          // Se estiver no formato YYYY-MM-DD (do input date), converter para DD/MM/YYYY
          if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
            const parts = dateStr.split("-");
            return `${parts[2]}/${parts[1]}/${parts[0]}`;
          }

          // Tentar converter de outras formas
          try {
            const date = new Date(dateStr);
            if (!isNaN(date.getTime())) {
              const day = String(date.getDate()).padStart(2, "0");
              const month = String(date.getMonth() + 1).padStart(2, "0");
              const year = date.getFullYear();
              return `${day}/${month}/${year}`;
            }
          } catch (e) {
            // Se falhar, retornar o original
          }

          return dateStr;
        }

        // Elementos DOM
        const whatsappText = document.getElementById("whatsappText");
        const processBtn = document.getElementById("processBtn");
        const exportBtn = document.getElementById("exportBtn");
        const resultTable = document.getElementById("resultTable");

        const filterLote = document.getElementById("filterLote");
        const filterStatus = document.getElementById("filterStatus");
        const filterTipo = document.getElementById("filterTipo");
        const filterCodigo = document.getElementById("filterCodigo");
        const startDate = document.getElementById("startDate");
        const endDate = document.getElementById("endDate");
        const applyFiltersBtn = document.getElementById("applyFiltersBtn");
        const clearFiltersBtn = document.getElementById("clearFiltersBtn");
        const tabs = document.querySelectorAll(".tab");
        const tabContents = document.querySelectorAll(".tab-content");
        const irregularMessages = document.getElementById("irregularMessages");

        // Adicionar no bloco DOMContentLoaded
        document
          .getElementById("applyStatsFiltersBtn")
          .addEventListener("click", applyStatsFilters);
        document
          .getElementById("clearStatsFiltersBtn")
          .addEventListener("click", clearStatsFilters);

        // Dados
        let processedData = [];
        let irregularData = [];
let detectedDateFormat = "DD/MM/YYYY"; // Formato padrão (BR)
let userSelectedFormat = "auto"; // Auto por padrã


        // Event Listeners
        processBtn.addEventListener("click", processMessages);
        exportBtn.addEventListener("click", exportToCSV);
        applyFiltersBtn.addEventListener("click", applyFilters);
        clearFiltersBtn.addEventListener("click", clearFilters);

        // Tabs
        tabs.forEach((tab) => {
          tab.addEventListener("click", () => {
            // Desativar todas as abas
            tabs.forEach((t) => t.classList.remove("active"));
            tabContents.forEach((t) => t.classList.remove("active"));

            // Ativar a aba clicada
            tab.classList.add("active");
            document
              .getElementById(tab.dataset.tab + "-tab")
              .classList.add("active");

            // Se for a aba de estatísticas e houver dados, atualizar gráficos
            if (
              tab.dataset.tab === "estatisticas" &&
              processedData.length > 0
            ) {
              updateCharts();
            }
          });
        });

        // MELHORIAS #1: Função robusta para normalizar lotes (remove zeros à esquerda)
        function normalizeLote(lote) {
          if (!lote) return "";

          // Remover espaços extras
          const trimmedLote = lote.trim();

          // Verificar se é um número
          if (/^\d+$/.test(trimmedLote)) {
            // Converter para número e depois para string para remover zeros à esquerda
            return parseInt(trimmedLote, 10).toString();
          }

          return trimmedLote;
        }

        // MELHORIAS #1: Modificar a função extractLote para normalizar o lote após extração
        function extractLote(text, message) {
          // Melhorar regex para capturar lotes com qualquer número de dígitos
          const loteMatch =
            text.match(/Lote:?\s*(\d+)/i) || text.match(/Lote\s*(\d+)/i);

          if (loteMatch) {
            // Normalizar o lote ao extrair
            message.lote = normalizeLote(loteMatch[1]);
          }
        }

        // MELHORIAS #2: Função melhorada para normalização de tipos de inspeção
        function normalizeTipoInspecao(tipo) {
          if (!tipo) return "";

          const normalized = normalizeText(tipo);

          // Verificações mais robustas para CADASTRAL
          if (
            normalized.includes("cadastral") ||
            normalized.includes("cadstral") ||
            normalized.includes("cdastral") ||
            normalized.includes("cdstral") ||
            normalized.includes("cadastrais") ||
            normalized.includes("cadatral")
          ) {
            return "CADASTRAL";
          }

          // Verificações mais robustas para ROTINEIRA
          if (
            normalized.includes("rotineira") ||
            normalized.includes("rotinera") ||
            normalized.includes("rotineirra") ||
            normalized.includes("rotinieira")
          ) {
            return "ROTINEIRA";
          }

          // Verificações mais robustas para CORREÇÃO DE CADASTRO
          if (
            normalized.includes("correcao") ||
            normalized.includes("correção") ||
            normalized.includes("retificacao") ||
            normalized.includes("retificação") ||
            normalized.includes("cadastro corrigido")
          ) {
            return "CORREÇÃO DE CADASTRO";
          }

          // Se não encontrar nenhum padrão conhecido, retornar o original em maiúsculas
          return tipo.toUpperCase();
        }

       
        // Substitua a função detectDateFormat existente por esta versão melhorada
function detectDateFormat(messages) {
    // Primeiro, verificar se o usuário escolheu um formato específico
    if (userSelectedFormat !== "auto") {
        return userSelectedFormat;
    }

    // Analisar as mensagens para detectar o formato
    for (const message of messages) {
        if (message.data) {
            // Primeiro verificar formato com colchetes [MM/DD/YY] ou [DD/MM/YY]
            const bracketMatch = message.data.match(/\[(\d{1,2})\/(\d{1,2})\/(\d{2,4})/);
            if (bracketMatch) {
                const firstNumber = parseInt(bracketMatch[1], 10);
                const secondNumber = parseInt(bracketMatch[2], 10);
                
                // Se o primeiro número > 12, então é um dia (formato DD/MM)
                if (firstNumber > 12 && secondNumber <= 12) {
                    return "DD/MM/YYYY";
                }
                
                // Se o segundo número > 12, então é um dia (formato MM/DD)
                if (secondNumber > 12 && firstNumber <= 12) {
                    return "MM/DD/YYYY";
                }
            }
            
            // Verificar formato sem colchetes DD/MM/YYYY ou MM/DD/YYYY
            const datePart = message.data.split(" ")[0];
            if (datePart.includes("/")) {
                const parts = datePart.split("/");
                if (parts.length === 3) {
                    const firstNumber = parseInt(parts[0], 10);
                    const secondNumber = parseInt(parts[1], 10);
                    
                    // Se o primeiro número > 12, então é um dia (formato DD/MM)
                    if (firstNumber > 12 && secondNumber <= 12) {
                        return "DD/MM/YYYY";
                    }
                    
                    // Se o segundo número > 12, então é um dia (formato MM/DD)
                    if (secondNumber > 12 && firstNumber <= 12) {
                        return "MM/DD/YYYY";
                    }
                }
            }
        }
    }
    
    // Verificar nas datas de entrega/recebimento/devolução
    for (const message of messages) {
        // Verificar todas as datas adicionais no objeto
        const dates = [message.dataEntrega, message.dataRecebimento, message.dataDevolucao];
        
        for (const date of dates) {
            if (date && date.includes("/")) {
                const parts = date.split("/");
                if (parts.length === 3) {
                    const firstNumber = parseInt(parts[0], 10);
                    const secondNumber = parseInt(parts[1], 10);
                    
                    if (firstNumber > 12 && secondNumber <= 12) {
                        return "DD/MM/YYYY";
                    }
                    if (secondNumber > 12 && firstNumber <= 12) {
                        return "MM/DD/YYYY";
                    }
                }
            }
        }
    }
    
    // Se não conseguir detectar, usar o padrão brasileiro
    return "DD/MM/YYYY";
}


        // Função para formatar qualquer data no formato brasileiro
        function formatDateBrazilian(dateObj) {
          if (
            !dateObj ||
            !(dateObj instanceof Date) ||
            isNaN(dateObj.getTime())
          ) {
            return "";
          }

          const day = String(dateObj.getDate()).padStart(2, "0");
          const month = String(dateObj.getMonth() + 1).padStart(2, "0");
          const year = dateObj.getFullYear();

          return `${day}/${month}/${year}`;
        }

        // MELHORIAS #3: Função robusta para interpretar múltiplos formatos de data
        function parseComplexDate(dateStr) {
          if (!dateStr) return null;

          // Remover espaços extras
          dateStr = dateStr.trim();

          // Tratar formato DD/MM/YYYY
          const dmyMatch = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
          if (dmyMatch) {
            const day = parseInt(dmyMatch[1], 10);
            const month = parseInt(dmyMatch[2], 10) - 1; // Meses em JS são 0-indexed
            const year = parseInt(dmyMatch[3], 10);

            // Verificar se o formato detectado é MM/DD/YYYY
            if (detectedDateFormat === "MM/DD/YYYY") {
              // Inverter dia e mês
              return new Date(year, day - 1, month + 1);
            } else {
              return new Date(year, month, day);
            }
          }

          // Tratar formato DD/MM/YY (ano com 2 dígitos)
          const dmyShortMatch = dateStr.match(
            /^(\d{1,2})\/(\d{1,2})\/(\d{2})$/
          );
          if (dmyShortMatch) {
            const day = parseInt(dmyShortMatch[1], 10);
            const month = parseInt(dmyShortMatch[2], 10) - 1;
            let year = parseInt(dmyShortMatch[3], 10);
            // Converter ano de 2 dígitos para 4 dígitos
            year = year < 50 ? 2000 + year : 1900 + year;

            // Verificar se o formato detectado é MM/DD/YYYY
            if (detectedDateFormat === "MM/DD/YYYY") {
              // Inverter dia e mês
              return new Date(year, day - 1, month + 1);
            } else {
              return new Date(year, month, day);
            }
          }

          // Tratar formato YYYY-MM-DD (usado pelo input HTML)
          const isoMatch = dateStr.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
          if (isoMatch) {
            const year = parseInt(isoMatch[1], 10);
            const month = parseInt(isoMatch[2], 10) - 1;
            const day = parseInt(isoMatch[3], 10);

            return new Date(year, month, day);
          }

          // Se não conseguir reconhecer o formato, retornar null
          return null;
        }

        // MELHORIAS #3: Extrair data de mensagem em qualquer formato
        function extractDateFromMessage(dateString) {
          if (!dateString) return null;

          // Extrair a parte da data (sem horário)
          let datePart = null;

          // Formato com colchetes [DD/MM/YY, HH:MM:SS]
          const bracketMatch = dateString.match(
            /\[(\d{1,2}\/\d{1,2}\/\d{2,4}),/
          );
          if (bracketMatch) {
            datePart = bracketMatch[1];
          }
          // Formato padrão DD/MM/YYYY HH:MM
          else if (dateString.includes("/")) {
            datePart = dateString.split(" ")[0];
          }

          if (datePart) {
            return parseComplexDate(datePart);
          }

          return null;
        }

        // Função auxiliar para validar datas
        function isValidDate(date) {
          return date instanceof Date && !isNaN(date.getTime());
        }

        // MELHORIAS #4: Função para ordenação de mensagens por data (mais recentes primeiro)
        function sortMessagesByDate(messages) {
          return messages.sort((a, b) => {
            const dateA = extractDateFromMessage(a.data);
            const dateB = extractDateFromMessage(b.data);

            if (dateA && dateB) {
              // Ordem decrescente (mais recente primeiro)
              return dateB - dateA;
            }

            // Fallback para comparação de strings se não conseguir extrair as datas
            return (b.data || "").localeCompare(a.data || "");
          });
        }

        // Função melhorada para processamento de mensagens
        function processMessages() {
          const text = whatsappText.value.trim();
          if (!text) {
            alert("Por favor, cole o texto das conversas do WhatsApp.");
            return;
          }

          // Limpar dados anteriores
          processedData = [];
          irregularData = [];

          // Feedback visual
          resultTable.querySelector("tbody").innerHTML =
            '<tr><td colspan="9" style="text-align: center;">Processando...</td></tr>';

          // Separar as linhas
          const lines = text.split("\n");
          console.log(`Processando ${lines.length} linhas`);

          // Variáveis para processamento
          let currentMessage = null;
          let currentText = "";
          let isProcessingMessage = false;

          // Processar cada linha
          for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();

            // Pular linhas vazias
            if (!line) continue;

            // Verificar se é mensagem do sistema
            if (isSystemMessage(line)) {
              continue;
            }

            // Verificar diferentes formatos de início de mensagem

            // Formato [DD/MM/YY, HH:MM:SS] Remetente: Conteúdo
            const bracketDateMatch = line.match(
              /^\[(\d{1,2}\/\d{1,2}\/\d{2,4}),\s*(\d{1,2}:\d{2}(?::\d{2})?)\]\s*(.+?):\s*(.*)$/
            );

            // Formato DD/MM/YYYY HH:MM - Remetente: Conteúdo
            const standardDateMatch = line.match(
              /^(\d{1,2}\/\d{1,2}\/\d{4})\s+(\d{1,2}:\d{2}(?::\d{2})?)\s*-\s*(.+?):\s*(.*)$/
            );

            if (bracketDateMatch) {
              // Salvar mensagem anterior se existir
              if (isProcessingMessage && currentMessage) {
                checkAndSaveMessage(currentMessage, currentText);
              }

              // Iniciar nova mensagem com formato [DD/MM/YY, HH:MM:SS]
              const date = bracketDateMatch[1];
              const time = bracketDateMatch[2];
              const sender = bracketDateMatch[3];
              const content = bracketDateMatch[4];

              currentMessage = {
                data: `${date} ${time}`,
                remetente: sender,
                lote: "",
                codigoOAE: "",
                tipoInspecao: "",
                dataEntrega: "",
                dataRecebimento: "",
                dataDevolucao: "",
                status: "",
              };

              currentText = content;
              isProcessingMessage = true;

              // Processar conteúdo inicial
              extractData(content, currentMessage);
            } else if (standardDateMatch) {
              // Salvar mensagem anterior se existir
              if (isProcessingMessage && currentMessage) {
                checkAndSaveMessage(currentMessage, currentText);
              }

              // Iniciar nova mensagem com formato DD/MM/YYYY HH:MM
              const date = standardDateMatch[1];
              const time = standardDateMatch[2];
              const sender = standardDateMatch[3];
              const content = standardDateMatch[4];

              currentMessage = {
                data: `${date} ${time}`,
                remetente: sender,
                lote: "",
                codigoOAE: "",
                tipoInspecao: "",
                dataEntrega: "",
                dataRecebimento: "",
                dataDevolucao: "",
                status: "",
              };

              currentText = content;
              isProcessingMessage = true;

              // Processar conteúdo inicial
              extractData(content, currentMessage);
            } else if (isProcessingMessage && currentMessage) {
              // Linha de continuação
              currentText += "\n" + line;
              extractData(line, currentMessage);
            }
          }

          // Processar a última mensagem
          if (isProcessingMessage && currentMessage) {
            checkAndSaveMessage(currentMessage, currentText);
          }

          // MELHORIAS #3: Detectar formato de data com base nas mensagens processadas
          detectedDateFormat = detectDateFormat(processedData);
          console.log(`Formato de data detectado: ${detectedDateFormat}`);

          // MELHORIAS #4: Ordenar mensagens por data (mais recentes primeiro)
          processedData = sortMessagesByDate(processedData);

          console.log(
            `Mensagens processadas: ${processedData.length}, Irregulares: ${irregularData.length}`
          );

          // Atualizar interface
          updateTable();
          updateFilterOptions();
          updateIrregularMessages();
          initializeDateFilters();
          initializeStatsFilters();

          // Habilitar exportação
          exportBtn.disabled = processedData.length === 0;
        }

        function isSystemMessage(line) {
          return (
            line.includes("As mensagens e ligações são protegidas") ||
            line.includes("criou o grupo") ||
            line.includes("adicionou você") ||
            line.includes("mudou a descrição do grupo") ||
            line.includes("mudou o assunto") ||
            line.includes("mensagens e ligações são protegidas") ||
            line.includes("Você adicionou") ||
            line.includes("adicionou") ||
            line.match(/^‎.*adicionou/) !== null ||
            line.match(/^‎.*mudou/) !== null ||
            line.match(/^‎.*criou/) !== null ||
            line.match(/‎/) !== null // Caractere invisível usado pelo WhatsApp em mensagens de sistema
          );
        }

        function extractData(text, message) {
          // Extrair Lote
          extractLote(text, message);

          // Extrair Código OAE
          extractCodigoOAE(text, message);

          // Extrair Tipo de Inspeção
          extractTipoInspecao(text, message);

          // Extrair Datas
          extractDatas(text, message);

          // Extrair Status
          extractStatus(text, message);
        }

        function extractCodigoOAE(text, message) {
          const codigoMatch =
            text.match(/Código OAE:?\s*([0-9\/]+)/i) ||
            text.match(/Código\s*(?:da)?\s*OAE:?\s*([0-9\/]+)/i) ||
            text.match(/OAE:?\s*([0-9\/]+)/i);
          if (codigoMatch) {
            message.codigoOAE = codigoMatch[1].trim();
          }
        }

        function extractTipoInspecao(text, message) {
          const tipoMatch =
            text.match(/Tipo de Inspeção:?\s*([A-Za-zÀ-ú\s]+)/i) ||
            text.match(/Tipo\s*(?:de)?\s*Inspeção:?\s*([A-Za-zÀ-ú\s]+)/i);

          if (tipoMatch) {
            message.tipoInspecao = normalizeTipoInspecao(tipoMatch[1].trim());
          } else if (text.includes("Cadastral") || text.includes("CADASTRAL")) {
            message.tipoInspecao = "CADASTRAL";
          } else if (text.includes("Cdastral") || text.includes("CADASTRAL")) {
            message.tipoInspecao = "CADASTRAL";
          } else if (text.includes("Rotineira") || text.includes("ROTINEIRA")) {
            message.tipoInspecao = "ROTINEIRA";
          } else if (
            text.includes("Correção de Cadastro") ||
            text.includes("CORREÇÃO DE CADASTRO") ||
            text.includes("Correcao de Cadastro")
          ) {
            message.tipoInspecao = "CORREÇÃO DE CADASTRO";
          }

          // Também verificar campos específicos
          const fieldMatch = text.match(/^([A-Za-zÀ-ú\s]+):\s*(.+)$/);
          if (fieldMatch) {
            const field = normalizeText(fieldMatch[1].trim());
            const value = fieldMatch[2].trim();

            if (field.includes("tipo") || field.includes("inspecao")) {
              message.tipoInspecao = normalizeTipoInspecao(value);
            }
          }
        }

        function extractDatas(text, message) {
          // Data de Entrega/Envio
          const dataEntregaMatch =
            text.match(/Data de [Ee]ntrega:?\s*(\d{2}\/\d{2}\/\d{4})/) ||
            text.match(/Data de [Ee]nvio:?\s*(\d{2}\/\d{2}\/\d{4})/) ||
            text.match(
              /Data(?:\s*de)?\s*(?:[Ee]ntrega|[Ee]nvio):?\s*(\d{2}\/\d{2}\/\d{4})/
            );
          if (dataEntregaMatch) {
            message.dataEntrega = dataEntregaMatch[1];
          }

          // Data de Recebimento
          const dataRecebimentoMatch =
            text.match(/Data de [Rr]ecebimento:?\s*(\d{2}\/\d{2}\/\d{4})/) ||
            text.match(
              /Data(?:\s*de)?\s*[Rr]ecebimento:?\s*(\d{2}\/\d{2}\/\d{4})/
            );
          if (dataRecebimentoMatch) {
            message.dataRecebimento = dataRecebimentoMatch[1];
          }

          // Data de Devolução/Retorno
          const dataDevolucaoMatch =
            text.match(/Data de [Dd]evolução:?\s*(\d{2}\/\d{2}\/\d{4})/) ||
            text.match(/Data de [Rr]etorno:?\s*(\d{2}\/\d{2}\/\d{4})/) ||
            text.match(
              /Data(?:\s*de)?\s*(?:[Dd]evolução|[Rr]etorno):?\s*(\d{2}\/\d{2}\/\d{4})/
            );
          if (dataDevolucaoMatch) {
            message.dataDevolucao = dataDevolucaoMatch[1];
          }

          // Também verificar campos específicos
          const fieldMatch = text.match(/^([A-Za-zÀ-ú\s]+):\s*(.+)$/);
          if (fieldMatch) {
            const field = normalizeText(fieldMatch[1].trim());
            const value = fieldMatch[2].trim();

            if (
              field.includes("data") &&
              (field.includes("entrega") || field.includes("envio"))
            ) {
              message.dataEntrega = value;
            } else if (
              field.includes("data") &&
              field.includes("recebimento")
            ) {
              message.dataRecebimento = value;
            } else if (
              field.includes("data") &&
              (field.includes("devolucao") || field.includes("retorno"))
            ) {
              message.dataDevolucao = value;
            }
          }
        }

        // MELHORIAS #2: Função robusta para normalização de status
        function normalizeStatus(status) {
          if (!status) return "";

          // Tratar casos de strings truncadas
          if (
            status.endsWith("AVALIAC") ||
            status.endsWith("AVALIACÃ") ||
            status.endsWith("AVALIACA")
          ) {
            return "AVALIAÇÃO";
          }

          // Remover caracteres especiais e normalizar espaços
          let normalized = normalizeText(status)
            .replace(/\s+/g, " ") // Substituir múltiplos espaços por um único
            .trim();

          // Verificar prefixos numéricos para reavaliação
          const reavaliacaoMatch = normalized.match(
            /^(\d+)[ªa°]?\s*r?e?a?v?a?l?i?a?c?a?o?$/i
          );
          if (reavaliacaoMatch || /^[123456789]$/.test(normalized)) {
            const numero = reavaliacaoMatch ? reavaliacaoMatch[1] : normalized;
            return `${numero}ª REAVALIAÇÃO`;
          }

          // Padrões específicos com palavras que podem estar juntas
          if (/obraaguardando|aguardandodrone|obradrone/.test(normalized)) {
            return "OBRA AGUARDANDO DRONE";
          }

          if (/correcaocadastral|cadastralcorrecao/.test(normalized)) {
            return "CORREÇÃO CADASTRAL";
          }

          // Padrões para cada tipo de status
          const statusPatterns = {
            APROVADA: [
              "aprovad",
              "aprovacao",
              "aprovação",
              "liberada",
              "aceita",
            ],
            REPROVADA: [
              "reprovad",
              "reprovacao",
              "rejeitad",
              "desaprovad",
              "nao aprovad",
              "não aprovad",
            ],
            AVALIAÇÃO: [
              "avaliaca",
              "avaliac",
              "aAvaliaca",
              "avaliaca",
              "avaliaca",
              "avaliaCã",
              "avaliação",
              "analise",
              "análise",
            ],
            REAVALIAÇÃO: ["reavaliaca", "reavaliaçã", "reavaliação"],
            "OBRA AGUARDANDO DRONE": ["aguardando", "drone", "fotos"],
            "CORREÇÃO CADASTRAL": [
              "correcao",
              "correção",
              "cadastr",
              "retifica",
            ],
          };

          // Verificar cada padrão
          for (const [padrao, variantes] of Object.entries(statusPatterns)) {
            for (const variante of variantes) {
              if (normalized.includes(variante)) {
                return padrao;
              }
            }
          }

          // Se não encontrou nenhum padrão conhecido, retornar o original em maiúsculas
          return status.toUpperCase();
        }

        function extractStatus(text, message) {
          const statusMatch = text.match(
            /Status:?\s*([A-Za-zÀ-ú\s0-9ª<>]+)(?:<|$)/i
          );

          if (statusMatch) {
            message.status = normalizeStatus(statusMatch[1].trim());
          } else if (
            text.toUpperCase().includes("APROVADA") ||
            text.includes("aprovada")
          ) {
            message.status = "APROVADA";
          } else if (
            text.toUpperCase().includes("REPROVADA") ||
            text.includes("reprovada")
          ) {
            message.status = "REPROVADA";
          } else if (
            text.toUpperCase().includes("AVALIAÇÃO") ||
            text.includes("Avaliação") ||
            text.includes("Avaliaçã") ||
            text.includes("avaliação")
          ) {
            message.status = "AVALIAÇÃO";
          } else if (
            text.toUpperCase().includes("REAVALIAÇÃO") ||
            text.includes("Reavaliação") ||
            text.includes("reavaliação")
          ) {
            message.status = "REAVALIAÇÃO";
          } else if (text.match(/(\d+)[ªa°]?\s*[re]*avalia[cç][aã]o/i)) {
            const match = text.match(/(\d+)[ªa°]?\s*[re]*avalia[cç][aã]o/i);
            message.status = `${match[1]}ª REAVALIAÇÃO`;
          } else if (
            text.includes("RETIFICAÇÃO DE CADASTRO") ||
            normalizeText(text).includes("retificacao")
          ) {
            message.status = "RETIFICAÇÃO DE CADASTRO";
          }

          // Também verificar campos específicos
          const fieldMatch = text.match(/^([A-Za-zÀ-ú\s]+):\s*(.+)$/);
          if (fieldMatch) {
            const field = normalizeText(fieldMatch[1].trim());
            const value = fieldMatch[2].trim();

            if (field.includes("status")) {
              message.status = normalizeStatus(value);
            }
          }
        }

      // Modifique a função checkAndSaveMessage para armazenar o texto original
function checkAndSaveMessage(message, text) {
  // Armazenar o texto completo da mensagem
  message.textoOriginal = text;
  
  // Verificar campos obrigatórios
  const missingFields = [];
  let fieldsCount = 0;

  if (message.lote) fieldsCount++;
  else missingFields.push("Lote");

  if (message.codigoOAE) fieldsCount++;
  else missingFields.push("Código OAE");

  if (message.tipoInspecao) fieldsCount++;
  else missingFields.push("Tipo de Inspeção");

  if (message.status) fieldsCount++;
  else missingFields.push("Status");

  // Só adicionar aos dados processados se tiver pelo menos os campos obrigatórios
  if (fieldsCount >= 3) {
    processedData.push(message);
  }

  // Se faltam campos, marcar como irregular
  if (fieldsCount < 3) {
    irregularData.push({
      data: message.data,
      remetente: message.remetente,
      texto: text,
      camposFaltantes: missingFields.join(", "),
    });
  }
}




        // MELHORIAS #1: Aplicar normalização de lotes nos filtros
        function applyFilters() {
          const loteFilter = normalizeLote(filterLote.value);
          const statusFilter = filterStatus.value;
          const tipoFilter = filterTipo.value;
          const codigoFilter = filterCodigo.value.toLowerCase();

          // Processar datas para filtro
          let startDateValue = startDate.value
            ? parseComplexDate(startDate.value)
            : null;
          let endDateValue = endDate.value
            ? parseComplexDate(endDate.value)
            : null;

          // Ajustar horário da data final para incluir o dia inteiro
          if (endDateValue) {
            endDateValue.setHours(23, 59, 59, 999);
          }

          const filteredData = processedData.filter((message) => {
            // Filtros de texto com normalização de lote
            const matchesText =
              (loteFilter === "" ||
                normalizeLote(message.lote) === loteFilter) &&
              (statusFilter === "" ||
                normalizeStatus(message.status) === statusFilter) &&
              (tipoFilter === "" ||
                normalizeTipoInspecao(message.tipoInspecao) === tipoFilter) &&
              (codigoFilter === "" ||
                (message.codigoOAE &&
                  message.codigoOAE.toLowerCase().includes(codigoFilter)));

            // Filtros de data
            let matchesDate = true;

            if (startDateValue || endDateValue) {
              const messageDate = extractDateFromMessage(message.data);

              if (messageDate) {
                if (startDateValue && messageDate < startDateValue) {
                  matchesDate = false;
                }

                if (endDateValue && messageDate > endDateValue) {
                  matchesDate = false;
                }
              } else {
                matchesDate = false;
              }
            }

            return matchesText && matchesDate;
          });

          console.log(
            `Filtrados ${filteredData.length} de ${processedData.length} registros`
          );
          updateTable(filteredData);
        }

        // MELHORIAS #1: Modificar a função updateFilterOptions para agrupar lotes normalizados
        function updateFilterOptions() {
          // Limpar opções atuais
          filterLote.innerHTML = '<option value="">Todos os Lotes</option>';
          filterStatus.innerHTML = '<option value="">Todos os Status</option>';
          filterTipo.innerHTML = '<option value="">Todos os Tipos</option>';

          // Mapa para lotes normalizados e originais
          const lotesMap = new Map();
          const status = new Set();
          const tipos = new Set();

          // Coletar valores únicos
          processedData.forEach((message) => {
            if (message.lote) {
              const normalizedLote = normalizeLote(message.lote);
              // Guardar o lote original junto com o normalizado
              if (
                !lotesMap.has(normalizedLote) ||
                message.lote.length < lotesMap.get(normalizedLote).length
              ) {
                lotesMap.set(normalizedLote, message.lote);
              }
            }

            if (message.status) status.add(normalizeStatus(message.status));
            if (message.tipoInspecao)
              tipos.add(normalizeTipoInspecao(message.tipoInspecao));
          });

          // Adicionar opções de lote ordenadas numericamente
          Array.from(lotesMap.keys())
            .sort((a, b) => parseInt(a, 10) - parseInt(b, 10))
            .forEach((lote) => {
              const option = document.createElement("option");
              option.value = lote;
              option.textContent = `Lote ${lote}`;
              filterLote.appendChild(option);
            });

          // Status - ordenados conforme definido
          const statusOrdem = [
            "APROVADA",
            "REPROVADA",
            "AVALIAÇÃO",
            "1ª REAVALIAÇÃO",
            "2ª REAVALIAÇÃO",
            "3ª REAVALIAÇÃO",
            "4ª REAVALIAÇÃO",
            "5ª REAVALIAÇÃO",
            "OBRA AGUARDANDO DRONE",
            "CORREÇÃO CADASTRAL",
          ];

          statusOrdem.forEach((st) => {
            if (status.has(st)) {
              const option = document.createElement("option");
              option.value = st;
              option.textContent = st;
              filterStatus.appendChild(option);
              status.delete(st);
            }
          });

          // Adicionar outros status não previstos
          status.forEach((st) => {
            const option = document.createElement("option");
            option.value = st;
            option.textContent = st;
            filterStatus.appendChild(option);
          });

          // Tipos de Inspeção
          const tiposOrdem = ["CADASTRAL", "ROTINEIRA", "CORREÇÃO DE CADASTRO"];

          tiposOrdem.forEach((tipo) => {
            if (tipos.has(tipo)) {
              const option = document.createElement("option");
              option.value = tipo;
              option.textContent = tipo;
              filterTipo.appendChild(option);
              tipos.delete(tipo);
            }
          });

          // Adicionar outros tipos não previstos
          tipos.forEach((tipo) => {
            const option = document.createElement("option");
            option.value = tipo;
            option.textContent = tipo;
            filterTipo.appendChild(option);
          });
        }

        // MELHORIAS #2: Atualizar a função applyStatsFilters para usar normalização de lote
        function applyStatsFilters() {
          const tipoFilter = document.getElementById("statsTipoFilter").value;
          const loteFilter = normalizeLote(
            document.getElementById("statsLoteFilter").value
          );

          // Filtrar dados
          const filteredData = processedData.filter((message) => {
            return (
              (tipoFilter === "" ||
                normalizeTipoInspecao(message.tipoInspecao) === tipoFilter) &&
              (loteFilter === "" || normalizeLote(message.lote) === loteFilter)
            );
          });

          // Atualizar gráficos com dados filtrados
          updateCharts(filteredData);
        }

        // MELHORIAS #1: Modificar a função initializeStatsFilters para usar normalização de lote
        function initializeStatsFilters() {
          // Adicionar opções de lote ao filtro de estatísticas
          const statsLoteFilter = document.getElementById("statsLoteFilter");
          if (statsLoteFilter) {
            statsLoteFilter.innerHTML =
              '<option value="">Todos os Lotes</option>';

            // Obter lotes únicos normalizados
            const lotesMap = new Map();
            processedData.forEach((message) => {
              if (message.lote) {
                const normalizedLote = normalizeLote(message.lote);
                if (
                  !lotesMap.has(normalizedLote) ||
                  message.lote.length < lotesMap.get(normalizedLote).length
                ) {
                  lotesMap.set(normalizedLote, message.lote);
                }
              }
            });

            // Adicionar opções ordenadas numericamente
            Array.from(lotesMap.keys())
              .sort((a, b) => parseInt(a, 10) - parseInt(b, 10))
              .forEach((lote) => {
                const option = document.createElement("option");
                option.value = lote;
                option.textContent = `Lote ${lote}`;
                statsLoteFilter.appendChild(option);
              });
          }

          // Adicionar opções para filtrar por tipo de inspeção
          const statsTipoFilter = document.getElementById("statsTipoFilter");
          if (statsTipoFilter) {
            // Limpar as opções existentes e manter a opção "Todos"
            statsTipoFilter.innerHTML =
              '<option value="">Todos os Tipos de Inspeção</option>';

            // Obter tipos únicos
            const tipos = new Set();
            processedData.forEach((message) => {
              if (message.tipoInspecao) {
                tipos.add(normalizeTipoInspecao(message.tipoInspecao));
              }
            });

            // Ordem predefinida para tipos
            const tiposOrdem = [
              "CADASTRAL",
              "ROTINEIRA",
              "CORREÇÃO DE CADASTRO",
            ];

            // Adicionar na ordem predefinida
            tiposOrdem.forEach((tipo) => {
              if (tipos.has(tipo)) {
                const option = document.createElement("option");
                option.value = tipo;
                option.textContent = tipo;
                statsTipoFilter.appendChild(option);
                tipos.delete(tipo);
              }
            });

            // Adicionar outros tipos não previstos
            tipos.forEach((tipo) => {
              const option = document.createElement("option");
              option.value = tipo;
              option.textContent = tipo;
              statsTipoFilter.appendChild(option);
            });
          }
        }

        // Função para limpar filtros de estatísticas
        function clearStatsFilters() {
          document.getElementById("statsTipoFilter").value = "";
          document.getElementById("statsLoteFilter").value = "";
          updateCharts(processedData); // Atualizar com todos os dados
        }

        // MELHORIAS #2: Modificar a função updateCharts para aceitar dados filtrados
        function updateCharts(dataToShow = processedData) {
          if (dataToShow.length === 0) return;

          // Mostrar gráficos apenas se a aba estatísticas estiver ativa
          if (
            !document
              .getElementById("estatisticas-tab")
              .classList.contains("active")
          ) {
            return;
          }

          // 1. Status counts
          const statusCounts = {};
          dataToShow.forEach((item) => {
            if (item.status) {
              const status = normalizeStatus(item.status);
              statusCounts[status] = (statusCounts[status] || 0) + 1;
            }
          });

          // 2. Reprovações por código
          const reprovacoesPorCodigo = {};
          dataToShow.forEach((item) => {
            if (
              normalizeStatus(item.status) === "REPROVADA" &&
              item.codigoOAE
            ) {
              reprovacoesPorCodigo[item.codigoOAE] =
                (reprovacoesPorCodigo[item.codigoOAE] || 0) + 1;
            }
          });

          // Ordenar e limitar a 10
          const topReprovados = Object.fromEntries(
            Object.entries(reprovacoesPorCodigo)
              .sort(([, a], [, b]) => b - a)
              .slice(0, 10)
          );

          // 3. Quem mais aprova
          const aprovadoresPorRemetente = {};
          dataToShow.forEach((item) => {
            if (normalizeStatus(item.status) === "APROVADA" && item.remetente) {
              aprovadoresPorRemetente[item.remetente] =
                (aprovadoresPorRemetente[item.remetente] || 0) + 1;
            }
          });

          // Ordenar e limitar a 10
          const topAprovadores = Object.fromEntries(
            Object.entries(aprovadoresPorRemetente)
              .sort(([, a], [, b]) => b - a)
              .slice(0, 10)
          );

          // 4. Quem mais reprova
          const reprovadoresPorRemetente = {};
          dataToShow.forEach((item) => {
            if (
              normalizeStatus(item.status) === "REPROVADA" &&
              item.remetente
            ) {
              reprovadoresPorRemetente[item.remetente] =
                (reprovadoresPorRemetente[item.remetente] || 0) + 1;
            }
          });

          // Ordenar e limitar a 10
          const topReprovadores = Object.fromEntries(
            Object.entries(reprovadoresPorRemetente)
              .sort(([, a], [, b]) => b - a)
              .slice(0, 10)
          );

          // 5. Tempo médio por tipo
          const diasPorTipo = {
            CADASTRAL: [],
            ROTINEIRA: [],
            "CORREÇÃO DE CADASTRO": [],
          };

          dataToShow.forEach((item) => {
            if (
              item.tipoInspecao &&
              item.dataEntrega &&
              (item.dataDevolucao || item.dataRecebimento)
            ) {
              const tipo = normalizeTipoInspecao(item.tipoInspecao);
              const dataInicio = parseComplexDate(item.dataEntrega);
              const dataFim = parseComplexDate(
                item.dataDevolucao || item.dataRecebimento
              );

              if (dataInicio && dataFim && diasPorTipo[tipo]) {
                const dias = Math.round(
                  (dataFim - dataInicio) / (1000 * 60 * 60 * 24)
                );
                if (dias >= 0) {
                  diasPorTipo[tipo].push(dias);
                }
              }
            }
          });

          // Calcular médias
          const mediaDiasPorTipo = {};
          Object.entries(diasPorTipo).forEach(([tipo, dias]) => {
            if (dias.length > 0) {
              mediaDiasPorTipo[tipo] =
                dias.reduce((sum, val) => sum + val, 0) / dias.length;
            } else {
              mediaDiasPorTipo[tipo] = 0;
            }
          });

          // 6. Contagem por tipo
          const tipoInspecaoCounts = {};
          dataToShow.forEach((item) => {
            if (item.tipoInspecao) {
              const tipo = normalizeTipoInspecao(item.tipoInspecao);
              tipoInspecaoCounts[tipo] = (tipoInspecaoCounts[tipo] || 0) + 1;
            }
          });

          // Criar gráficos
          createStatusChart(statusCounts);
          createReprovacaoChart(topReprovados);
          createAprovadorChart(topAprovadores);
          createReprovadorChart(topReprovadores);
          createTempoChart(mediaDiasPorTipo);
          createTipoChart(tipoInspecaoCounts);

          // Adicionar título com informações do filtro
          updateStatsFilterInfo(dataToShow.length);
        }

        // Função para mostrar informações do filtro aplicado nas estatísticas
        function updateStatsFilterInfo(filteredCount) {
          const tipoFilter = document.getElementById("statsTipoFilter").value;
          const loteFilter = document.getElementById("statsLoteFilter").value;

          let filterInfo = `<h3>Estatísticas`;

          if (tipoFilter || loteFilter) {
            filterInfo += ` - Filtro: `;
            if (tipoFilter) {
              filterInfo += `Tipo ${tipoFilter}`;
            }
            if (tipoFilter && loteFilter) {
              filterInfo += ` / `;
            }
            if (loteFilter) {
              filterInfo += `Lote ${loteFilter}`;
            }
          }

          filterInfo += ` (${filteredCount} registros)</h3>`;

          const filterInfoContainer =
            document.getElementById("statsFilterInfo");
          if (filterInfoContainer) {
            filterInfoContainer.innerHTML = filterInfo;
          }
        }

        // MELHORIAS #1 e #3: Cálculo e exibição de sumário atualizado
        function calculateSummary(dataToShow) {
          const summary = {
            total: dataToShow.length,
            porStatus: {},
            porTipo: {},
            porLote: {},
            aprovacaoInvalida: 0,
          };

          dataToShow.forEach((message) => {
            // Verificar se é uma aprovação inválida (Lote 1)
            const isAprovacaoInvalida =
              normalizeLote(message.lote) === "1" &&
              normalizeStatus(message.status || "").includes("APROVADA");

            if (isAprovacaoInvalida) {
              summary.aprovacaoInvalida = (summary.aprovacaoInvalida || 0) + 1;
            }

            // Contar por Status (destacando APROVADA para Lote 1 como INVÁLIDA)
            if (message.status) {
              if (isAprovacaoInvalida) {
                // Adicionar a uma categoria especial
                const invalidStatus = "APROVAÇÃO INVÁLIDA (LOTE 1)";
                summary.porStatus[invalidStatus] =
                  (summary.porStatus[invalidStatus] || 0) + 1;
              } else {
                const status = normalizeStatus(message.status);
                summary.porStatus[status] =
                  (summary.porStatus[status] || 0) + 1;
              }
            }

            // Contar por Tipo de Inspeção (normalizado)
            if (message.tipoInspecao) {
              const tipo = normalizeTipoInspecao(message.tipoInspecao);
              summary.porTipo[tipo] = (summary.porTipo[tipo] || 0) + 1;
            }

            // Contar por Lote (normalizado)
            if (message.lote) {
              const normalizedLote = normalizeLote(message.lote);
              summary.porLote[normalizedLote] =
                (summary.porLote[normalizedLote] || 0) + 1;
            }
          });

          return summary;
        }

        function updateSummaryDisplay(summary) {
          const summaryContainer = document.getElementById("dataSummary");

          let html = `<p><strong>Total de Registros:</strong> ${summary.total}</p>`;

          // Mostrar aprovações inválidas se houver
          if (summary.aprovacaoInvalida > 0) {
            html += `<p class="invalid-approval-warning"><strong>Atenção:</strong> ${summary.aprovacaoInvalida} aprovações inválidas do Lote 1 foram encontradas</p>`;
          }

          // Por Status
          if (Object.keys(summary.porStatus).length > 0) {
            html +=
              '<div class="summary-section"><strong>Por Status:</strong><ul>';
            Object.entries(summary.porStatus).forEach(([status, count]) => {
              if (status === "APROVAÇÃO INVÁLIDA (LOTE 1)") {
                html += `<li class="invalid-approval">${status}: ${count}</li>`;
              } else {
                html += `<li>${status}: ${count}</li>`;
              }
            });
            html += "</ul></div>";
          }

          // Por Tipo
          if (Object.keys(summary.porTipo).length > 0) {
            html +=
              '<div class="summary-section"><strong>Por Tipo de Inspeção:</strong><ul>';
            Object.entries(summary.porTipo).forEach(([tipo, count]) => {
              html += `<li>${tipo}: ${count}</li>`;
            });
            html += "</ul></div>";
          }

          // Por Lote
          if (Object.keys(summary.porLote).length > 0) {
            html +=
              '<div class="summary-section"><strong>Por Lote:</strong><ul>';

            // Ordenar lotes numericamente
            const lotesOrdenados = Object.entries(summary.porLote).sort(
              ([a], [b]) => parseInt(a, 10) - parseInt(b, 10)
            );

            lotesOrdenados.forEach(([lote, count]) => {
              html += `<li>Lote ${lote}: ${count}</li>`;
            });
            html += "</ul></div>";
          }

          summaryContainer.innerHTML = html;
        }

        // MELHORIAS #4: Atualização de tabela com ordenação por data
        function updateTable(dataToShow = processedData) {
          const tbody = resultTable.querySelector("tbody");
          tbody.innerHTML = "";

          if (dataToShow.length === 0) {
            tbody.innerHTML =
              '<tr><td colspan="9" style="text-align: center;">Nenhum dado processado. Cole as mensagens e clique em "Processar".</td></tr>';
            document.getElementById("dataSummary").innerHTML = "";
            return;
          }

          // Calcular e exibir sumário
          const summary = calculateSummary(dataToShow);
          updateSummaryDisplay(summary);

          // Ordenar por data (mais recente primeiro)
          const sortedData = sortMessagesByDate([...dataToShow]);

          sortedData.forEach((message) => {
            const row = document.createElement("tr");

            // Verificar se é uma aprovação inválida (Lote 1)
            const isAprovacaoInvalida =
              normalizeLote(message.lote) === "1" &&
              normalizeStatus(message.status || "").includes("APROVADA");

            // Definir classe baseada no status
            const statusLower = (message.status || "").toLowerCase();
            if (isAprovacaoInvalida) {
              row.classList.add("status-invalida");
            } else if (
              statusLower.includes("avaliação") ||
              statusLower.includes("avaliaçã") ||
              statusLower.includes("avaliacao")
            ) {
              row.classList.add("status-avaliacao");
            } else if (
              statusLower.includes("aprovada") ||
              statusLower.includes("aprovado")
            ) {
              row.classList.add("status-aprovada");
            } else if (
              statusLower.includes("reprovada") ||
              statusLower.includes("reprovado")
            ) {
              row.classList.add("status-reprovada");
            } else if (
              statusLower.includes("reavaliação") ||
              statusLower.includes("reavaliacao")
            ) {
              row.classList.add("status-reavaliacao");
            }

            // Formatar todas as datas para o formato brasileiro
            // Converter a data da mensagem para formato brasileiro (DD/MM/AAAA)
            const formattedMessageDate = formatMessageDateBrazilian(
              message.data
            );
            const dataEntrega = formatDateBR(message.dataEntrega);
            const dataRecebimento = formatDateBR(message.dataRecebimento);
            const dataDevolucao = formatDateBR(message.dataDevolucao);

            // Normalizar o tipo de inspeção
            const tipoInspecao = normalizeTipoInspecao(
              message.tipoInspecao || ""
            );

            // Ajustar o status para indicar invalidez se necessário
            let statusDisplay = message.status || "";
            if (isAprovacaoInvalida) {
              statusDisplay += ' <span class="invalid-badge">INVÁLIDA</span>';
            }

            row.innerHTML = `
        <td>${formattedMessageDate || ""}</td>
        <td>${message.remetente || ""}</td>
        <td>${message.lote || ""}</td>
        <td>${message.codigoOAE || ""}</td>
        <td>${tipoInspecao || ""}</td>
        <td>${dataEntrega || ""}</td>
        <td>${dataRecebimento || ""}</td>
        <td>${dataDevolucao || ""}</td>
        <td>${statusDisplay}</td>
      `;

            tbody.appendChild(row);
          });
        }

        // Função para formatar a data da mensagem para o formato brasileiro
        function formatMessageDateBrazilian(dateString) {
          if (!dateString) return "";

          // Se a data já tem o formato DD/MM/YYYY HH:MM ou [DD/MM/YYYY, HH:MM]
          // Extrair apenas a parte da data e converter para o formato brasileiro
          let datePart = "";
          let timePart = "";

          // Formato com colchetes [MM/DD/YY, HH:MM:SS]
          const bracketMatch = dateString.match(
            /\[(\d{1,2}\/\d{1,2}\/\d{2,4}),\s*(\d{1,2}:\d{2}(?::\d{2})?)\]/
          );
          if (bracketMatch) {
            datePart = bracketMatch[1];
            timePart = bracketMatch[2];
          }
          // Formato padrão MM/DD/YYYY HH:MM
          else if (dateString.includes("/")) {
            const parts = dateString.split(" ");
            datePart = parts[0];
            timePart = parts.length > 1 ? parts[1] : "";
          }

          // Se encontramos uma parte de data, formatar para DD/MM/YYYY
          if (datePart) {
            const parts = datePart.split("/");
            if (parts.length === 3) {
              // Verificar se está no formato MM/DD/YYYY (formato americano)
              if (detectedDateFormat === "MM/DD/YYYY") {
                // Inverter mês e dia
                const month = parts[0];
                const day = parts[1];
                const year =
                  parts[2].length === 2
                    ? parseInt(parts[2]) < 50
                      ? "20" + parts[2]
                      : "19" + parts[2]
                    : parts[2];

                // Retornar no formato brasileiro com a hora original
                return `${day}/${month}/${year}${
                  timePart ? " " + timePart : ""
                }`;
              } else {
                // Já está no formato brasileiro, retornar como está
                return dateString;
              }
            }
          }

          // Se não conseguir formatar, retornar a string original
          return dateString;
        }

        function updateIrregularMessages() {
          irregularMessages.innerHTML = "";

          if (irregularData.length === 0) {
            irregularMessages.innerHTML =
              "<p>Nenhuma mensagem irregular encontrada.</p>";
            return;
          }

          irregularData.forEach((message) => {
            const messageElement = document.createElement("div");
            messageElement.className = "message-card";

            messageElement.innerHTML = `
        <div class="message-header">
          <span>${message.data} - ${message.remetente}</span>
          <span class="missing-fields">Campos faltantes: ${message.camposFaltantes}</span>
        </div>
        <div class="message-content">${message.texto}</div>
      `;

            irregularMessages.appendChild(messageElement);
          });
        }

        function initializeDateFilters() {
          if (processedData.length === 0) return;

          // Encontrar datas extremas
          let earliestDate = new Date();
          let latestDate = new Date(0); // 1970-01-01

          processedData.forEach((message) => {
            if (message.data) {
              // Extrair a data da mensagem
              const messageDate = extractDateFromMessage(message.data);

              if (messageDate) {
                if (messageDate < earliestDate) earliestDate = messageDate;
                if (messageDate > latestDate) latestDate = messageDate;
              }
            }
          });

          // Formatar para input de data no formato brasileiro (DD/MM/YYYY)
          startDate.value = formatDateBrazilian(earliestDate);
          endDate.value = formatDateBrazilian(latestDate);
        }

        // Funções para formatação de datas no formato brasileiro (DD/MM/YYYY)
        function formatDateForInput(date) {
          if (!date || isNaN(date.getTime())) return "";
          // Sempre retornar no formato DD/MM/YYYY para inputs brasileiros
          return `${String(date.getDate()).padStart(
            2,
            "0"
          )}/${String(date.getMonth() + 1).padStart(2, "0")}/${date.getFullYear()}`;
        }

        function clearFilters() {
          filterLote.value = "";
          filterStatus.value = "";
          filterTipo.value = "";
          filterCodigo.value = "";

          // Limpar os campos de data
          startDate.value = "";
          endDate.value = "";

          // Atualizar a tabela com todos os dados
          updateTable(processedData);
        }

        function exportToCSV() {
          if (processedData.length === 0) {
            alert("Não há dados para exportar.");
            return;
          }

          // Cabeçalhos
          const headers = [
            "Data",
            "Remetente",
            "Lote",
            "Código OAE",
            "Tipo de Inspeção",
            "Data de Entrega/Envio",
            "Data de Recebimento",
            "Data de Devolução/Retorno",
            "Status",
          ];

          // Linhas de dados
          const rows = processedData.map((message) => [
            message.data || "",
            message.remetente || "",
            message.lote || "",
            message.codigoOAE || "",
            message.tipoInspecao || "",
            message.dataEntrega || "",
            message.dataRecebimento || "",
            message.dataDevolucao || "",
            message.status || "",
          ]);

          // Montar CSV
          const csvContent = [
            headers.join(","),
            ...rows.map((row) =>
              row
                .map((cell) => `"${(cell || "").replace(/"/g, '""')}"`)
                .join(",")
            ),
          ].join("\n");

          // Download
          const blob = new Blob([csvContent], {
            type: "text/csv;charset=utf-8;",
          });
          const url = URL.createObjectURL(blob);
          const link = document.createElement("a");

          link.setAttribute("href", url);
          link.setAttribute(
            "download",
            `dados-oae-${new Date()
              .toISOString()
              .slice(0, 19)
              .replace(/[:.]/g, "-")}.csv`
          );
          link.style.display = "none";

          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }

        // Funções Auxiliares
        function normalizeText(text) {
          if (!text) return "";
          return text
            .toString()
            .normalize("NFD")
            .replace(/[\u0300-\u036f]/g, "")
            .toLowerCase()
            .trim();
        }

        function parseDate(dateStr) {
          return parseComplexDate(dateStr);
        }

        // Funções de Gráficos
        function createStatusChart(data) {
          createChart("statusChart", data, "bar", {
            indexAxis: "x",
            backgroundColor: (ctx) => {
              const label = ctx.chart.data.labels[ctx.dataIndex].toLowerCase();
              if (label.includes("aprovada")) return "rgba(39, 174, 96, 0.7)";
              if (label.includes("reprovada")) return "rgba(231, 76, 60, 0.7)";
              if (label.includes("avaliação")) return "rgba(243, 156, 18, 0.7)";
              if (label.includes("reavaliação"))
                return "rgba(52, 152, 219, 0.7)";
              return "rgba(149, 165, 166, 0.7)";
            },
          });
        }

        function createReprovacaoChart(data) {
          createChart("reprovacaoChart", data, "bar", {
            indexAxis: "y",
            backgroundColor: "rgba(231, 76, 60, 0.7)",
            borderColor: "rgba(231, 76, 60, 1)",
          });
        }

        function createAprovadorChart(data) {
          createChart("aprovadorChart", data, "bar", {
            indexAxis: "y",
            backgroundColor: "rgba(39, 174, 96, 0.7)",
            borderColor: "rgba(39, 174, 96, 1)",
          });
        }

        function createReprovadorChart(data) {
          createChart("reprovadorChart", data, "bar", {
            indexAxis: "y",
            backgroundColor: "rgba(231, 76, 60, 0.7)",
            borderColor: "rgba(231, 76, 60, 1)",
          });
        }

        function createTempoChart(data) {
          createChart("tempoChart", data, "bar", {
            indexAxis: "x",
            backgroundColor: "rgba(52, 152, 219, 0.7)",
            borderColor: "rgba(52, 152, 219, 1)",
            formatter: (value) => `${value.toFixed(1)} dias`,
          });
        }

        function createTipoChart(data) {
          const colors = [
            "rgba(52, 152, 219, 0.7)", // Azul
            "rgba(46, 204, 113, 0.7)", // Verde
            "rgba(155, 89, 182, 0.7)", // Roxo
            "rgba(241, 196, 15, 0.7)", // Amarelo
            "rgba(230, 126, 34, 0.7)", // Laranja
          ];

          createChart("tipoChart", data, "doughnut", {
            backgroundColor: Object.keys(data).map(
              (_, i) => colors[i % colors.length]
            ),
            borderColor: Object.keys(data).map((_, i) =>
              colors[i % colors.length].replace("0.7", "1")
            ),
            formatter: (value, ctx) => {
              const dataset = ctx.chart.data.datasets[0];
              const total = dataset.data.reduce((acc, val) => acc + val, 0);
              const percentage = ((value / total) * 100).toFixed(1);
              return `${
                ctx.chart.data.labels[ctx.dataIndex]
              }: ${value} (${percentage}%)`;
            },
          });
        }

        function createChart(canvasId, data, type, options = {}) {
          const canvas = document.getElementById(canvasId);
          if (!canvas) return; // Segurança extra

          const ctx = canvas.getContext("2d");

          // Destruir gráfico anterior se existir
          const existingChart = Chart.getChart(canvas);
          if (existingChart) {
            existingChart.destroy();
          }

          // Preparar dados
          const labels = Object.keys(data);
          const values = Object.values(data);

          let datasets = [
            {
              label: options.label || "Quantidade",
              data: values,
              backgroundColor:
                options.backgroundColor || "rgba(52, 152, 219, 0.7)",
              borderColor: options.borderColor || "rgba(52, 152, 219, 1)",
              borderWidth: 1,
            },
          ];

          // Configurações para tipos específicos
          const chartOptions = {
            responsive: true,
            maintainAspectRatio: false, // Importante para controlar altura
            plugins: {
              legend: {
                display: type === "doughnut",
                position: "bottom",
                labels: {
                  color: "#ffffff",
                  boxWidth: 12,
                  padding: 10,
                },
              },
              tooltip: {
                callbacks: {},
              },
            },
            scales: {},
          };

          // Adicionar formatter se fornecido
          if (options.formatter) {
            chartOptions.plugins.tooltip.callbacks.label = function (context) {
              return options.formatter(context.raw, context);
            };
          }

          // Configurações específicas para gráficos de barras
          if (type === "bar") {
            chartOptions.indexAxis = options.indexAxis || "x";

            chartOptions.scales = {
              x: {
                beginAtZero: true,
                ticks: {
                  color: "#ffffff",
                },
                grid: {
                  color: "rgba(255, 255, 255, 0.1)",
                },
              },
              y: {
                ticks: {
                  color: "#ffffff",
                },
                grid: {
                  color: "rgba(255, 255, 255, 0.1)",
                },
              },
            };
          }

          // Limitar o número de ticks no eixo Y para barras horizontais
          if (type === "bar" && options.indexAxis === "y") {
            chartOptions.scales.y.ticks.autoSkip = true;
            chartOptions.scales.y.ticks.maxTicksLimit = 8;
          }

          // Criar gráfico
          try {
            new Chart(ctx, {
              type: type,
              data: {
                labels: labels,
                datasets: datasets,
              },
              options: chartOptions,
            });
          } catch (error) {
            console.error(`Erro ao criar gráfico ${canvasId}:`, error);
          }
        }
      });
    </script>
  </body>
</html>
