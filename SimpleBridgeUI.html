<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OAE - Interface de Preenchimento</title>

    <style>



      .export-btn {
  background: linear-gradient(45deg, #9b59b6, #8e44ad);
}

.export-btn:hover {
  background: linear-gradient(45deg, #8e44ad, #9b59b6);
}



      /* Base de estilo do novo design */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(
          135deg,
          #2c3e50 0%,
          #34495e 50%,
          #2c3e50 100%
        );
        min-height: 100vh;
        color: #ffffff;
        overflow-x: hidden;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem;
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
      }

      header {
        text-align: center;
        margin-bottom: 2rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      h1 {
        font-size: 2rem;
        font-weight: 700;
        background: linear-gradient(45deg, #ffffff, #e3f2fd);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      }

      h2 {
        font-size: 1.5rem;
        margin: 20px 0 10px;
        background: rgba(52, 152, 219, 0.2);
        color: white;
        padding: 10px;
        border-radius: 10px;
        backdrop-filter: blur(5px);
      }

      h3 {
        font-size: 1.2rem;
        margin: 15px 0 10px;
        padding-bottom: 5px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        color: #e3f2fd;
      }

      /* Sistemas de abas */
      .tabs {
        display: flex;
        flex-wrap: wrap;
        margin-bottom: 20px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        gap: 5px;
      }

      .tab {
        padding: 10px 20px;
        cursor: pointer;
        background: rgba(52, 152, 219, 0.1);
        border-radius: 10px 10px 0 0;
        transition: all 0.3s ease;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-bottom: none;
        margin-bottom: -1px;
      }

      .tab:hover {
        background: rgba(52, 152, 219, 0.3);
      }

      .tab.active {
        background: linear-gradient(
          to bottom,
          rgba(52, 152, 219, 0.6),
          rgba(52, 152, 219, 0.3)
        );
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-bottom: none;
        position: relative;
      }

      .tab-content {
        display: none;
        padding: 20px;
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(5px);
        border-radius: 0 10px 10px 10px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        animation: fadeIn 0.3s ease-out;
      }

      .tab-content.active {
        display: block;
      }

      /* Formulários */
      .form-row {
        display: flex;
        flex-wrap: wrap;
        margin-bottom: 15px;
        gap: 15px;
      }

      .form-group {
        flex: 1 0 calc(33.333% - 15px);
        min-width: 200px;
      }

      label {
        display: block;
        margin-bottom: 5px;
        font-weight: 500;
        color: #e3f2fd;
      }

      label.required::after {
        content: " *";
        color: #e74c3c;
        font-weight: bold;
      }

      input[type="text"],
      input[type="number"],
      input[type="date"],
      select {
        width: 100%;
        padding: 10px 12px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        font-size: 14px;
        background: rgba(255, 255, 255, 0.1);
        color: white;
        transition: all 0.3s ease;
      }

      input[type="text"]:focus,
      input[type="number"]:focus,
      input[type="date"]:focus,
      select:focus {
        border-color: rgba(52, 152, 219, 0.8);
        outline: none;
        box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.3);
      }

      input.error,
      select.error {
        border: 2px solid #e74c3c;
        background-color: rgba(231, 76, 60, 0.1);
      }

      select {
        cursor: pointer;
        appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 10px center;
        background-size: 16px;
        padding-right: 30px;
      }

      /* Opções do select */
      select option {
        background-color: #34495e;
        color: white;
      }

      input[type="checkbox"] {
        width: 18px;
        height: 18px;
        margin-right: 5px;
        vertical-align: middle;
        accent-color: #3498db;
      }

      /* Botões */
      button {
        background: linear-gradient(45deg, #3498db, #2980b9);
        color: white;
        border: none;
        padding: 12px 18px;
        margin: 5px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: all 0.3s ease;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        position: relative;
        overflow: hidden;
      }

      button:hover {
        background: linear-gradient(45deg, #2980b9, #3498db);
        transform: translateY(-2px);
        box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
      }

      button:active {
        transform: translateY(0);
        box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1);
      }

      button::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.2),
          transparent
        );
        transition: left 0.5s ease;
      }

      button:hover::before {
        left: 100%;
      }

      .add-btn {
        background: linear-gradient(45deg, #27ae60, #2ecc71);
      }

      .add-btn:hover {
        background: linear-gradient(45deg, #2ecc71, #27ae60);
      }

      .copy-btn {
        background: linear-gradient(45deg, #8e44ad, #9b59b6);
      }

      .copy-btn:hover {
        background: linear-gradient(45deg, #9b59b6, #8e44ad);
      }

      .delete-btn {
        background: linear-gradient(45deg, #e74c3c, #c0392b);
      }

      .delete-btn:hover {
        background: linear-gradient(45deg, #c0392b, #e74c3c);
      }

      /* Containers dinâmicos */
      .dynamic-container {
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: 20px;
        margin: 15px 0;
        border-radius: 10px;
        background: rgba(52, 152, 219, 0.1);
        backdrop-filter: blur(5px);
      }

      .dynamic-fields {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .actions {
        margin-top: 20px;
        display: flex;
        flex-wrap: wrap;
        justify-content: flex-end;
        gap: 10px;
      }

      .dynamic-field {
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        width: 100%;
        gap: 10px;
      }

      .dynamic-field label {
        width: 100px;
        margin-right: 10px;
        margin-bottom: 0;
        flex-shrink: 0;
      }

      .dynamic-field input {
        flex-grow: 1;
      }

      /* Modais */
      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(5px);
      }

      .modal-content {
        background: linear-gradient(135deg, #34495e, #2c3e50);
        margin: 5% auto;
        padding: 25px;
        border-radius: 15px;
        width: 80%;
        max-width: 800px;
        max-height: 80%;
        overflow-y: auto;
        box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
        animation: fadeInUp 0.3s ease-out;
      }

      .close-modal {
        float: right;
        cursor: pointer;
        font-size: 24px;
        font-weight: bold;
      }
      .close-modal:hover {
        color: #fff;
      }

      /* Painel de obras */
      .works-panel {
        margin-bottom: 20px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        padding: 20px;
        background: rgba(52, 73, 94, 0.4);
        backdrop-filter: blur(10px);
      }

      .works-list {
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        margin: 15px 0;
        padding: 10px;
        background-color: rgba(255, 255, 255, 0.05);
      }

      .work-item {
        padding: 10px 15px;
        margin-bottom: 8px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-radius: 6px;
        transition: all 0.3s ease;
      }

      .work-item:hover {
        background-color: rgba(52, 152, 219, 0.2);
      }

      .work-item.selected {
        background-color: rgba(52, 152, 219, 0.3);
        font-weight: bold;
        border-left: 3px solid #3498db;
      }

      .filter-container {
        display: flex;
        margin-bottom: 15px;
        gap: 10px;
      }

      .filter-container input {
        flex-grow: 1;
        padding: 10px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.1);
        color: white;
      }

      /* Notificações e mensagens */
      .notification {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: linear-gradient(45deg, #3498db, #2980b9);
        color: white;
        padding: 15px 20px;
        border-radius: 10px;
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        display: none;
        z-index: 1000;
        animation: slideIn 0.3s ease-out;
      }

      .toggle-panel {
        cursor: pointer;
        background: linear-gradient(45deg, #3498db, #2980b9);
        color: white;
        padding: 10px 15px;
        border-radius: 8px;
        font-size: 14px;
        border: none;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
      }

      .toggle-panel:hover {
        background: linear-gradient(45deg, #2980b9, #3498db);
        transform: translateY(-2px);
        box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
      }

      /* CSV e resultados */
      #csv-line {
        margin: 15px 0;
        padding: 15px;
        background: rgba(52, 73, 94, 0.5);
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        font-family: monospace;
        white-space: pre-wrap;
        word-break: break-all;
        display: none;
        color: #e3f2fd;
      }

      /* Mantenha o posicionamento absoluto */
      .form-group {
        position: relative;
      }

      .error-message {
        display: none; /* Esconde por padrão */
        position: absolute;
        top: 100%;
        left: 0;
        color: #e74c3c;
        font-size: 12px;
        background: rgba(231, 76, 60, 0.1);
        padding: 2px 8px;
        border-radius: 4px;
        z-index: 10;
        width: 100%;
      }

      /* Exibe apenas quando tem a classe visible */
      .error-message.visible {
        display: block;
      }
      .error-message.visible {
        display: block;
        animation: fadeIn 0.3s ease;
      }

      .alert-message {
        color: #e74c3c;
        background-color: rgba(231, 76, 60, 0.1);
        padding: 10px 15px;
        border-radius: 8px;
        margin: 10px 0;
        border-left: 4px solid #e74c3c;
      }

      /* Alerta de pendências - estilo original adaptado */
      .missing-fields-list {
        background-color: #f9f9f9;
        border: 1px solid #bdc3c7;
        border-radius: 4px;
        padding: 15px;
        margin-bottom: 15px;
        color: #333;
      }

      .missing-field {
        color: #e74c3c;
        font-weight: normal;
        margin-bottom: 5px;
      }

      /* Estilo para o modal de resumo */
      .summary-modal .modal-content {
        background: white;
        color: #333;
        border: 1px solid #bdc3c7;
      }

      .summary-section {
        margin-bottom: 20px;
        border-bottom: 1px solid #ddd;
        padding-bottom: 15px;
      }

      .summary-section h3 {
        background-color: #2c3e50;
        color: white;
        padding: 8px;
        border-radius: 4px;
      }

      .summary-row {
        display: flex;
        margin: 8px 0;
        padding: 4px 0;
        border-bottom: 1px solid #eee;
      }

      .summary-label {
        flex: 0 0 40%;
        font-weight: bold;
        color: #333;
      }

      .summary-value {
        flex: 0 0 60%;
        color: #333;
      }



      /* Adicionar ao <style> - Estilo para os campos de apoio em grid */
.apoios-header {
  display: grid;
  grid-template-columns: 100px 1fr 1fr 1fr;
  gap: 10px;
  padding: 10px;
  background: rgba(52, 152, 219, 0.2);
  border-radius: 8px;
  margin-bottom: 10px;
  font-weight: 600;
  text-align: center;
}

.apoio-column {
  color: #e3f2fd;
}

.apoio-row {
  display: grid;
  grid-template-columns: 100px 1fr 1fr 1fr;
  gap: 10px;
  padding: 10px;
  margin-bottom: 8px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
  align-items: center;
}

.apoio-label {
  font-weight: 500;
  color: #e3f2fd;
  text-align: center;
}

.apoio-altura-field,
.apoio-comp-field,
.apoio-larg-field {
  width: 100%;
  padding: 8px 10px;
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 6px;
  font-size: 14px;
  background: rgba(255, 255, 255, 0.1);
  color: white;
  transition: all 0.3s ease;
  text-align: center;
}

.apoio-altura-field:focus,
.apoio-comp-field:focus,
.apoio-larg-field:focus {
  border-color: rgba(52, 152, 219, 0.8);
  outline: none;
  box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.3);
}



      /* Animações */
      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(30px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @keyframes slideIn {
        from {
          transform: translateX(100px);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

    

      
    </style>
  </head>
  <body>
    <div class="notification" id="save-reminder">
      Lembrete: Salve seus dados para não perder o trabalho!
      <button onclick="exportToCSV()">Salvar agora</button>
    </div>

    <div class="container">
      <header>
        <h1>Interface de Preenchimento de Obras de Arte Especiais (OAE)</h1>
        <button id="toggle-works-panel" class="toggle-panel">
          Mostrar Obras
        </button>
      </header>

      <div class="works-panel" id="works-panel" style="display: none">
        <h2>Gerenciamento de Obras</h2>

        <div class="filter-container">
          <input
            type="text"
            id="filter-works"
            placeholder="Filtrar por código..."
          />
          <input
            type="text"
            id="filter-lote"
            placeholder="Filtrar por lote..."
          />
          <button onclick="filterWorks()">Filtrar</button>
        </div>
        <div class="works-list" id="works-list">
          <!-- Lista de obras aqui -->
          <div class="work-item">Nenhuma obra cadastrada</div>
        </div>

        <div class="actions">
          <button type="button" onclick="createNewWork()">Nova Obra</button>
          <button type="button" onclick="importMultipleWorks()">
            Importar Obras para modelar
          </button>
          <button type="button" onclick="importPontesReferenceCSV()">
            Importar CSV BASE DE DADOS
          </button>
          <button type="button" onclick="exportAllWorks()">
            Exportar obras para modelar
          </button>
          <button type="button" class="delete-btn" onclick="clearDatabase()">
            Limpar Banco de Dados
          </button>
          <button onclick="exportToJSON()" class="export-btn">
            📄 Exportar JSON
          </button>
        </div>
      </div>

      <div class="tabs">
        <div class="tab active" data-tab="info">INFORMAÇÕES GERAIS</div>
        <div class="tab" data-tab="configuracao">CONFIGURAÇÕES GERAIS</div>
        <div class="tab" data-tab="transicao">TRANSIÇÃO</div>
        <div class="tab" data-tab="superestrutura">SUPERESTRUTURA</div>
        <div class="tab" data-tab="apoio">APOIO</div>
        <div class="tab" data-tab="complementares">COMPLEMENTARES</div>
      </div>

      <form id="oae-form">
        <!-- Informações Gerais -->
        <div class="tab-content active" id="info-content">
          <h2>Informações Gerais da Obra</h2>
          <div class="form-row">
            <div class="form-group">
              <label for="modelado">MODELADO:</label>
              <input type="checkbox" id="modelado" name="MODELADO" />
            </div>
            <div class="form-group">
              <label for="gps">GPS:</label>
              <input type="checkbox" id="gps" name="GPS" />
            </div>
            <div class="form-group">
              <label for="lote" class="required">LOTE:</label>
              <input type="text" id="lote" name="LOTE" required />
              <div class="error-message" id="lote-error">
                Este campo é obrigatório
              </div>
            </div>
          </div>

          <!-- Adicione também um botão para buscar pontes no formulário principal, próximo ao campo código -->
          <div class="form-group">
            <label for="codigo">Código:</label>
            <div style="display: flex; gap: 5px">
              <input
                type="text"
                id="codigo"
                name="CODIGO"
                required
                style="flex-grow: 1"
              />
              <button
                type="button"
                onclick="showSearchPontesModal()"
                title="Buscar ponte de referência"
              >
                Buscar
              </button>
            </div>
            <div class="form-group">
              <label for="fotos-superiores">FOTOS SUPERIORES</label>
              <input
                type="number"
                id="fotos-superiores"
                name="FOTOS SUPERIORES"
                min="0"
                step="1"
              />
            </div>
            <div class="form-group">
              <label for="fotos-inferiores">FOTOS INFERIORES</label>
              <input
                type="number"
                id="fotos-inferiores"
                name="FOTOS INFERIORES"
                min="0"
                step="1"
              />
            </div>

            <div class="form-group">
              <label for="nome">NOME</label>
              <input type="text" id="nome" name="NOME" />
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label for="uf">UF:</label>
              <input type="text" id="uf" name="UF" />
            </div>

            <div class="form-group">
              <label for="rodovia">RODOVIA</label>
              <input type="number" id="rodovia" name="RODOVIA" />
            </div>
            <div class="form-group">
              <label for="km">KM:</label>
              <input type="number" id="km" name="KM" step="0.01" min="0" />
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label for="data">DATA</label>
              <input
                type="text"
                id="data"
                name="DATA"
                placeholder="dd/mm/aaaa"
              />
            </div>
            <div class="form-group">
              <label for="engenheiro">ENGENHEIRO</label>
              <input type="text" id="engenheiro" name="ENGENHEIRO" />
            </div>
            <div class="form-group">
              <label for="tecnico">TECNICO</label>
              <input type="text" id="tecnico" name="TECNICO" />
            </div>
          </div>

          <!-- Adicionar dentro da div com id="info-content" antes do fechamento -->
          <div class="form-row">
            <div class="form-group">
              <label for="latitude">LATITUDE:</label>
              <input
                type="number"
                id="latitude"
                name="LATITUDE"
                min="-90.99999999999"
                max="99.999999999999"
                step="0.000001"
              />
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label for="longitude">LONGITUDE:</label>
              <input
                type="number"
                id="longitude"
                min="-180.99999999999"
                max="180.999999999999"
                name="LONGITUDE"
                step="0.000001"
              />
            </div>
          </div>

          <div id="info-custom-fields"></div>
          <button
            type="button"
            class="add-btn"
            onclick="showAddField('info-custom-fields')"
          >
            + Adicionar Campo
          </button>
        </div>



<!-- Configurações Gerais -->
<div class="tab-content" id="configuracao-content">
  <h2>CONFIGURAÇÕES GERAIS</h2>
  <div class="form-row">
    <div class="form-group">
      <label for="comprimento" class="required">COMPRIMENTO</label>
      <input
        type="number"
        id="comprimento"
        name="COMPRIMENTO"
        step="0.01"
        min="0"
        required
      />
    <div class="error-message" id="tramos-sum-error" style="display: none; margin-top: 10px;">
  A soma dos tramos deve ser igual ao comprimento total
</div>
    </div>
    <div class="form-group">
      <label for="largura" class="required">LARGURA</label>
      <input
        type="number"
        id="largura"
        name="LARGURA"
        step="0.01"
        min="0"
        required
      />
      <div class="error-message" id="largura-error">
        Este campo é obrigatório
      </div>
    </div>
    <div class="form-group">
      <label for="altura" class="required">ALTURA</label>
      <input
        type="number"
        id="altura"
        name="ALTURA"
        step="0.01"
        min="0"
        required
      />
      <div class="error-message" id="altura-error">
        Este campo é obrigatório
      </div>
    </div>
  </div>
  <div class="form-row">
    <div class="form-group">
      <label for="qtd-tramos" class="required">QTD TRAMOS</label>
      <input
        type="number" 
        id="qtd-tramos" 
        name="QTD TRAMOS"
        min="1"
        value="1" 
        step= "1"
        required
        oninput="forceIntegerOnly(this)"
        onchange="generateTramosFields()"
      />
      <div class="error-message" id="qtd-tramos-error">
        Este campo é obrigatório e deve ser no mínimo 1
      </div>
    </div>
  </div>

  <div id="dynamic-tramos" class="dynamic-container">
    <h3>COMPRIMENTO TRAMOS</h3>
    <div id="tramos-fields" class="dynamic-fields">
      <!-- Campos gerados dinamicamente para tramos -->
    </div>
    <div class="error-message" id="tramos-error">
      Todos os tramos devem ter comprimento mínimo de 0.5m
    </div>
  </div>

  <div id="config-custom-fields"></div>
  <button
    type="button"
    class="add-btn"
    onclick="showAddField('config-custom-fields')"
  >
    + Adicionar Campo
  </button>
</div>




        <!-- Transição -->
        <div class="tab-content" id="transicao-content">
          <h2>ELEMENTOS DE TRANSIÇÃO</h2>
          <div class="form-row">
            <div class="form-group">
              <label for="cortina-altura" class="required"
              >CORTINA ALTURA</label
                >
              <input
                type="number"
                id="cortina-altura"
                name="CORTINA ALTURA"
                step="0.01"
                min="0"
                required
              />
              <div class="error-message" id="cortina-altura-error">
                Este campo é obrigatório
              </div>
            </div>
            <div class="form-group">
              <label for="tipo-ala-paralela">TIPO ALA PARALELA</label>
              <select id="tipo-ala-paralela" name="TIPO ALA PARALELA">
                <!-- Adicionar após o campo tipo-ala-paralela -->
                <div class="error-message" id="tipo-ala-paralela-error">
                  Este campo é obrigatório quando o encontro é Parede Frontal
                  Portante
                </div>

                <option value="">Selecione</option>
                <option value="ALA DE CONCRETO ARMADO">
                  ALA DE CONCRETO ARMADO
                </option>
                <option value="Nenhum">Nenhum</option>
              </select>
            </div>
            <div class="form-group">
              <label for="tipo-ala-perpendicular">TIPO ALA PERPENDICULAR</label>

              <!-- Adicionar após o campo tipo-ala-perpendicular -->
              <div class="error-message" id="tipo-ala-perpendicular-error">
                Este campo é obrigatório quando o encontro é Parede Frontal
                Portante
              </div>

              <select id="tipo-ala-perpendicular" name="TIPO ALA PERPENDICULAR">
                <option value="">Selecione</option>
                <option value="ALA DE CONCRETO ARMADO">
                  ALA DE CONCRETO ARMADO
                </option>
                <option value="Nenhum">Nenhum</option>
              </select>
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label for="comprimento-ala">COMPRIMENTO ALA</label>
              <input
                type="number"
                id="comprimento-ala"
                name="COMPRIMENTO ALA"
                step="0.01"
                min="0"
                required
              />
              <div class="error-message" id="comprimento-ala-error">
                Este campo é obrigatório se alguma ala estiver selecionada
              </div>
            </div>
            <div class="form-group">
              <label for="espessura-ala">ESPESSURA ALA</label>
              <input
                type="number"
                id="espessura-ala"
                name="ESPESSURA ALA"
                step="0.01"
                min="0"
              />
            </div>

            <div class="form-group">
              <label for="tipo-encontro">TIPO ENCONTRO</label>
              <select id="tipo-encontro" name="TIPO ENCONTRO">
                <option value="">Selecione</option>
                <option value="Nenhum">Nenhum</option>
                <option value="ENCONTRO - PAREDE FRONTAL PORTANTE">ENCONTRO - PAREDE FRONTAL PORTANTE</option>
                <option value="ENCONTRO LAJE">ENCONTRO LAJE</option>
                <option value="ENCONTRO DE ALVENARIA DE PEDRA">ENCONTRO DE ALVENARIA DE PEDRA</option>
              </select>
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label for="deslocamento-esquerdo-encontro-laje"
                >DESLOCAMENTO ESQUERDO ENCONTRO LAJE</label
              >
              <input
                type="number"
                id="deslocamento-esquerdo-encontro-laje"
                name="DESLOCAMENTO ESQUERDO ENCONTRO LAJE"
                step="0.01"
                min="0"
              />
            </div>
            <div class="form-group">
              <label for="deslocamento-direito-encontro-laje"
                >DESLOCAMENTO DIREITO ENCONTRO LAJE</label
              >
              <input
                type="number"
                id="deslocamento-direito-encontro-laje"
                name="DESLOCAMENTO DIREITO ENCONTRO LAJE"
                step="0.01"
                min="0"
              />
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label for="comprimento-encontro-laje"
                >COMPRIMENTO ENCONTRO LAJE</label
              >
              <input
                type="number"
                id="comprimento-encontro-laje"
                name="COMPRIMENTO ENCONTRO LAJE"
                step="0.01"
                min="0"
              />
            </div>
            <div class="form-group">
              <label for="laje-transicao">LAJE TRANSICAO</label>
              <select id="laje-transicao" name="LAJE TRANSICAO">
                <option value="">Selecione</option>
                <option value="Nenhum">Nenhum</option>
                <option value="LAJE TRANSICAO">LAJE TRANSICAO</option>
              </select>
            </div>
          </div>

          <div id="transicao-custom-fields"></div>
          <button
            type="button"
            class="add-btn"
            onclick="showAddField('transicao-custom-fields')"
          >
            + Adicionar Campo
          </button>
        </div>



<!-- Superestrutura -->
<div class="tab-content" id="superestrutura-content">
  <h2>ELEMENTOS DE SUPERESTRUTURA</h2>
  <div class="form-row">
    <div class="form-group">
      <label for="altura-longarina" class="required"
        >ALTURA LONGARINA</label
      >
      <input
        type="number"
        id="altura-longarina"
        name="ALTURA LONGARINA"
        step="0.01"
        min="0"
        required
      />
      <div class="error-message" id="altura-longarina-error">
        Este campo é obrigatório
      </div>
    </div>
    <div class="form-group">
      <label for="deslocamento-esquerdo" class="required"
        >DESLOCAMENTO ESQUERDO</label
      >
      <input
        type="number"
        id="deslocamento-esquerdo"
        name="DESLOCAMENTO ESQUERDO"
        step="0.01"
        min="0"
        required
      />
      <div class="error-message" id="deslocamento-esquerdo-error">
        Este campo é obrigatório
      </div>
    </div>
    <div class="form-group">
      <label for="deslocamento-direito" class="required"
        >DESLOCAMENTO DIREITO</label
      >
      <input
        type="number"
        id="deslocamento-direito"
        name="DESLOCAMENTO DIREITO"
        step="0.01"
        min="0"
        required
      />
      <div class="error-message" id="deslocamento-direito-error">
        Este campo é obrigatório
      </div>
    </div>
  </div>
  <div class="form-row">
    <div class="form-group">
      <label for="qtd-longarinas" class="required"
        >QTD LONGARINAS</label
      >
      <input
        type="number"
        id="qtd-longarinas"
        name="QTD LONGARINAS"
        min="0"
        step= "1"
        oninput="forceIntegerOnly(this)"
        required
      />
      <div class="error-message" id="qtd-longarinas-error">
        Este campo é obrigatório
      </div>
    </div>
    <div class="form-group">
      <label for="qtd-transversinas">QTD TRANSVERSINAS</label>
      <input
        type="number"
        id="qtd-transversinas"
        name="QTD TRANSVERSINAS"
        min="0"
        step="1"
        oninput="forceIntegerOnly(this)"
      />
    </div>
  </div>
  <div class="form-row">
    <div class="form-group">
      <label for="espessura-longarina" class="required"
        >ESPESSURA LONGARINA</label
      >
      <input
        type="number"
        id="espessura-longarina"
        name="ESPESSURA LONGARINA"
        step="0.01"
        min="0"
        required
      />
      <div class="error-message" id="espessura-longarina-error">
        Este campo é obrigatório
      </div>
    </div>
    <div class="form-group">
      <label for="espessura-transversina">ESPESSURA TRANSVERSINA</label>
      <input
        type="number"
        id="espessura-transversina"
        name="ESPESSURA TRANSVERSINA"
        step="0.01"
        min="0"
      />
    </div>
    <div class="form-group">
      <label for="espessura-laje" class="required"
        >ESPESSURA LAJE:</label
      >
      <input
        type="number"
        id="espessura-laje"
        name="ESPESSURA LAJE"
        step="0.01"
        min="0"
        required
      />
      <div class="error-message" id="espessura-laje-error">
        Este campo é obrigatório
      </div>
    </div>
  </div>

  <div id="superestrutura-custom-fields"></div>
  <button
    type="button"
    class="add-btn"
    onclick="showAddField('superestrutura-custom-fields')"
  >
    + Adicionar Campo
  </button>
</div>


<!-- Versão: 1.2 -->
<!-- Seção APOIO atualizada com campo TIPO LIGAÇÃO FUNDAÇÕES (renomeado) -->

        <!-- Apoio -->
        <div class="tab-content" id="apoio-content">
          <h2>ELEMENTOS DE APOIO</h2>
          <div class="form-row">
            <div class="form-group">
              <label for="qtd-pilares" class="required">QTD PILARES</label>
      <input
        type="number"
        id="qtd-pilares"
        step= "1"
        oninput="forceIntegerOnly(this)"
        name="QTD PILARES"
        min="0"
        required
      />
              <div class="error-message" id="qtd-pilares-error">
                Este campo é obrigatório
              </div>
            </div>
            <div class="form-group">
              <label for="pilar-descentralizado">PILAR DESCENTRALIZADO</label>
              <select id="pilar-descentralizado" name="PILAR DESCENTRALIZADO">
                <option value="">Selecione</option>
                <option value="Sim">Sim</option>
                <option value="Não">Não</option>
              </select>
            </div>
                        <div class="form-group">
              <label for="tipo-aparelho-apoio">TIPO APARELHO APOIO</label>
              <select id="tipo-aparelho-apoio" name="TIPO APARELHO APOIO">
                <option value="">Selecione</option>
        <option value="APARELHO DE APOIO DE NEOPRENE FRETADO"> APARELHO DE APOIO DE NEOPRENE FRETADO </option>
        <option value="APARELHO DE APOIO ROLO METÁLICO"> APARELHO DE APOIO ROLO METÁLICO </option>
                <option value="Nenhum">Nenhum</option>
              </select>
            </div>
          </div>

 
  <!-- Área de apoios com os três campos -->
          <div id="dynamic-apoios" class="dynamic-container">
    <h3>APOIOS</h3>
    <div class="apoios-header">
      <div class="apoio-column">APOIO</div>
      <div class="apoio-column">ALT.</div>
      <div class="apoio-column">COMP.</div>
      <div class="apoio-column">LARG.</div>
    </div>
    <div id="apoios-fields" class="dynamic-fields">
      <!-- Campos gerados dinamicamente para apoios -->
    </div>
            <div class="error-message" id="apoios-error">
      Todos os campos de apoio precisam ser preenchidos
            </div>
          </div>

          <div class="form-row">
            <div class="form-group">
              <label for="tipo-travessa">TIPO TRAVESSA</label>
              <select id="tipo-travessa" name="TIPO TRAVESSA">
                <option value="">Selecione</option>
                <option value="TRAVESSA DE APOIO DE CONCRETO ARMADO">
                  TRAVESSA DE APOIO DE CONCRETO ARMADO
                </option>
                <option value="Nenhum">Nenhum</option>
              </select>
            </div>
            <div class="form-group">
              <label for="altura-travessa">ALTURA TRAVESSA</label>
      <input
        type="number"
        id="altura-travessa"
        name="ALTURA TRAVESSA"
        step="0.01"
        min="0"
      />
              <div class="error-message" id="altura-travessa-error">
                Este campo é obrigatório se uma travessa estiver selecionada
              </div>
            </div>
            <div class="form-group">
              <label for="tipo-encamisamento">TIPO ENCAMISAMENTO</label>
              <select id="tipo-encamisamento" name="TIPO ENCAMISAMENTO">
                <option value="">Selecione</option>
                <option value="ENCAMISAMENTO DE PILAR">
                  ENCAMISAMENTO DE PILAR
                </option>
                <option value="Nenhum">Nenhum</option>
              </select>
            </div>
          </div>
  
          <div class="form-row">
            <div class="form-group">
              <label for="tipo-bloco-sapata">TIPO BLOCO SAPATA</label>
              <select id="tipo-bloco-sapata" name="TIPO BLOCO SAPATA">
                <option value="">Selecione</option>
                <option value="BLOCO SAPATA DE CONCRETO ARMADO">
                  BLOCO OU SAPATA DE CONCRETO ARMADO
                </option>
                <option value="Nenhum">Nenhum</option>
              </select>
            </div>
            <div class="form-group">
              <label for="altura-bloco-sapata">ALTURA BLOCO SAPATA</label>
      <input
        type="number"
        id="altura-bloco-sapata"
        name="ALTURA BLOCO SAPATA"
        step="0.01"
        min="0"
      />
            </div>
            <div class="form-group">
              <label for="largura-bloco-sapata">LARGURA BLOCO SAPATA</label>
      <input
        type="number"
        id="largura-bloco-sapata"
        name="LARGURA BLOCO SAPATA"
        step="0.01"
        min="0"
      />
            </div>
          </div>
          
          


          <div class="form-row">
            <div class="form-group">
      <label for="tipo-contraventamento-pilar">TIPO CONTRAVENTAMENTO PILAR</label>
      <select
        id="tipo-contraventamento-pilar"
        name="TIPO CONTRAVENTAMENTO PILAR"
      >
                <option value="">Selecione</option>
        <option value="VIGA DE CONTRAVENTAMENTO DE PILAR DE CONCRETO ARMADO">
          VIGA DE CONTRAVENTAMENTO DE PILAR DE CONCRETO ARMADO
                </option>
        <option value="PAREDE DE CONTRAVENTAMENTO DE PILAR DE CONCRETO ARMADO">
          PAREDE DE CONTRAVENTAMENTO DE PILAR DE CONCRETO ARMADO
                </option>
                <option value="Nenhum">Nenhum</option>
              </select>
            </div>
            <div class="form-group">
              <label for="tipo-ligacao-fundacoes">TIPO LIGACAO FUNDACOES</label>
              <select
                id="tipo-ligacao-fundacoes"
                name="TIPO LIGACAO FUNDACOES"
              >
                <option value="">Selecione</option>
                <option value="VIGA DE LIGAÇÃO DE FUNDAÇÕES DE CONCRETO ARMADO">
                  VIGA DE LIGAÇÃO DE FUNDAÇÕES DE CONCRETO ARMADO
                </option>
                <option value="Nenhum">Nenhum</option>
              </select>
            </div>
          </div>
   

          <div id="apoio-custom-fields"></div>
          <button
              type="button"
              class="add-btn"
              onclick="showAddField('apoio-custom-fields')"
            >
            + Adicionar Campo
          </button>
        </div>



        <!-- Elementos Complementares -->
        <div class="tab-content" id="complementares-content">
          <h2>ELEMENTOS COMPLEMENTARES</h2>
          <div class="form-row">
            <div class="form-group">
              <label for="tipo-barreira-esquerda">TIPO BARREIRA ESQUERDA</label>
              <select id="tipo-barreira-esquerda" name="TIPO BARREIRA ESQUERDA">
                <option value="">Selecione</option>
                <option value="BARREIRA NEW JERSEY">BARREIRA NEW JERSEY</option>
                <option value="BARREIRA QUALQUER DE CONCRETO ARMADO">BARREIRA QUALQUER DE CONCRETO ARMADO</option>
                <option value="BARREIRA COM GUARDA-CORPO">BARREIRA COM GUARDA-CORPO</option>
                <option value="Nenhum">Nenhum</option>
              </select>
            </div>
            <div class="form-group">
              <label for="largura-barreira-esquerda">LARGURA BARREIRA ESQUERDA</label>
              <input
                type="number"
                id="largura-barreira-esquerda"
                name="LARGURA BARREIRA ESQUERDA"
                step="0.01"
                min="0"
              />
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label for="tipo-barreira-direita">TIPO BARREIRA DIREITA</label>
              <select id="tipo-barreira-direita" name="TIPO BARREIRA DIREITA">
                 <option value="">Selecione</option>
                <option value="BARREIRA NEW JERSEY">BARREIRA NEW JERSEY</option>
                <option value="BARREIRA QUALQUER DE CONCRETO ARMADO">BARREIRA QUALQUER DE CONCRETO ARMADO</option>
                <option value="BARREIRA COM GUARDA-CORPO">BARREIRA COM GUARDA-CORPO</option>
                <option value="Nenhum">Nenhum</option>
              </select>
            </div>
            <div class="form-group">
              <label for="largura-barreira-direita"
                >LARGURA BARREIRA DIREITA:</label
              >
              <input
                type="number"
                id="largura-barreira-direita"
                name="LARGURA BARREIRA DIREITA"
                step="0.01"
                min="0"
              />
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label for="tipo-calcada-esquerda">TIPO CALCADA ESQUERDA</label>
              <select id="tipo-calcada-esquerda" name="TIPO CALCADA ESQUERDA">
                <option value="">Selecione</option>
                <option value="CALÇADA PARA PEDESTRES DE CONCRETO ARMADO">
                  CALÇADA PARA PEDESTRES DE CONCRETO ARMADO
                </option>
                <option value="Nenhum">Nenhum</option>
              </select>
            </div>
            <div class="form-group">
              <label for="largura-calcada-esquerda"
                >LARGURA CALCADA ESQUERDA:</label
              >
              <input
                type="number"
                id="largura-calcada-esquerda"
                name="LARGURA CALCADA ESQUERDA"
                step="0.01"
                min="0"
              />
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label for="tipo-calcada-direita">TIPO CALCADA DIREITA</label>
              <select id="tipo-calcada-direita" name="TIPO CALCADA DIREITA">
                <option value="">Selecione</option>
                <option value="CALÇADA PARA PEDESTRES DE CONCRETO ARMADO">
                  CALÇADA PARA PEDESTRES DE CONCRETO ARMADO
                </option>
                <option value="Nenhum">Nenhum</option>
              </select>
            </div>
            <div class="form-group">
              <label for="largura-calcada-direita"
                >LARGURA CALCADA DIREITA</label
              >
              <input
                type="number"
                id="largura-calcada-direita"
                name="LARGURA CALCADA DIREITA"
                step="0.01"
                min="0"
              />
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label for="guarda-rodas-esquerdo">GUARDA RODAS ESQUERDO</label>
              <select id="guarda-rodas-esquerdo" name="GUARDA RODAS ESQUERDO">
                <option value="">Selecione</option>
                <option value="GUARDA-RODAS ANTIGO DO DNER">
                  GUARDA-RODAS ANTIGO DO DNER
                </option>
                <option value="Nenhum">Nenhum</option>
              </select>
            </div>
            <div class="form-group">
              <label for="largura-guarda-rodas-esquerdo"
                >LARGURA GUARDA RODAS ESQUERDO</label
              >
              <input
              id="largura-guarda-rodas-esquerdo"
              type="number"
                name="LARGURA GUARDA RODAS ESQUERDO"
                step="0.01"
                min="0"
              />
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label for="guarda-rodas-direito">GUARDA RODAS DIREITO</label>
              <select id="guarda-rodas-direito" name="GUARDA RODAS DIREITO">
                <option value="">Selecione</option>
                <option value="GUARDA-RODAS ANTIGO DO DNER">
                  GUARDA-RODAS ANTIGO DO DNER
                </option>
                <option value="Nenhum">Nenhum</option>
              </select>
            </div>
            <div class="form-group">
              <label for="largura-guarda-rodas-direito"
                >LARGURA GUARDA RODAS DIREITO</label
              >
              <input
                type="number"
                id="largura-guarda-rodas-direito"
                name="LARGURA GUARDA RODAS DIREITO"
                step="0.01"
                min="0"
              />
            </div>
          </div>
          <div class="form-row">
            <div class="form-group">
              <label for="pavimento" class="required">TIPO PAVIMENTO</label>
              <select id="pavimento" name="TIPO PAVIMENTO" required>
                <option value="">Selecione</option>
                <option value="PAVIMENTO ASFÁLTICO">PAVIMENTO ASFÁLTICO</option>
                <option value="PAVIMENTO DE CONCRETO">PAVIMENTO DE CONCRETO</option>
                <option value="Nenhum">Nenhum</option>
              </select>
              <div class="error-message" id="pavimento-error">
                Este campo é obrigatório
              </div>
            </div>
            <div class="form-group">
              <label for="qtd-buzinotes">QTD BUZINOTES</label>
              <input
                type="number"
                id="qtd-buzinotes"
                step= "1"
                oninput="forceIntegerOnly(this)"
                name="QTD BUZINOTES"
                min="0"
              />
            </div>
          </div>

          <div
            class="alert-message"
            id="lateral-protection-error"
            style="
              display: none;
              color: var(--danger);
              background-color: rgba(231, 76, 60, 0.1);
              padding: 10px;
              border-radius: 4px;
              margin: 10px 0;
            "
          >
            <strong>Atenção:</strong> Toda obra deve ter pelo menos um tipo de
            proteção lateral (barreira, guarda-rodas ou CALCADA) em AMBOS os
            lados.
          </div>

          <div id="complementares-custom-fields"></div>
          <button
            type="button"
            class="add-btn"
            onclick="showAddField('complementares-custom-fields')"
          >
            + Adicionar Campo
          </button>
        </div>
      
      
      


      
      </form>

      <div id="csv-line"></div>


      <!-- Botões de Ação -->
      <div class="actions">
        <button type="button" id="import-btn" onclick="showImportModal()">
          Importar CSV
        </button>
        <button type="button" id="export-btn" onclick="exportToCSV()">
          Exportar para CSV
        </button>
        <button type="button" class="copy-btn" onclick="generateAndShowCSVLine()">
          Copiar Linha para Excel
        </button>
        <button type="button" id="save-btn" onclick="showSummaryBeforeSave()">
          Salvar Obra
        </button>
        <button type="button" id="clear-btn" onclick="clearForm()">
          Limpar Formulário
        </button>

        
      </div>

      <!-- Input para importação de arquivos oculto -->
      <input type="file" id="import-file" style="display: none" accept=".csv" />
    </div>

    <!-- Modal para adicionar campo -->
    <div id="add-field-modal" class="modal">
      <div class="modal-content">
        <span class="close-modal" onclick="closeModal()">&times;</span>
        <h3>Adicionar Novo Campo</h3>
        <div class="form-row">
          <div class="form-group">
            <label for="new-field-name">Nome do Campo:</label>
            <input
              type="text"
              id="new-field-name"
              placeholder="Ex: Peso Estrutura"
            />
          </div>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label>Tipo de Campo:</label>
            <div class="field-type-selector">
              <label>
                <input
                  type="radio"
                  name="field-type"
                  value="number-int"
                  checked
                />
                Número Inteiro
              </label>
              <label>
                <input type="radio" name="field-type" value="number-double" />
                Número Decimal
              </label>
              <label>
                <input type="radio" name="field-type" value="select" /> Seleção
              </label>
            </div>
          </div>
        </div>

        <div id="select-options" style="display: none">
          <div class="form-row">
            <div class="form-group">
              <label for="select-options-input">Opções (uma por linha):</label>
              <textarea
                id="select-options-input"
                rows="5"
                placeholder="Nenhum&#10;Opção 1&#10;Opção 2"
              ></textarea>
            </div>
          </div>
        </div>

        <input type="hidden" id="target-container" />
        <div class="actions">
          <button type="button" onclick="addCustomField()">
            Adicionar Campo
        <input type="hidden" id="target-container">
          <button type="button" onclick="closeModal()">Cancelar</button>
        </div>
      </div>
    </div>

    <!-- Modal para importação -->
    <div id="import-modal" class="modal">
      <div class="modal-content">
        <span class="close-modal" onclick="closeImportModal()">&times;</span>
        <h3>Importar Arquivo CSV</h3>
        <p>Selecione um arquivo CSV para importar:</p>
        <input type="file" id="csv-file-input" accept=".csv" />
        <div class="actions">
          <button type="button" onclick="processImportFile()">Importar</button>
          <button type="button" onclick="closeImportModal()">Cancelar</button>
        </div>
      </div>
    </div>

    <!-- Modal para resumo antes de salvar -->
    <div id="summary-modal" class="modal summary-modal">
      <div class="modal-content">
        <span class="close-modal" onclick="closeSummaryModal()">&times;</span>
        <h3>Resumo da Obra</h3>

<!-- Versão: 1.0 -->
<!-- Elemento HTML com sintaxe corrigida -->

<div id="missing-fields-container" class="missing-fields-list" style="display: none">
  <span class="close-modal" onclick="closeSummaryModal()">×</span>
  <h4>Campos Obrigatórios Não Preenchidos:</h4>
  <ul id="missing-fields-list"></ul>
  <p>Por favor, preencha os campos obrigatórios antes de salvar.</p>
</div>

        <div id="summary-content"></div>

        <div class="actions">
          <button
            type="button"
            id="confirm-save-btn"
            onclick="saveCurrentWork()"
          >
            Confirmar Salvamento
          </button>
          <button type="button" onclick="closeSummaryModal()">
            Voltar e Revisar
          </button>
        </div>
      </div>

      <button type="button" onclick="showExportLoteModal()">
        Exportar por Lote
      </button>

      <!-- Modal para exportar por lote -->
      <div id="export-lote-modal" class="modal">
        <div class="modal-content">
          <span class="close-modal" onclick="closeExportLoteModal()"
            >&times;</span
          >
          <h3>Exportar Obras por Lote</h3>
          <div class="form-group">
            <label for="export-lote-select">Selecione o Lote:</label>
            <select id="export-lote-select">
              <!-- Opções serão preenchidas dinamicamente -->
            </select>
          </div>
          <div class="actions">
            <button type="button" onclick="exportLoteWorks()">Exportar</button>
            <button type="button" onclick="closeExportLoteModal()">
              Cancelar
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      var db;
      var saveReminderInterval;
      var currentWorkCode = null;


      // Função para inicializar o sistema de abas
      function initTabSystem() {
        const tabs = document.querySelectorAll(".tab");

        // Verificar se as abas existem
        if (tabs.length === 0) {
          console.error("Nenhuma aba encontrada na página!");
          return;
        }

        // Para cada aba, adicionar evento de clique
        tabs.forEach((tab) => {
          tab.addEventListener("click", function (event) {
            // Impedir comportamento padrão
            event.preventDefault();

            // Obter o ID da aba a ser exibida
            const tabId = this.getAttribute("data-tab");

            // Desativar todas as abas e conteúdos
            document
              .querySelectorAll(".tab")
              .forEach((t) => t.classList.remove("active"));
            document
              .querySelectorAll(".tab-content")
              .forEach((c) => c.classList.remove("active"));

            // Ativar a aba clicada
            this.classList.add("active");

            // Ativar o conteúdo correspondente
            const tabContent = document.getElementById(tabId + "-content");
            if (tabContent) {
              tabContent.classList.add("active");
            } else {
              console.error(`Conteúdo da aba não encontrado: ${tabId}-content`);
            }
          });
        });

        // Ativar a primeira aba por padrão (se nenhuma estiver ativa)
        const activeTab = document.querySelector(".tab.active");
        if (!activeTab && tabs.length > 0) {
          const firstTab = tabs[0];
          firstTab.classList.add("active");

          const firstTabId = firstTab.getAttribute("data-tab");
          const firstTabContent = document.getElementById(
            firstTabId + "-content"
          );
          if (firstTabContent) {
            firstTabContent.classList.add("active");
          }
        }

        console.log("Sistema de abas inicializado com sucesso!");
      }

      // Inicializar o sistema de abas quando o documento estiver pronto
      document.addEventListener("DOMContentLoaded", initTabSystem);

      // Se o documento já estiver carregado, inicializar o sistema de abas imediatamente
      if (document.readyState !== "loading") {
        initTabSystem();
      }

      // Adicionar a função ao escopo global para que possa ser chamada manualmente se necessário
      window.initTabSystem = initTabSystem;

      // 2. Adicionar função debugLog que estava ausente (usada na consultarRodoviasDNIT)
      function debugLog(message) {
        if (window.console && window.console.log) {
          console.log(message);
        }
      }

      // Versão: 2.0
      // Função para criar o objeto requiredFields se não existir
      function checkAndCreateRequiredFields() {
        // Se o objeto já existir, não fazer nada
        if (window.requiredFields) {
          return;
        }

        // Criar o objeto requiredFields caso ele não exista
        window.requiredFields = {
          lote: { type: "text", min: null, required: true },
          codigo: { type: "text", min: null, required: true },
          comprimento: { type: "number", min: 0, required: true },
          largura: { type: "number", min: 0, required: true },
          altura: { type: "number", min: 0, required: true },
          "qtd-tramos": { type: "number", min: 1, required: true },
          "cortina-altura": { type: "number", min: 0, required: true },
          "tipo-ala-paralela": {
            type: "text",
            required: function () {
              const encontroField = document.getElementById("tipo-encontro");
              const alaPerpendicularField =
                document.getElementById("tipo-ala-perpendicular");

              if (!encontroField || !alaPerpendicularField) return false;

              // Se o encontro é parede frontal portante e não tem ala perpendicular, então a paralela é obrigatória
              return (
                encontroField.value === "ENCONTRO - PAREDE FRONTAL PORTANTE" &&
                (alaPerpendicularField.value === "" ||
                  alaPerpendicularField.value === "Nenhum")
              );
            },
          },
          "tipo-ala-perpendicular": {
            type: "text",
            required: function () {
              const encontroField = document.getElementById("tipo-encontro");
              const alaParalelaField = document.getElementById("tipo-ala-paralela");

              if (!encontroField || !alaParalelaField) return false;

              // Se o encontro é parede frontal portante e não tem ala paralela, então a perpendicular é obrigatória
              return (
                encontroField.value === "ENCONTRO - PAREDE FRONTAL PORTANTE" &&
                (alaParalelaField.value === "" ||
                  alaParalelaField.value === "Nenhum")
              );
            },
          },
          "comprimento-ala": {
            type: "number",
            min: 0,
            required: function () {
              const alaParalelaField = document.getElementById("tipo-ala-paralela");
              const alaPerpendicularField =
                document.getElementById("tipo-ala-perpendicular");

              if (!alaParalelaField || !alaPerpendicularField) return false;

              return (
                (alaParalelaField.value !== "" &&
                  alaParalelaField.value !== "Nenhum") ||
                (alaPerpendicularField.value !== "" &&
                  alaPerpendicularField.value !== "Nenhum")
              );
            },
          },
          "espessura-ala": {
            type: "number",
            min: 0,
            required: function () {
              const alaParalelaField = document.getElementById("tipo-ala-paralela");
              const alaPerpendicularField =
                document.getElementById("tipo-ala-perpendicular");

              if (!alaParalelaField || !alaPerpendicularField) return false;

              return (
                (alaParalelaField.value !== "" &&
                  alaParalelaField.value !== "Nenhum") ||
                (alaPerpendicularField.value !== "" &&
                  alaPerpendicularField.value !== "Nenhum")
              );
            },
          },
          "deslocamento-esquerdo-encontro-laje": {
            type: "number",
            min: 0,
            required: function () {
              const encontroField = document.getElementById("tipo-encontro");
              return encontroField && encontroField.value === "ENCONTRO LAJE";
            },
          },
          "deslocamento-direito-encontro-laje": {
            type: "number",
            min: 0,
            required: function () {
              const encontroField = document.getElementById("tipo-encontro");
              return encontroField && encontroField.value === "ENCONTRO LAJE";
            },
          },
          "comprimento-encontro-laje": {
            type: "number",
            min: 0,
            required: function () {
              const encontroField = document.getElementById("tipo-encontro");
              return encontroField && encontroField.value === "ENCONTRO LAJE";
            },
          },
          "altura-longarina": { type: "number", min: 0, required: true },
          "deslocamento-esquerdo": { type: "number", min: 0, required: true },
          "deslocamento-direito": { type: "number", min: 0, required: true },
          "qtd-longarinas": { type: "number", min: 0, required: true },
          "espessura-longarina": { type: "number", min: 0, required: true },
          "espessura-transversina": {
            type: "number",
            min: 0,
            required: function () {
              const qtdTransversinasField =
                document.getElementById("qtd-transversinas");
              const qtdTransversinas =
                parseInt(
                  qtdTransversinasField ? qtdTransversinasField.value : 0
                ) || 0;
              return qtdTransversinas > 0;
            },
          },
          "espessura-laje": { type: "number", min: 0, required: true },
          "qtd-pilares": { type: "number", min: 0, required: true },
          "largura-pilar": {
            type: "number",
            min: 0,
            required: function () {
              const qtdPilaresField = document.getElementById("qtd-pilares");
              const qtdPilares =
                parseInt(qtdPilaresField ? qtdPilaresField.value : 0) || 0;
              return qtdPilares > 0;
            },
          },
          "comprimento-pilares": {
            type: "number",
            min: 0,
            required: function () {
              const qtdPilaresField = document.getElementById("qtd-pilares");
              const qtdPilares =
                parseInt(qtdPilaresField ? qtdPilaresField.value : 0) || 0;
              return qtdPilares > 0;
            },
          },
          "altura-travessa": {
            type: "number",
            min: 0,
            required: function () {
              const tipoTravessaField =
                document.getElementById("tipo-travessa");
              return (
                tipoTravessaField &&
                tipoTravessaField.value !== "" &&
                tipoTravessaField.value !== "Nenhum"
              );
            },
          },
          "altura-bloco-sapata": {
            type: "number",
            min: 0,
            required: function () {
              const tipoBlocoSapataField =
                document.getElementById("tipo-bloco-sapata");
              return (
                tipoBlocoSapataField &&
                tipoBlocoSapataField.value !== "" &&
                tipoBlocoSapataField.value !== "Nenhum"
              );
            },
          },
          "largura-bloco-sapata": {
            type: "number",
            min: 0,
            required: function () {
              const tipoBlocoSapataField =
                document.getElementById("tipo-bloco-sapata");
              return (
                tipoBlocoSapataField &&
                tipoBlocoSapataField.value !== "" &&
                tipoBlocoSapataField.value !== "Nenhum"
              );
            },
          },
          pavimento: { type: "text", required: true },
        };

        console.log("Objeto requiredFields criado com sucesso.");
      }

      // 4. Função para consultar a API do DNIT corrigida (sem a referência a debugLog)
      async function consultarRodoviasDNIT(lat, lng) {
        try {
          if (!lat || !lng) {
            throw new Error(
              "Latitude e longitude são necessárias para consulta"
            );
          }

          const dataRef = new Date().toISOString().split("T")[0];
          const url = `https://servicos.dnit.gov.br/sgplan/apigeo/rotas/localizarkm?lng=${lng}&lat=${lat}&r=250&data=${dataRef}`;

          console.log(`Consultando DNIT: ${url}`);

          const response = await fetch(url, {
            method: "GET",
            headers: {
              Accept: "application/json",
            },
            mode: "cors",
          });

          if (!response.ok) {
            throw new Error(`Erro na API DNIT: ${response.status}`);
          }

          const data = await response.json();
          console.log(`Resposta DNIT:`, data);

          return data;
        } catch (error) {
          console.error(`Erro ao consultar DNIT: ${error.message}`);
          return null;
        }
      }




      // 6. Corrigir a função validateForm para verificar o objeto requiredFields
      function safeValidateForm() {
        // Verificar se o objeto requiredFields existe
        if (typeof requiredFields === "undefined" || !requiredFields) {
          checkAndCreateRequiredFields();
        }

        // Resto da função validateForm original
        let isValid = true;
        const missingFields = [];

        // Validar campos obrigatórios
        for (const fieldId in requiredFields) {
          const isFieldValid = validateField(fieldId);

          if (!isFieldValid) {
            isValid = false;
            const field = document.getElementById(fieldId);
            const label = document.querySelector(`label[for="${fieldId}"]`);
            missingFields.push(
              label ? label.textContent.replace(":", "") : fieldId
            );

            // Se não estiver visível, mostrar a aba correspondente
            const tabContent = field.closest(".tab-content");
            if (tabContent && !tabContent.classList.contains("active")) {
              const tabId = tabContent.id.replace("-content", "");
              document.querySelector(`.tab[data-tab="${tabId}"]`).click();
            }
          }
        }

        // Validar apoios
        const apoiosValid = validateApoios();
        if (!apoiosValid) {
          isValid = false;
          missingFields.push("Altura dos Apoios");
        }

        // Validar proteção lateral (deve ter pelo menos um tipo em cada lado)
        const lateralProtectionValid = validateLateralProtection();
        if (!lateralProtectionValid) {
          isValid = false;
          missingFields.push(
            "Proteção Lateral (barreira, guarda-rodas ou CALCADA) em ambos os lados"
          );
        }

        // Adicionar validação das alas com o encontro
        const alaWithEncontroValid = validateAlaWithEncountro();
        if (!alaWithEncontroValid) {
          isValid = false;
          missingFields.push(
            "Ala obrigatória quando o encontro é Parede Frontal Portante"
          );
        }

        return { isValid, missingFields };
      }

      // 7. Inicialização e verificação de erros
      (function () {
        // Verificar e criar o objeto requiredFields
        checkAndCreateRequiredFields();

        // Substituir a função validateForm globalmente
        if (typeof validateForm !== "undefined") {
          window.originalValidateForm = validateForm;
          window.validateForm = safeValidateForm;
        } else {
          window.validateForm = safeValidateForm;
        }

        // Substituir a função consultarRodoviasDNIT globalmente
        window.consultarRodoviasDNIT = consultarRodoviasDNIT;

        // Garantir que validateAlaWithEncountro esteja disponível globalmente
        window.validateAlaWithEncountro = validateAlaWithEncountro;

        // Adicionar debugLog como função global
        window.debugLog = debugLog;

        console.log("Correções aplicadas com sucesso!");
      })();

      // Versão: 1.0

      // Versão: 1.0
      // ATUALIZAÇÃO DO CAMPO KM COM CONSULTA DIRETA À API DNIT

      // Função para adicionar botão de atualização do KM
      function addKmUpdateButton() {
        // Verificar se o campo KM existe
        const kmInput = document.getElementById("km");
        if (!kmInput) return;

        // Verificar se já existe um botão de atualização
        if (document.getElementById("update-km-button")) return;

        // Criar o contêiner para o botão
        const buttonContainer = document.createElement("div");
        buttonContainer.style.display = "flex";
        buttonContainer.style.alignItems = "center";
        buttonContainer.style.gap = "5px";

        // Criar o botão de atualização
        const updateButton = document.createElement("button");
        updateButton.id = "update-km-button";
        updateButton.type = "button";
        updateButton.className = "update-km-btn";
        updateButton.textContent = "Atualizar KM via DNIT";
        updateButton.style.fontSize = "0.8rem";
        updateButton.style.padding = "4px 8px";
        updateButton.style.backgroundColor = "#f39c12";
        updateButton.style.color = "white";
        updateButton.style.border = "none";
        updateButton.style.borderRadius = "4px";
        updateButton.style.cursor = "pointer";
        updateButton.title =
          "Consultar API do DNIT para atualizar o KM baseado nas coordenadas GPS";

        // Adicionar evento de clique
        updateButton.addEventListener("click", consultarKmDnit);

        // Criar um wrapper para o campo de input
        const kmWrapper = document.createElement("div");
        kmWrapper.style.flex = "1";

        // Mover o campo KM para o novo wrapper
        const kmParent = kmInput.parentNode;
        kmParent.removeChild(kmInput);
        kmWrapper.appendChild(kmInput);

        // Adicionar o wrapper e o botão ao contêiner
        buttonContainer.appendChild(kmWrapper);
        buttonContainer.appendChild(updateButton);

        // Adicionar o contêiner ao pai original do campo KM
        kmParent.appendChild(buttonContainer);

        // Adicionar estilos adicionais
        const style = document.createElement("style");
        style.textContent = `
    .update-km-btn:hover {
      background-color: #f1c40f !important;
      transform: translateY(-1px);
    }
    .km-loading {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid rgba(255,255,255,.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: km-spin 1s ease-in-out infinite;
      margin-left: 4px;
    }
    @keyframes km-spin {
      to { transform: rotate(360deg); }
    }
    .km-status {
      font-size: 0.75rem;
      margin-top: 2px;
      color: #27ae60;
    }
  `;
        document.head.appendChild(style);
      }

      // Função para consultar KM no DNIT
      async function consultarKmDnit() {
        try {
          // Verificar se temos os campos de latitude e longitude
          const latInput = document.getElementById("latitude");
          const lngInput = document.getElementById("longitude");
          const kmInput = document.getElementById("km");
          const updateButton = document.getElementById("update-km-button");

          // Verificar se temos coordenadas para usar
          if (!latInput || !lngInput || !latInput.value || !lngInput.value) {
            alert(
              "É necessário ter coordenadas GPS válidas para consultar o KM. Por favor, preencha os campos de Latitude e Longitude."
            );
            return;
          }

          // Obter valores das coordenadas
          const lat = parseFloat(latInput.value);
          const lng = parseFloat(lngInput.value);

          if (isNaN(lat) || isNaN(lng)) {
            alert(
              "Coordenadas GPS inválidas. Por favor, verifique os valores."
            );
            return;
          }

          // Atualizar estado do botão para indicar carregamento
          const originalText = updateButton.textContent;
          updateButton.disabled = true;
          updateButton.innerHTML =
            'Consultando... <span class="km-loading"></span>';

          // Criar ou atualizar o elemento de status
          let statusElement = document.getElementById("km-status");
          if (!statusElement) {
            statusElement = document.createElement("div");
            statusElement.id = "km-status";
            statusElement.className = "km-status";
            kmInput.parentNode.appendChild(statusElement);
          }
          statusElement.textContent = "";

          // Realizar a consulta
          const resultado = await consultarRodoviasDNIT(lat, lng);

          // Restaurar o botão
          updateButton.disabled = false;
          updateButton.textContent = originalText;

          // Processar resultados
          if (
            resultado &&
            resultado.features &&
            resultado.features.length > 0
          ) {
            // Filtrar apenas rodovias federais (BRs)
            const rodoviasFederais = resultado.features.filter(
              (feature) =>
                feature.properties.sigla_rodov &&
                feature.properties.sigla_rodov.startsWith("BR")
            );

            if (rodoviasFederais.length > 0) {
              // Ordenar pelo mais próximo (menor distância)
              rodoviasFederais.sort(
                (a, b) => a.properties.distancia_m - b.properties.distancia_m
              );

              // Pegar o resultado mais próximo
              const melhorResultado = rodoviasFederais[0];
              const km = melhorResultado.properties.km;
              const rodovia = melhorResultado.properties.sigla_rodov;
              const distancia = melhorResultado.properties.distancia_m;

              // Atualizar o campo de KM
              if (kmInput) {
                kmInput.value = parseFloat(km).toFixed(2);
                kmInput.style.borderColor = "#27ae60";

                // Atualizar o campo de rodovia se existir
                const rodoviaInput = document.getElementById("rodovia");
                if (rodoviaInput) {
                  rodoviaInput.value = rodovia;
                  rodoviaInput.style.borderColor = "#27ae60";
                }

                // Mostrar mensagem de sucesso
                statusElement.textContent = `KM atualizado via DNIT (${distancia.toFixed(
                  0
                )}m de distância)`;

                // Restaurar o estilo após alguns segundos
                setTimeout(() => {
                  kmInput.style.borderColor = "";
                  if (rodoviaInput) rodoviaInput.style.borderColor = "";
                }, 5000);

                return true;
              }
            } else {
              statusElement.textContent =
                "Nenhuma rodovia federal encontrada próxima às coordenadas.";
              statusElement.style.color = "#e74c3c";
            }
          } else {
            statusElement.textContent =
              "Nenhum resultado encontrado na API do DNIT.";
            statusElement.style.color = "#e74c3c";
          }
        } catch (error) {
          console.error("Erro ao consultar API do DNIT:", error);

          // Restaurar botão
          const updateButton = document.getElementById("update-km-button");
          if (updateButton) {
            updateButton.disabled = false;
            updateButton.textContent = "Atualizar KM via DNIT";
          }

          // Mostrar mensagem de erro
          let statusElement = document.getElementById("km-status");
          if (statusElement) {
            statusElement.textContent = `Erro: ${error.message}`;
            statusElement.style.color = "#e74c3c";
          } else {
            alert(`Erro ao consultar API do DNIT: ${error.message}`);
          }

          return false;
        }
      }

      // Inicializar o botão quando o documento estiver pronto
      document.addEventListener("DOMContentLoaded", function () {
        addKmUpdateButton();
      });

      // Se o documento já estiver carregado, adicionar o botão imediatamente
      if (document.readyState !== "loading") {
        addKmUpdateButton();
      }

      const ponteModalStyles = document.createElement("style");
      ponteModalStyles.id = "ponte-details-modal-styles";
      ponteModalStyles.textContent = `
/* Estilos para o modal de detalhes da ponte */
.ponte-details-container {
  margin: 15px 0;
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 10px;
  overflow: hidden;
  background: rgba(44, 62, 80, 0.7);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.ponte-header {
  background: linear-gradient(to right, rgba(52, 152, 219, 0.7), rgba(52, 73, 94, 0.7));
  padding: 12px 15px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.ponte-header strong {
  font-size: 1.1rem;
  color: #ffffff;
}

.ponte-header button {
  background: rgba(255, 255, 255, 0.1);
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.3);
  padding: 5px 10px;
  margin-left: 8px;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 12px;
}

.ponte-header button:hover {
  background: rgba(255, 255, 255, 0.2);
  transform: translateY(-1px);
}

.ponte-fields {
  max-height: 400px;
  overflow-y: auto;
  padding: 10px;
}

.ponte-field-row {
  display: flex;
  padding: 10px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  align-items: center;
  transition: background 0.2s ease;
}

.ponte-field-row:last-child {
  border-bottom: none;
}

.ponte-field-row:hover {
  background: rgba(255, 255, 255, 0.05);
}

.ponte-field-checkbox {
  flex: 0 0 220px;
  display: flex;
  align-items: center;
  gap: 10px;
  cursor: pointer;
  font-weight: 500;
  color: #e3f2fd;
}

.ponte-field-checkbox input[type="checkbox"] {
  width: 18px;
  height: 18px;
  accent-color: #3498db;
}

.ponte-field-checkbox input[type="checkbox"]:disabled + span {
  color: rgba(255, 255, 255, 0.4);
}

.ponte-field-value {
  flex: 1;
  padding-left: 20px;
  word-break: break-word;
  font-family: monospace;
  font-size: 0.9rem;
  color: #ffffff;
  background: rgba(0, 0, 0, 0.1);
  padding: 5px 10px;
  border-radius: 4px;
  border-left: 3px solid rgba(52, 152, 219, 0.7);
}

.ponte-field-actions {
  flex: 0 0 auto;
  margin-left: 10px;
}

.ponte-field-actions button {
  background: rgba(52, 152, 219, 0.3);
  color: white;
  border: none;
  padding: 4px 8px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.8rem;
  transition: all 0.2s ease;
}

.ponte-field-actions button:hover {
  background: rgba(52, 152, 219, 0.6);
}

.work-item-actions {
  display: flex;
  gap: 5px;
}

.work-item-actions button {
  background: rgba(52, 152, 219, 0.3);
  color: white;
  border: none;
  padding: 5px 10px;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.work-item-actions button:hover {
  background: rgba(52, 152, 219, 0.6);
}

.coords-group {
  display: flex;
  gap: 10px;
  margin-top: 10px;
  padding: 10px;
  background: rgba(0, 0, 0, 0.1);
  border-radius: 8px;
}

.coords-group button {
  background: #27ae60;
  color: white;
  border: none;
  padding: 6px 12px;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.coords-group button:hover {
  background: #2ecc71;
}

.update-km-btn {
  background: #f39c12 !important;
}

.update-km-btn:hover {
  background: #f1c40f !important;
}

/* Status de carregamento */
.loading-indicator {
  display: inline-block;
  width: 18px;
  height: 18px;
  border: 3px solid rgba(255,255,255,.3);
  border-radius: 50%;
  border-top-color: #fff;
  animation: spin 1s ease-in-out infinite;
  margin-left: 5px;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}
`;

      // Adicionar os estilos ao documento apenas se ainda não existirem
      if (!document.getElementById("ponte-details-modal-styles")) {
        document.head.appendChild(ponteModalStyles);
      }


      


// Versão: 3.0
// Função aprimorada para importMultipleWorks

function importMultipleWorks() {
  try {
    console.log("Iniciando função importMultipleWorks...");
    
    // Verificar se já existe um input file, e removê-lo se existir
    const oldInput = document.getElementById("import-multiple-works-input");
    if (oldInput) {
      document.body.removeChild(oldInput);
    }
    
    // Criar um novo input de arquivo
    const fileInput = document.createElement("input");
    fileInput.id = "import-multiple-works-input";
    fileInput.type = "file";
    fileInput.accept = ".csv";
    fileInput.style.display = "none";
    document.body.appendChild(fileInput);
    
    // Adicionar evento change com tratamento de erro explícito
    fileInput.addEventListener("change", function(event) {
      try {
        console.log("Arquivo selecionado no input importMultipleWorks");
        
        if (!this.files || this.files.length === 0) {
          console.warn("Nenhum arquivo selecionado");
          return;
        }
        
        const file = this.files[0];
        console.log(`Arquivo selecionado: ${file.name}, tamanho: ${file.size}, tipo: ${file.type}`);
        
        // Verificar extensão
        if (!file.name.toLowerCase().endsWith('.csv')) {
          alert("Por favor, selecione um arquivo CSV válido.");
          console.warn("Arquivo com extensão não CSV");
          return;
        }
        
        // Mostrar notificação de processamento
        const notification = document.createElement("div");
        notification.textContent = `Processando ${file.name}...`;
        notification.style.position = "fixed";
        notification.style.bottom = "20px";
        notification.style.right = "20px";
        notification.style.padding = "15px 20px";
        notification.style.background = "rgba(52, 152, 219, 0.8)";
        notification.style.color = "white";
        notification.style.borderRadius = "5px";
        notification.style.zIndex = "1000";
        document.body.appendChild(notification);
        
        // Criar um leitor de arquivo
        const reader = new FileReader();
        
        // Configurar handler de evento de conclusão de leitura
        reader.onload = function(e) {
          try {
            console.log("Arquivo lido com sucesso, tamanho:", e.target.result.length);
            
            const csvData = e.target.result;
            if (!csvData || csvData.trim() === "") {
              alert("O arquivo CSV está vazio.");
              document.body.removeChild(notification);
              return;
            }
            
            const lines = csvData.split(/\r?\n/);
            console.log(`Arquivo contém ${lines.length} linhas`);
            
            if (lines.length < 2) {
              alert("O arquivo CSV não contém dados suficientes (precisa ter cabeçalhos e pelo menos uma linha de dados).");
              document.body.removeChild(notification);
              return;
            }
            
            // Detectar separador
            const headerLine = lines[0];
            let separator = ",";
            if (headerLine.includes("\t")) separator = "\t";
            else if (headerLine.includes(";")) separator = ";";
            
            console.log(`Separador detectado: '${separator === "\t" ? "TAB" : separator}'`);
            
            // Obter cabeçalhos
            const headers = headerLine.split(separator).map(header => header.trim());
            console.log(`Cabeçalhos: ${headers.join(", ")}`);
            
            // Verificar cabeçalhos mínimos
            if (!headers.includes("CODIGO")) {
              alert("O arquivo CSV não contém o cabeçalho obrigatório 'CODIGO'.");
              document.body.removeChild(notification);
              return;
            }
            
            // Processar obras
            const works = [];
            
            for (let i = 1; i < lines.length; i++) {
              const line = lines[i].trim();
              if (!line) {
                console.log(`Linha ${i+1} vazia, ignorando.`);
                continue;
              }
              
              const values = parseCSVLine(line, separator);
              console.log(`Linha ${i+1}: ${values.length} valores`);
              
              if (values.length < 3) {
                console.warn(`Linha ${i+1} muito curta, ignorando.`);
                continue;
              }
              
              // Criar objeto de dados para a obra
              const workData = {};
              
              // Mapear valores para cabeçalhos
              for (let j = 0; j < headers.length; j++) {
                if (j < values.length) {
                  workData[headers[j]] = values[j];
                }
              }
              
              // Verificar código válido
              if (workData["CODIGO"] && workData["CODIGO"].trim() !== "") {
                works.push(workData);
                console.log(`Obra processada: ${workData["CODIGO"]}`);
              } else {
                console.warn(`Linha ${i+1} sem código, ignorando.`);
              }
            }
            
            // Remover a notificação
            document.body.removeChild(notification);
            
            if (works.length > 0) {
              console.log(`Total de ${works.length} obras processadas com sucesso.`);
              
              // Mostrar confirmação para salvar
              if (confirm(`O arquivo contém ${works.length} obras. Deseja importar todas para o banco de dados?`)) {
                console.log("Usuário confirmou salvamento, chamando saveMultipleWorks");
                saveMultipleWorks(works);
              } else {
                console.log("Usuário cancelou a importação");
              }
            } else {
              alert("Nenhuma obra válida encontrada no arquivo CSV.");
            }
          } catch (parseError) {
            console.error("Erro ao processar CSV:", parseError);
            alert("Erro ao processar o arquivo CSV: " + parseError.message);
            
            if (document.body.contains(notification)) {
              document.body.removeChild(notification);
            }
          }
        };
        
        // Configurar handler de erro de leitura
        reader.onerror = function(errorEvent) {
          console.error("Erro na leitura do arquivo:", errorEvent);
          alert("Erro ao ler o arquivo: " + (errorEvent.target.error?.message || "Erro desconhecido"));
          
          if (document.body.contains(notification)) {
            document.body.removeChild(notification);
          }
        };
        
        // Iniciar a leitura do arquivo
        console.log("Iniciando leitura do arquivo...");
        reader.readAsText(file);
        
      } catch (fileError) {
        console.error("Erro ao processar o arquivo selecionado:", fileError);
        alert("Erro ao processar o arquivo: " + fileError.message);
      } finally {
        // Remover o input após o uso para evitar problemas de limpeza
        setTimeout(() => {
          if (document.body.contains(fileInput)) {
            document.body.removeChild(fileInput);
          }
        }, 1000);
      }
    });
    
    // Acionar o clique no input para abrir o seletor de arquivos
    console.log("Acionando clique no input file...");
    fileInput.click();
    
  } catch (mainError) {
    console.error("Erro crítico em importMultipleWorks:", mainError);
    alert("Erro ao importar obras: " + mainError.message);
  }
}

// Substituir a função global
window.importMultipleWorks = importMultipleWorks;





      // Função para consultar API do DNIT para atualizar o KM
      async function consultarDnitApi(latitude, longitude) {
        try {
          if (!latitude || !longitude) {
            throw new Error(
              "Latitude e longitude são necessárias para consultar a API do DNIT"
            );
          }

          // Desativar botão e mostrar carregamento
          const button = document.querySelector(".update-km-btn");
          if (button) {
            button.disabled = true;
            button.innerHTML =
              'Consultando API <span class="loading-indicator"></span>';
          }

          const dataRef = new Date().toISOString().split("T")[0];
          const url = `https://servicos.dnit.gov.br/sgplan/apigeo/rotas/localizarkm?lng=${longitude}&lat=${latitude}&r=250&data=${dataRef}`;

          console.log(`Consultando API DNIT: ${url}`);

          const response = await fetch(url, {
            method: "GET",
            headers: {
              Accept: "application/json",
            },
          });

          if (!response.ok) {
            throw new Error(`Erro na API DNIT: ${response.status}`);
          }

          const data = await response.json();
          console.log("Resposta da API DNIT:", data);

          // Restaurar botão
          if (button) {
            button.disabled = false;
            button.textContent = "Consultar DNIT";
          }

          // Processar resultados
          if (data && data.features && data.features.length > 0) {
            // Filtrar apenas rodovias federais (BRs)
            const rodoviasFederais = data.features.filter(
              (feature) =>
                feature.properties.sigla_rodov &&
                feature.properties.sigla_rodov.startsWith("BR")
            );

            if (rodoviasFederais.length > 0) {
              // Ordenar pelo mais próximo (menor distância)
              rodoviasFederais.sort(
                (a, b) => a.properties.distancia_m - b.properties.distancia_m
              );

              // Pegar o resultado mais próximo
              const melhorResultado = rodoviasFederais[0];
              const km = melhorResultado.properties.km;
              const rodovia = melhorResultado.properties.sigla_rodov;
              const distancia = melhorResultado.properties.distancia_m;

              // Atualizar os campos no modal
              const kmField = document.querySelector(
                'input[data-field-from="Km"]'
              );
              if (kmField) {
                kmField.checked = true;
                const kmValueElement = kmField
                  .closest(".ponte-field-row")
                  .querySelector(".ponte-field-value");
                if (kmValueElement) {
                  kmValueElement.innerHTML = `${parseFloat(km).toFixed(
                    2
                  )} <small>(atualizado via DNIT)</small>`;
                  kmValueElement.style.borderLeft = "3px solid #27ae60";
                }
              }

              // Atualizar o valor do rodovia se for BR
              const brField = document.querySelector(
                'input[data-field-from="Br"]'
              );
              if (brField && rodovia.startsWith("BR-")) {
                const brValueElement = brField
                  .closest(".ponte-field-row")
                  .querySelector(".ponte-field-value");
                if (brValueElement) {
                  const brNumber = rodovia.replace("BR-", "");
                  brValueElement.innerHTML = `${brNumber} <small>(atualizado via DNIT)</small>`;
                  brValueElement.style.borderLeft = "3px solid #27ae60";
                }
              }

              return {
                success: true,
                km: km,
                rodovia: rodovia,
                distancia: distancia,
              };
            } else {
              alert(
                "Nenhuma rodovia federal encontrada próxima às coordenadas informadas."
              );
              return { success: false };
            }
          } else {
            alert(
              "Nenhum resultado encontrado na API do DNIT para as coordenadas informadas."
            );
            return { success: false };
          }
        } catch (error) {
          console.error("Erro ao consultar API do DNIT:", error);

          // Restaurar botão
          const button = document.querySelector(".update-km-btn");
          if (button) {
            button.disabled = false;
            button.textContent = "Consultar DNIT";
          }

          alert(`Erro ao consultar API do DNIT: ${error.message}`);
          return { success: false, error: error.message };
        }
      }

      // Versão: 3.0
      // Abordagem completamente nova para resolver o problema de inicialização

      // Função para inicialização segura de todos os componentes
      function safeInitializeAll() {
        console.log(
          "Iniciando inicialização segura de todos os componentes..."
        );

        // 1. Inicializar o sistema de abas
        if (typeof initTabSystem === "function") {
          try {
            initTabSystem();
            console.log("Sistema de abas inicializado com sucesso");
          } catch (e) {
            console.error("Erro ao inicializar sistema de abas:", e);
          }
        }

        // 2. Inicializar campos de tramos se necessário
        if (typeof initConfiguracao === "function") {
          try {
            // Verificar se a aba de configuração está ativa
            const configTab = document.querySelector(
              '.tab[data-tab="configuracao"]'
            );
            if (configTab && configTab.classList.contains("active")) {
              initConfiguracao();
              console.log("Configuração inicializada com sucesso");
            }
          } catch (e) {
            console.error("Erro ao inicializar configuração:", e);
          }
        }

        // 3. Adicionar eventos de validação de forma segura
        setTimeout(function () {
          addValidationEvents();
        }, 500);
      }

      // Nova função para adicionar eventos de validação
      function addValidationEvents() {
        console.log("Adicionando eventos de validação...");

        // Verificar e adicionar eventos apenas a elementos que existem
        const addEventIfExists = function (id, eventType, handler) {
          const element = document.getElementById(id);
          if (element) {
            element.addEventListener(eventType, handler);
            return true;
          }
          return false;
        };

        // 1. Adicionar validação para campos obrigatórios
        if (typeof requiredFields !== "undefined" && requiredFields) {
          for (const fieldId in requiredFields) {
            addEventIfExists(fieldId, "input", function () {
              this.classList.remove("error");
              const errorMsg = document.getElementById(fieldId + "-error");
              if (errorMsg) errorMsg.classList.remove("visible");
            });
          }
        }

        // 2. Campos de proteção lateral
        const protectionFields = [
          "tipo-barreira-esquerda",
          "tipo-barreira-direita",
          "guarda-rodas-esquerdo",
          "guarda-rodas-direito",
          "tipo-calcada-esquerda",
          "tipo-calcada-direita",
        ];

        for (const field of protectionFields) {
          if (addEventIfExists(field, "change", validateLateralProtection)) {
            console.log(`Evento adicionado com sucesso para ${field}`);
          }
        }

        // 3. Validação de encontro e alas
        if (typeof validateAlaWithEncountro === "function") {
          addEventIfExists("tipo-encontro", "change", validateAlaWithEncountro);
          addEventIfExists("tipo-ala-paralela", "change", validateAlaWithEncountro);
          addEventIfExists(
            "tipo-ala-perpendicular",
            "change",
            validateAlaWithEncountro
          );
        }

        // 4. Validação para pilares
        addEventIfExists("qtd-pilares", "change", function () {
          const qtdPilares = parseInt(this.value) || 0;
          const larguraPilar = document.getElementById("largura-pilar");
          const comprimentoPilares = document.getElementById(
            "comprimento-pilares"
          );

          if (larguraPilar && comprimentoPilares) {
            // Nunca desabilitar campos
            larguraPilar.disabled = false;
            comprimentoPilares.disabled = false;

            // Remover erros se qtdPilares for 0
            if (qtdPilares === 0) {
              larguraPilar.classList.remove("error");
              comprimentoPilares.classList.remove("error");

              const larguraErro = document.getElementById(
                "largura-pilar-error"
              );
              const comprimentoErro = document.getElementById(
                "comprimento-pilares-error"
              );

              if (larguraErro) larguraErro.classList.remove("visible");
              if (comprimentoErro) comprimentoErro.classList.remove("visible");
            }
          }
        });

        console.log("Eventos de validação adicionados com sucesso");
      }

      // Substituir função global
      window.fixRequiredFieldsValidation = addValidationEvents;

      // Executar inicialização quando o documento estiver pronto
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", safeInitializeAll);
      } else {
        // Se o documento já estiver carregado
        setTimeout(safeInitializeAll, 100);
      }

      // Função para mostrar o modal de detalhes da ponte antes de importar
      function showPonteDetailsModal(ponteId) {
        try {
          if (!db) {
            alert("Banco de dados não está disponível.");
            return;
          }

          const transaction = db.transaction(["pontes"], "readonly");
          const objectStore = transaction.objectStore("pontes");
          const request = objectStore.get(ponteId);

          request.onsuccess = function (event) {
            const ponte = event.target.result;

            if (!ponte) {
              alert("Ponte não encontrada.");
              return;
            }

            // Verificar se o modal já existe
            let modal = document.getElementById("ponte-details-modal");

            if (!modal) {
              // Criar o modal
              modal = document.createElement("div");
              modal.id = "ponte-details-modal";
              modal.className = "modal";

              document.body.appendChild(modal);
            }

            // Mapeamento entre campos da ponte e campos do formulário
            const fieldMappings = [
              {
                from: "CodigoSgo",
                to: "codigo",
                label: "Código SGO",
                type: "text",
              },
              {
                from: "Identificacao",
                to: "nome",
                label: "Nome da Ponte",
                type: "text",
              },
              { from: "Uf", to: "uf", label: "UF", type: "text" },
              {
                from: "Br",
                to: "rodovia",
                label: "Rodovia",
                type: "text",
                transform: (value) => `BR-${value}`,
              },
              { from: "Km", to: "km", label: "Quilômetro", type: "number" },
              {
                from: "Comprimento",
                to: "comprimento",
                label: "Comprimento (m)",
                type: "number",
              },
              {
                from: "Largura",
                to: "largura",
                label: "Largura (m)",
                type: "number",
              },
              {
                from: "AnoConstrucao",
                to: null,
                label: "Ano de Construção",
                type: "text",
              },
              { from: "Municipio", to: null, label: "Município", type: "text" },
              { from: "Latitude", to: null, label: "Latitude", type: "number" },
              {
                from: "Longitude",
                to: null,
                label: "Longitude",
                type: "number",
              },
            ];

            // Construir conteúdo do modal
            let modalContent = `
        <div class="modal-content">
          <span class="close-modal" onclick="closePonteDetailsModal()">&times;</span>
          <h3>Confirmar importação de dados da ponte</h3>
          <p>Selecione os dados que deseja importar para o formulário:</p>
          
          <div class="ponte-details-container">
            <div class="ponte-header">
              <strong>${ponte.CodigoSgo || ""} - ${
              ponte.Identificacao || ""
            }</strong>
              <div>
                <button type="button" onclick="toggleAllFields(true)">Marcar Todos</button>
                <button type="button" onclick="toggleAllFields(false)">Desmarcar Todos</button>
              </div>
            </div>
            
            <div class="ponte-fields">`;

            // Adicionar cada campo com checkbox
            fieldMappings.forEach((field) => {
              const value =
                ponte[field.from] !== undefined ? ponte[field.from] : "";
              const isDisabled = value === ""; // Desabilitar se não houver valor
              const displayValue =
                field.from === "Br" && value ? `${value}` : value;

              modalContent += `
          <div class="ponte-field-row">
            <label class="ponte-field-checkbox">
              <input type="checkbox" name="import_${field.from}" ${
                isDisabled ? "disabled" : "checked"
              } 
                data-field-from="${field.from}" data-field-to="${
                field.to || ""
              }" 
                data-field-type="${field.type}" data-has-transform="${
                field.transform ? "true" : "false"
              }">
              <span>${field.label}</span>
            </label>
            <div class="ponte-field-value">${displayValue}</div>`;

              // Adicionar botão para coordenadas
              if (field.from === "Latitude" || field.from === "Longitude") {
                modalContent += `
            <div class="ponte-field-actions">
              <button type="button" onclick="copyToClipboard('${displayValue}')">Copiar</button>
            </div>`;
              }

              modalContent += `</div>`;
            });

            // Adicionar seção para coordenadas GPS e consulta DNIT
            const hasCoords = ponte.Latitude && ponte.Longitude;
            modalContent += `
        <div class="coords-group">
          <div>
            <strong>Coordenadas GPS:</strong>
            <div>${
              hasCoords
                ? `${ponte.Latitude}, ${ponte.Longitude}`
                : "Não disponíveis"
            }</div>
          </div>`;

            // Adicionar botão para consultar DNIT apenas se tiver coordenadas
            if (hasCoords) {
              modalContent += `
          <div>
            <button type="button" class="update-km-btn" 
              onclick="consultarDnitApi(${ponte.Latitude}, ${ponte.Longitude})">
              Atualizar KM via DNIT
            </button>
          </div>`;
            }

            modalContent += `</div>`;

            // Adicionar campos para latitude e longitude no formulário, se não existirem
            const formFieldsNeeded = checkAndAddGeoFields();

            // Verificar se os campos de latitude e longitude estão disponíveis no formulário
            if (formFieldsNeeded && hasCoords) {
              modalContent += `
          <div class="ponte-field-row">
            <label class="ponte-field-checkbox">
              <input type="checkbox" name="import_coords" checked>
              <span>Importar Coordenadas GPS para o Formulário</span>
            </label>
          </div>`;
            }

            // Fechar containers e adicionar botões de ação
            modalContent += `
            </div>
          </div>
          
          <div class="actions">
            <button type="button" onclick="confirmImportPonte('${ponteId}')">Importar Selecionados</button>
            <button type="button" onclick="closePonteDetailsModal()">Cancelar</button>
          </div>
        </div>
      `;

            modal.innerHTML = modalContent;

            // Exibir o modal
            modal.style.display = "block";
          };

          request.onerror = function (event) {
            console.error("Erro ao obter ponte:", event.target.error);
            alert("Erro ao obter dados da ponte.");
          };
        } catch (error) {
          console.error("Erro ao mostrar detalhes da ponte:", error);
          alert("Erro ao mostrar detalhes da ponte: " + error.message);
        }
      }

      // Verificar e adicionar campos de latitude e longitude ao formulário, se necessário
      function checkAndAddGeoFields() {
        const formContainer = document.getElementById("info-custom-fields");
        if (!formContainer) return false;

        const latField = document.getElementById("latitude");
        const lngField = document.getElementById("longitude");

        // Se ambos os campos já existem, não precisamos fazer nada
        if (latField && lngField) return false;

        // Se precisamos criar os campos de GPS
        let fieldsAdded = false;

        if (!latField) {
          const latFieldDiv = document.createElement("div");
          latFieldDiv.className = "form-row";
          latFieldDiv.innerHTML = `
      <div class="form-group">
        <label for="latitude">Latitude:</label>
        <input type="number" id="latitude" name="LATITUDE" step="0.000001">
      </div>
    `;
          formContainer.appendChild(latFieldDiv);
          fieldsAdded = true;
        }

        if (!lngField) {
          const lngFieldDiv = document.createElement("div");
          lngFieldDiv.className = "form-row";
          lngFieldDiv.innerHTML = `
      <div class="form-group">
        <label for="longitude">Longitude:</label>
        <input type="number" id="longitude" name="LONGITUDE" step="0.000001">
      </div>
    `;
          formContainer.appendChild(lngFieldDiv);
          fieldsAdded = true;
        }

        return fieldsAdded;
      }

      // Copiar valor para a área de transferência
      function copyToClipboard(text) {
        navigator.clipboard
          .writeText(text)
          .then(() => {
            alert("Valor copiado para a área de transferência!");
          })
          .catch((err) => {
            console.error("Erro ao copiar texto: ", err);
            alert(
              "Não foi possível copiar o texto. Por favor, copie manualmente."
            );
          });
      }

      // Fechar modal de detalhes da ponte
      function closePonteDetailsModal() {
        const modal = document.getElementById("ponte-details-modal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Marcar/desmarcar todos os campos
      function toggleAllFields(checked) {
        const checkboxes = document.querySelectorAll(
          '#ponte-details-modal input[type="checkbox"]:not([disabled])'
        );
        checkboxes.forEach((checkbox) => {
          checkbox.checked = checked;
        });
      }

      // Confirmar a importação dos campos selecionados
      function confirmImportPonte(ponteId) {
        try {
          if (!db) {
            alert("Banco de dados não está disponível.");
            return;
          }

          const transaction = db.transaction(["pontes"], "readonly");
          const objectStore = transaction.objectStore("pontes");
          const request = objectStore.get(ponteId);

          request.onsuccess = function (event) {
            const ponte = event.target.result;

            if (!ponte) {
              alert("Ponte não encontrada.");
              return;
            }

            // Coletar campos selecionados
            const selectedFields = document.querySelectorAll(
              '#ponte-details-modal input[type="checkbox"]:checked'
            );

            if (selectedFields.length === 0) {
              alert("Nenhum campo selecionado para importação.");
              return;
            }

            // Preencher os campos do formulário
            selectedFields.forEach((checkbox) => {
              const fieldName = checkbox.getAttribute("name");

              // Tratamento especial para coordenadas GPS
              if (fieldName === "import_coords") {
                // Importar coordenadas para os campos apropriados
                const latField = document.getElementById("latitude");
                const lngField = document.getElementById("longitude");

                if (latField && ponte.Latitude !== undefined) {
                  latField.value = ponte.Latitude;
                }

                if (lngField && ponte.Longitude !== undefined) {
                  lngField.value = ponte.Longitude;
                }

                // Marcar o checkbox GPS se existir
                const gpsCheckbox = document.getElementById("gps");
                if (gpsCheckbox) {
                  gpsCheckbox.checked = true;
                }

                return;
              }

              // Importação normal de campos
              const fieldFrom = checkbox.getAttribute("data-field-from");
              const fieldTo = checkbox.getAttribute("data-field-to");
              const fieldType = checkbox.getAttribute("data-field-type");
              const hasTransform =
                checkbox.getAttribute("data-has-transform") === "true";

              if (fieldTo && ponte[fieldFrom] !== undefined) {
                const field = document.getElementById(fieldTo);

                if (field) {
                  let value = ponte[fieldFrom];

                  // Aplicar transformação se necessário
                  if (hasTransform && fieldFrom === "Br") {
                    value = `BR-${value}`;
                  }

                  // Formatar de acordo com o tipo de campo
                  if (fieldType === "number" && value !== "") {
                    value = parseFloat(value) || 0;
                  }

                  field.value = value;
                }
              }
            });

            alert("Dados da ponte importados com sucesso!");
            closePonteDetailsModal();
            closeSearchPontesModal(); // Fechar também o modal de busca
          };

          request.onerror = function (event) {
            console.error("Erro ao obter ponte:", event.target.error);
            alert("Erro ao obter dados da ponte.");
          };
        } catch (error) {
          console.error("Erro ao importar dados da ponte:", error);
          alert("Erro ao importar dados da ponte: " + error.message);
        }
      }

      // PARTE 3: ATUALIZAÇÃO DA FUNÇÃO DE BUSCA DE PONTES

      // Realizar busca de pontes com opção de visualizar detalhes
      function performPontesSearch(isAutoBusca = false) {
        const searchTerm = document
          .getElementById("filter-pontes")
          .value.trim();
        const resultsContainer = document.getElementById("pontes-results");
        const codigoAtual = isAutoBusca
          ? searchTerm
          : document.getElementById("codigo").value.trim();

        if (!searchTerm) {
          resultsContainer.innerHTML =
            '<div class="work-item">Digite um termo para buscar pontes</div>';
          return;
        }

        resultsContainer.innerHTML = '<div class="work-item">Buscando...</div>';

        searchPontesReference(searchTerm, function (results) {
          if (results.length === 0) {
            resultsContainer.innerHTML =
              '<div class="work-item">Nenhuma ponte encontrada</div>';
            return;
          }

          resultsContainer.innerHTML = "";

          // Verificar se alguma ponte corresponde exatamente ao código atual
          const codigoExato = results.find(
            (ponte) => ponte.CodigoSgo === codigoAtual
          );

          results.forEach((ponte) => {
            const ponteItem = document.createElement("div");
            ponteItem.className = "work-item";

            // Destacar a ponte que corresponde ao código atual, se houver
            if (codigoAtual && ponte.CodigoSgo === codigoAtual) {
              ponteItem.classList.add("selected");
            }

            ponteItem.setAttribute("data-id", ponte.Id);

            // Adicionar mais informações úteis na exibição
            const km = ponte.Km ? parseFloat(ponte.Km).toFixed(2) : "N/A";
            const comprimento = ponte.Comprimento
              ? parseFloat(ponte.Comprimento).toFixed(2) + "m"
              : "N/A";
            const largura = ponte.Largura
              ? parseFloat(ponte.Largura).toFixed(2) + "m"
              : "N/A";

            ponteItem.innerHTML = `
        <div class="work-item-info">
          <div><strong>${ponte.CodigoSgo || ""}</strong> - ${
              ponte.Identificacao || ""
            }</div>
          <div class="work-item-details">
            ${ponte.Uf || ""} | BR-${
              ponte.Br || ""
            } | KM ${km} | ${comprimento} x ${largura}
          </div>
        </div>
        <div class="work-item-actions">
          <button type="button" onclick="showPonteDetailsModal('${
            ponte.Id
          }')">Usar Dados</button>
        </div>
      `;

            resultsContainer.appendChild(ponteItem);
          });

          // Se for auto-busca e encontrou uma correspondência exata, sugerir usar
          if (isAutoBusca && codigoExato) {
            if (
              confirm(
                `Encontramos a ponte "${codigoExato.Identificacao}" correspondente ao código ${codigoAtual}. Deseja ver seus detalhes?`
              )
            ) {
              showPonteDetailsModal(codigoExato.Id);
            }
          }
        });
      }

      // PARTE 4: INICIALIZAÇÃO E CONFIGURAÇÃO

      // Função para inicializar o sistema de pontes quando o documento carregar
      function initPonteSystem() {
        // Adicionar os estilos CSS
        if (!document.getElementById("ponte-details-modal-styles")) {
          document.head.appendChild(ponteModalStyles);
        }

        // Substituir a função usePonteData
        window.usePonteData = function (ponteId) {
          showPonteDetailsModal(ponteId);
        };

        console.log("Sistema de detalhes de pontes inicializado com sucesso!");
      }

      // Inicializar quando o documento estiver pronto
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initPonteSystem);
      } else {
        initPonteSystem();
      }

      // Inicialização do IndexedDB
      function initDB() {
        try {
          // Incrementar versão para 3 para adicionar a nova object store
          const request = window.indexedDB.open("OAEDatabase", 3);

          request.onerror = function (event) {
            console.error(
              "Erro ao abrir o banco de dados:",
              event.target.errorCode
            );
            alert(
              "Erro ao inicializar o banco de dados. Algumas funcionalidades podem não estar disponíveis."
            );
          };

          request.onupgradeneeded = function (event) {
            const database = event.target.result;
            const oldVersion = event.oldVersion;

            // Para novas instalações (banco não existe)
            if (oldVersion < 1) {
              // Criar object store para as obras
              const objectStore = database.createObjectStore("obras", {
                keyPath: "CODIGO",
              });
              objectStore.createIndex("CODIGO", "CODIGO", { unique: true });
              objectStore.createIndex("LOTE", "LOTE", { unique: false });
            }
            // Para usuários atualizando de v1 para v2
            else if (oldVersion === 1) {
              // Adicionar o novo índice ao objectStore existente
              const objectStore = event.target.transaction.objectStore("obras");
              if (!objectStore.indexNames.contains("LOTE")) {
                objectStore.createIndex("LOTE", "LOTE", { unique: false });
              }
            }

            // Para usuários atualizando para v3 (adicionar pontes)
            if (oldVersion < 3) {
              // Verificar se a object store já existe
              if (!database.objectStoreNames.contains("pontes")) {
                // Criar object store para as pontes
                const pontesStore = database.createObjectStore("pontes", {
                  keyPath: "Id",
                });
                // Criar índices úteis para busca
                pontesStore.createIndex("CodigoSgo", "CodigoSgo", {
                  unique: true,
                });
                pontesStore.createIndex("Uf", "Uf", { unique: false });
                pontesStore.createIndex("Br", "Br", { unique: false });
                pontesStore.createIndex("Identificacao", "Identificacao", {
                  unique: false,
                });
              }
            }
          };

          request.onsuccess = function (event) {
            db = event.target.result;
            console.log("Banco de dados inicializado com sucesso");
            loadWorksList(); // Carregar lista de obras

            // Iniciar lembretes de salvamento
            startSaveReminders();
          };
        } catch (error) {
          console.error("Erro na inicialização do banco de dados:", error);
          alert("Erro ao inicializar o banco de dados: " + error.message);
        }
      }

     

      // Versão: 3.0
// Função aprimorada para processamento de arquivo CSV com diagnóstico

function processImportFile() {
  try {
    console.log("Iniciando processamento do arquivo CSV...");
    const fileInput = document.getElementById("csv-file-input");
    
    if (!fileInput || !fileInput.files || fileInput.files.length === 0) {
      alert("Nenhum arquivo selecionado. Por favor, selecione um arquivo CSV para importar.");
      console.error("Nenhum arquivo selecionado");
      return;
    }
    
    const file = fileInput.files[0];
    console.log("Arquivo selecionado:", file.name, "tamanho:", file.size, "tipo:", file.type);
    
    // Verificar se é realmente um arquivo CSV
    if (!file.name.toLowerCase().endsWith('.csv') && file.type !== 'text/csv') {
      alert("O arquivo selecionado não parece ser um CSV válido. Extensão ou tipo incorreto.");
      console.error("Tipo de arquivo inválido:", file.type);
      return;
    }
    
    // Criar um leitor de arquivo com tratamento de erro explícito
    const reader = new FileReader();
    
    reader.onload = function(event) {
      try {
        console.log("Arquivo lido com sucesso. Tamanho dos dados:", event.target.result.length);
        const csvData = event.target.result;
        
        // Verificar se há conteúdo
        if (!csvData || csvData.trim() === "") {
          alert("O arquivo CSV está vazio.");
          console.error("Arquivo CSV vazio");
          return;
        }
        
        // Dividir em linhas
        const lines = csvData.split(/\r?\n/);
        console.log("Número de linhas detectadas:", lines.length);
        
        if (lines.length < 2) {
          alert("O arquivo CSV não contém dados válidos (precisa ter pelo menos 2 linhas).");
          console.error("Arquivo CSV com menos de 2 linhas");
          return;
        }
        
        // Detectar separador de forma mais robusta
        const headerLine = lines[0];
        let separator = detectSeparator(headerLine);
        console.log("Separador detectado:", separator === "\t" ? "TAB" : separator);
        
        if (!separator) {
          alert("Não foi possível detectar o separador no arquivo CSV.");
          console.error("Não foi possível detectar o separador");
          return;
        }
        
        // Obter cabeçalhos
        const headers = headerLine.split(separator).map(header => header.trim());
        console.log("Cabeçalhos detectados:", headers);
        
        if (headers.length < 3) {
          alert("O arquivo CSV não contém cabeçalhos suficientes.");
          console.error("Arquivo CSV com poucos cabeçalhos:", headers.length);
          return;
        }
        
        // Verificar se o arquivo tem várias obras (mais de uma linha de dados)
        if (lines.length > 2) {
          console.log("Detectado arquivo com múltiplas obras");
          const works = [];
          
          // Processar cada linha (exceto a primeira que são os cabeçalhos)
          for (let i = 1; i < lines.length; i++) {
            if (lines[i].trim() === "") {
              console.log(`Linha ${i+1} vazia, ignorando.`);
              continue; // Pular linhas vazias
            }
            
            const values = parseCSVLine(lines[i], separator);
            console.log(`Linha ${i+1}: ${values.length} valores vs ${headers.length} cabeçalhos`);
            
            if (values.length !== headers.length) {
              console.warn(`Linha ${i+1} tem número incorreto de campos (${values.length} vs ${headers.length}).`);
              // Continuar processando, mas registrar o aviso
            }
            
            const workData = {};
            
            // Mapear valores para cabeçalhos
            for (let j = 0; j < headers.length; j++) {
              if (j < values.length) {
                workData[headers[j]] = values[j];
              } else {
                workData[headers[j]] = ""; // Campo vazio para campos faltantes
              }
            }
            
            // Verificar se há um código válido
            if (workData["CODIGO"] && workData["CODIGO"].trim() !== "") {
              works.push(workData);
              console.log(`Obra '${workData["CODIGO"]}' processada com sucesso.`);
            } else {
              console.warn(`Linha ${i+1} sem código válido, ignorando.`);
            }
          }
          
          if (works.length > 0) {
            console.log(`Total de ${works.length} obras processadas com sucesso.`);
            
            // Perguntar se o usuário quer salvar todas as obras no banco de dados
            if (confirm(`O arquivo contém ${works.length} obras. Deseja importar todas para o banco de dados?`)) {
              saveMultipleWorks(works);
            }
          } else {
            alert("Nenhuma obra válida encontrada no arquivo CSV.");
            console.error("Nenhuma obra válida encontrada");
          }
        } else {
          console.log("Detectado arquivo com uma única obra");
          // Apenas uma obra, carregar no formulário atual
          const values = parseCSVLine(lines[1], separator);
          console.log("Valores da obra única:", values.length);
          
          if (values.length < 3) {
            alert("A linha de dados não contém informações suficientes para uma obra.");
            console.error("Dados insuficientes para uma obra");
            return;
          }
          
          loadCSVDataToForm(headers, values);
          console.log("Dados carregados no formulário com sucesso");
        }
        
        closeImportModal();
      } catch (parseError) {
        console.error("Erro ao processar dados do CSV:", parseError);
        alert("Erro ao processar os dados do CSV: " + parseError.message);
      }
    };
    
    reader.onerror = function(errorEvent) {
      console.error("Erro ao ler o arquivo:", errorEvent);
      alert("Erro ao ler o arquivo: " + (errorEvent.target.error?.message || "Erro desconhecido"));
    };
    
    console.log("Iniciando leitura do arquivo...");
    reader.readAsText(file);
    
  } catch (error) {
    console.error("Erro crítico ao processar arquivo:", error);
    alert("Erro ao processar arquivo: " + error.message);
  }
}

// Função auxiliar para detectar o separador
function detectSeparator(headerLine) {
  if (!headerLine) return null;
  
  // Contadores para cada tipo de separador
  const counts = {
    "\t": (headerLine.match(/\t/g) || []).length,
    ",": (headerLine.match(/,/g) || []).length,
    ";": (headerLine.match(/;/g) || []).length
  };
  
  // Encontrar o separador mais frequente
  let maxCount = 0;
  let detectedSeparator = null;
  
  for (const [sep, count] of Object.entries(counts)) {
    if (count > maxCount) {
      maxCount = count;
      detectedSeparator = sep;
    }
  }
  
  // Se não for possível detectar, usar a vírgula como padrão
  return detectedSeparator || ",";
}

// Função aprimorada para analisar linha CSV
function parseCSVLine(line, separator = ",") {
  if (!line) return [];
  
  // Tratamento especial para separador de tabulação
  if (separator === "\t") {
    return line.split(separator).map(value => value.trim());
  }
  
  const values = [];
  let currentValue = "";
  let inQuotes = false;
  
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    
    if (char === '"') {
      if (i < line.length - 1 && line[i + 1] === '"') {
        // Escape para aspas duplas dentro de aspas
        currentValue += '"';
        i++; // Pular o próximo caractere
      } else {
        inQuotes = !inQuotes;
      }
    } else if (char === separator && !inQuotes) {
      values.push(currentValue);
      currentValue = "";
    } else {
      currentValue += char;
    }
  }
  
  // Não esquecer o último valor
  values.push(currentValue);
  
  // Trim dos valores para remover espaços em branco
  return values.map(value => value.trim());
}

// Substituir a função global
window.processImportFile = processImportFile;
window.parseCSVLine = parseCSVLine;
window.detectSeparator = detectSeparator;







      // Versão: 1.1
      // Função auxiliar para analisar uma linha CSV (lidando com valores entre aspas e diferentes separadores)
      function parseCSVLine(line, separator = ",") {
        const values = [];
        let currentValue = "";
        let inQuotes = false;

        if (!line) return [];

        for (let i = 0; i < line.length; i++) {
          const char = line[i];

          if (char === '"') {
            inQuotes = !inQuotes;
          } else if (char === separator && !inQuotes) {
            values.push(currentValue);
            currentValue = "";
          } else {
            currentValue += char;
          }
        }

        // Não esquecer do último valor
        values.push(currentValue);

        // Trim dos valores para remover espaços em branco
        return values.map((value) => value.trim());
      }

      // Versão: 1.1
      // Função para processar o conteúdo do CSV de pontes
      function processPontesCSV(csvData) {
        try {
          // Dividir as linhas do CSV
          const lines = csvData.split("\n");
          if (lines.length < 2) {
            alert("O arquivo CSV não contém dados válidos.");
            return;
          }

          // Detectar o separador
          const headerLine = lines[0];
          let separator = ",";
          if (headerLine.includes("\t")) separator = "\t";
          else if (headerLine.includes(";")) separator = ";";

          console.log(
            "Separador detectado:",
            separator === "\t" ? "TAB" : separator
          );

          // Obter os cabeçalhos
          const headers = headerLine
            .split(separator)
            .map((header) => header.trim());

          // Array para armazenar as pontes
          const pontes = [];

          // Processar cada linha de dados
          for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue; // Pular linhas vazias

            // Processar linha respeitando aspas e o separador correto
            const values = parseCSVLine(line, separator);

            if (values.length < 3) {
              console.warn(
                `Linha ${i} com poucos campos (${values.length}), ignorando.`
              );
              continue; // Ignorar linhas muito curtas
            }

            // Mapear cabeçalhos para índices
            const headerMap = {};
            headers.forEach((header, index) => {
              // Normalizar o cabeçalho para facilitar a correspondência
              const normalizedHeader = header
                .toLowerCase()
                .replace(/[\s"']/g, "");
              headerMap[normalizedHeader] = index;
            });

            // Construir objeto ponte com valores padrão
            const ponte = {
              Id: generateUniqueId(), // Função para gerar ID único se não existir
              CodigoSgo: "",
              Identificacao: "",
              Municipio: "",
              Uf: "",
              Br: "",
              Km: 0,
              Comprimento: 0,
              Largura: 0,
              AnoConstrucao: "",
              Latitude: 0,
              Longitude: 0,
            };

            // Preencher com valores do CSV
            // Tentar múltiplas variações de nomes para cada campo
            ponte.Id = values[headerMap["id"] || 0] || ponte.Id;
            ponte.CodigoSgo =
              values[
                headerMap["codigo"] ||
                  headerMap["codigosgo"] ||
                  headerMap["códigosgo"] ||
                  headerMap["código"] ||
                  0
              ] || "";
            ponte.Identificacao =
              values[
                headerMap["nome"] ||
                  headerMap["identificacao"] ||
                  headerMap["identificação"] ||
                  1
              ] || "";
            ponte.Municipio =
              values[headerMap["municipio"] || headerMap["município"] || 2] ||
              "";
            ponte.Uf = values[headerMap["uf"] || 3] || "";
            ponte.Br = (
              values[headerMap["br"] || headerMap["rodovia"] || 4] || ""
            ).replace(/^BR-/i, "");
            ponte.Km =
              parseFloat(
                (values[headerMap["km"] || 5] || "0")
                  .toString()
                  .replace(",", ".")
              ) || 0;
            ponte.Comprimento =
              parseFloat(
                (values[headerMap["comprimento"] || 6] || "0")
                  .toString()
                  .replace(",", ".")
              ) || 0;
            ponte.Largura =
              parseFloat(
                (values[headerMap["largura"] || 7] || "0")
                  .toString()
                  .replace(",", ".")
              ) || 0;
            ponte.AnoConstrucao =
              values[headerMap["anoconstrucao"] || headerMap["ano"] || 8] || "";
            ponte.Latitude =
              parseFloat(
                (values[headerMap["latitude"] || headerMap["lat"] || 9] || "0")
                  .toString()
                  .replace(",", ".")
              ) || 0;
            ponte.Longitude =
              parseFloat(
                (
                  values[headerMap["longitude"] || headerMap["long"] || 10] ||
                  "0"
                )
                  .toString()
                  .replace(",", ".")
              ) || 0;

            // Verificar se o objeto tem dados mínimos (código)
            if (ponte.CodigoSgo) {
              pontes.push(ponte);
            } else {
              console.warn(`Ponte na linha ${i + 1} sem código, ignorando.`);
            }
          }

          if (pontes.length > 0) {
            // Salvar as pontes no banco de dados
            savePontesReference(pontes);
            alert(
              `Importação concluída: ${pontes.length} pontes de referência importadas.`
            );
          } else {
            alert("Nenhuma ponte válida encontrada no arquivo CSV.");
          }
        } catch (error) {
          console.error("Erro ao processar arquivo CSV de pontes:", error);
          alert("Erro ao processar arquivo CSV de pontes: " + error.message);
        }
      }

      // Função auxiliar para gerar ID único se não existir
      function generateUniqueId() {
        return (
          "ponte_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9)
        );
      }

      // Função auxiliar para gerar ID único se não existir
      function generateUniqueId() {
        return (
          "ponte_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9)
        );
      }

      // Versão: 1.1
      // Carregar dados do CSV para o formulário
      function loadCSVDataToForm(headers, values) {
        try {
          clearForm(); // Limpar o formulário antes

          console.log("Carregando dados CSV para o formulário:", headers);
          console.log("Valores:", values);

          // Mapear valores para os campos do formulário
          const fieldsProcessed = new Set();

          for (let i = 0; i < headers.length; i++) {
            const header = headers[i].trim();
            if (i < values.length && header) {
              const value = values[i];

              // Adicionar ao conjunto de campos processados
              fieldsProcessed.add(header);

              // Tratar campos especiais
              if (header === "MODELADO") {
                document.getElementById("modelado").checked =
                  value.toLowerCase() === "true" || value === "TRUE";
              } else if (header === "GPS") {
                if (document.getElementById("gps")) {
                  document.getElementById("gps").checked =
                    value.toLowerCase() === "true" || value === "TRUE";
                }
              } else if (header === "COMPRIMENTO TRAMOS") {
                if (value) {
                  const tramos = value.split(";");
                  document.getElementById("qtd-tramos").value = tramos.length;
                  generateTramosFields(); // Regenerar campos de tramos

                  // Preencher valores dos tramos
                  const tramosFields =
                    document.querySelectorAll(".tramo-field");
                  for (let j = 0; j < tramosFields.length; j++) {
                    if (j < tramos.length) {
                      tramosFields[j].value = tramos[j];
                    }
                  }
                }
              } else if (header === "ALTURA APOIO") {
                if (value) {
                  const apoios = value.split(";");
                  // Os apoios são regenerados com base nos tramos

                  // Preencher valores dos apoios
                  const apoiosFields =
                    document.querySelectorAll(".apoio-field");
                  for (let j = 0; j < apoiosFields.length; j++) {
                    if (j < apoios.length) {
                      apoiosFields[j].value = apoios[j];
                    }
                  }
                }
              } else {
                // Outros campos - procurar pelo nome ou pelo ID
                const fieldByName = document.querySelector(
                  `[name="${header}"]`
                );
                const fieldById = document.getElementById(
                  header.toLowerCase().replace(/\s+/g, "-")
                );

                if (fieldByName) {
                  fieldByName.value = value;
                } else if (fieldById) {
                  fieldById.value = value;
                } else {
                  console.log(`Campo não encontrado para cabeçalho: ${header}`);
                }
              }
            }
          }

          // Definir o código atual
          const codigoField = document.getElementById("codigo");
          if (codigoField && codigoField.value) {
            currentWorkCode = codigoField.value;
            console.log("Código atual definido:", currentWorkCode);
          }

          // Verificar campos obrigatórios não processados
          console.log("Campos processados:", fieldsProcessed);

          // Executar validação após carregar
          validateForm();
        } catch (error) {
          console.error("Erro ao carregar dados do CSV:", error);
          alert("Erro ao carregar dados do CSV: " + error.message);
        }
      }



      function forceIntegerOnly(input) {
  input.value = input.value.replace(/[^0-9]/g, '');
}


      // Versão: 1.1
      // Função para importar CSV de pontes para referência
      function importPontesReferenceCSV() {
        try {
          // Criar um input de arquivo oculto
          const fileInput = document.createElement("input");
          fileInput.type = "file";
          fileInput.accept = ".csv";
          fileInput.style.display = "none";
          document.body.appendChild(fileInput);

          fileInput.addEventListener("change", function () {
            if (this.files && this.files[0]) {
              const file = this.files[0];
              console.log("Arquivo selecionado:", file.name, file.size);

              // Adicionar notificação visual
              const notification = document.createElement("div");
              notification.textContent = `Processando arquivo: ${file.name}`;
              notification.style.position = "fixed";
              notification.style.bottom = "20px";
              notification.style.right = "20px";
              notification.style.padding = "10px 20px";
              notification.style.background = "rgba(52, 152, 219, 0.9)";
              notification.style.color = "white";
              notification.style.borderRadius = "5px";
              notification.style.zIndex = "1000";
              document.body.appendChild(notification);

              const reader = new FileReader();

              reader.onload = function (event) {
                const csvData = event.target.result;
                processPontesCSV(csvData);
                document.body.removeChild(notification);
              };

              reader.onerror = function () {
                alert("Erro ao ler o arquivo.");
                document.body.removeChild(notification);
              };

              reader.readAsText(file);
            }

            // Remover o input após uso
            document.body.removeChild(fileInput);
          });

          // Acionar o clique para abrir o seletor de arquivos
          fileInput.click();
        } catch (error) {
          console.error("Erro ao importar referência de pontes:", error);
          alert("Erro ao importar referência de pontes: " + error.message);
        }
      }

      // Função para processar o conteúdo do CSV de pontes para referência
      function processPontesReferenceCSV(csvData) {
        try {
          // Dividir as linhas do CSV
          const lines = csvData.split("\n");
          if (lines.length < 2) {
            alert("O arquivo CSV não contém dados válidos.");
            return;
          }

          // Verificar o separador correto (pode ser ; ou ,)
          const separator = lines[0].includes(";") ? ";" : ",";

          // Obter os cabeçalhos (primeira linha)
          const headers = lines[0]
            .split(separator)
            .map((header) => header.trim());

          // Verificar se os cabeçalhos esperados existem
          const requiredHeaders = [
            "Id",
            "CodigoSgo",
            "Identificacao",
            "Uf",
            "Br",
            "Km",
          ];
          const missingHeaders = requiredHeaders.filter(
            (header) => !headers.includes(header)
          );

          if (missingHeaders.length > 0) {
            alert(
              "O arquivo CSV não contém os cabeçalhos esperados: " +
                missingHeaders.join(", ")
            );
            return;
          }

          // Array para armazenar as pontes de referência
          const pontes = [];

          // Processar cada linha de dados (exceto a primeira que são os cabeçalhos)
          for (let i = 1; i < lines.length; i++) {
            if (lines[i].trim() === "") continue; // Pular linhas vazias

            const values = lines[i].split(separator);
            if (values.length !== headers.length) {
              console.warn(
                `Linha ${
                  i + 1
                } tem número incorreto de campos. Tentando processar mesmo assim.`
              );
              continue; // Pular linhas com formato incorreto
            }

            // Criar um objeto para mapear os valores para os índices de cabeçalho
            const ponte = {};
            headers.forEach((header, index) => {
              if (index < values.length) {
                // Converter Km para número se possível
                if (header === "Km") {
                  ponte[header] =
                    parseFloat(values[index].replace(",", ".")) || 0;
                } else {
                  ponte[header] = values[index].trim();
                }
              }
            });

            // Se houver um Id válido, adicionar à lista
            if (ponte.Id && ponte.Id.trim() !== "") {
              pontes.push(ponte);
            }
          }

          if (pontes.length > 0) {
            // Salvar as pontes no banco de dados
            savePontesReference(pontes);
          } else {
            alert("Nenhuma ponte válida encontrada no arquivo CSV.");
          }
        } catch (error) {
          console.error("Erro ao processar arquivo CSV de pontes:", error);
          alert("Erro ao processar arquivo CSV de pontes: " + error.message);
        }
      }

      // Função para salvar as pontes de referência no banco de dados
      function savePontesReference(pontes) {
        try {
          if (!db) {
            alert("Banco de dados não está disponível.");
            return;
          }

          const transaction = db.transaction(["pontes"], "readwrite");
          const objectStore = transaction.objectStore("pontes");

          let countSuccess = 0;
          let countError = 0;
          let processed = 0;

          // Limpar store antes de inserir novos dados
          objectStore.clear().onsuccess = function () {
            pontes.forEach((ponte) => {
              const request = objectStore.add(ponte);

              request.onsuccess = function () {
                countSuccess++;
                processed++;
                checkComplete();
              };

              request.onerror = function (event) {
                countError++;
                processed++;
                console.error(
                  `Erro ao salvar a ponte ${ponte.CodigoSgo}:`,
                  event.target.error
                );
                checkComplete();
              };
            });
          };

          function checkComplete() {
            if (processed === pontes.length) {
              alert(
                `Importação concluída: ${countSuccess} pontes de referência importadas com sucesso, ${countError} erros.`
              );
            }
          }

          transaction.oncomplete = function () {
            console.log(
              "Transação de importação de pontes de referência concluída."
            );
          };

          transaction.onerror = function (event) {
            console.error(
              "Erro na transação de importação de pontes:",
              event.target.error
            );
          };
        } catch (error) {
          console.error("Erro ao salvar pontes de referência:", error);
          alert("Erro ao salvar pontes de referência: " + error.message);
        }
      }

      // Função para buscar pontes de referência
      function searchPontesReference(searchTerm, callback) {
        try {
          if (!db) {
            alert("Banco de dados não está disponível.");
            return;
          }

          const transaction = db.transaction(["pontes"], "readonly");
          const objectStore = transaction.objectStore("pontes");
          const request = objectStore.getAll();

          request.onsuccess = function (event) {
            const pontes = event.target.result;

            // Filtrar pontes com base no termo de busca
            const filteredPontes = pontes.filter(
              (ponte) =>
                ponte.CodigoSgo.toLowerCase().includes(
                  searchTerm.toLowerCase()
                ) ||
                ponte.Identificacao.toLowerCase().includes(
                  searchTerm.toLowerCase()
                ) ||
                ponte.Uf.toLowerCase().includes(searchTerm.toLowerCase()) ||
                ponte.Br.toString().includes(searchTerm)
            );

            callback(filteredPontes);
          };

          request.onerror = function (event) {
            console.error("Erro ao buscar pontes:", event.target.error);
            callback([]);
          };
        } catch (error) {
          console.error("Erro ao buscar pontes de referência:", error);
          callback([]);
        }
      }

      // Função para mostrar modal de busca de pontes

      // Função para mostrar modal de busca de pontes
      function showSearchPontesModal() {
        // Verificar se já existe o modal, se não, criar
        let modal = document.getElementById("search-pontes-modal");

        if (!modal) {
          // Criar o modal
          modal = document.createElement("div");
          modal.id = "search-pontes-modal";
          modal.className = "modal";

          modal.innerHTML = `
      <div class="modal-content">
        <span class="close-modal" onclick="closeSearchPontesModal()">&times;</span>
        <h3>Buscar Pontes de Referência</h3>
        <div class="filter-container">
          <input type="text" id="filter-pontes" placeholder="Buscar ponte por código, nome, UF ou BR..." />
          <button onclick="performPontesSearch()">Buscar</button>
        </div>
        <div id="pontes-results" class="works-list" style="max-height:400px;">
          <!-- Resultados da busca serão exibidos aqui -->
          <div class="work-item">Digite um termo para buscar pontes</div>
        </div>
        <div class="actions">
          <button type="button" onclick="closeSearchPontesModal()">Fechar</button>
        </div>
      </div>
    `;

          document.body.appendChild(modal);

          // Adicionar evento para tecla Enter no campo de busca
          const searchInput = document.getElementById("filter-pontes");
          searchInput.addEventListener("keypress", function (e) {
            if (e.key === "Enter") {
              performPontesSearch();
            }
          });
        }

        // Exibir o modal
        modal.style.display = "block";

        // Verificar se já existe um código digitado
        const codigoAtual = document.getElementById("codigo").value.trim();
        if (codigoAtual) {
          // Preencher o campo de busca com o código atual
          document.getElementById("filter-pontes").value = codigoAtual;

          // Realizar a busca automaticamente
          performPontesSearch(true);
        }
      }

      // Usar os dados da ponte selecionada
      function usePonteData(ponteId) {
        try {
          if (!db) {
            alert("Banco de dados não está disponível.");
            return;
          }

          const transaction = db.transaction(["pontes"], "readonly");
          const objectStore = transaction.objectStore("pontes");
          const request = objectStore.get(ponteId);

          request.onsuccess = function (event) {
            const ponte = event.target.result;

            if (ponte) {
              // Preencher os campos do formulário com os dados da ponte
              document.getElementById("codigo").value = ponte.CodigoSgo || "";
              document.getElementById("nome").value = ponte.Identificacao || "";
              document.getElementById("uf").value = ponte.Uf || "";
              document.getElementById("rodovia").value = ponte.Br
                ? `BR-${ponte.Br}`
                : "";
              document.getElementById("km").value = ponte.Km || 0;
              // Não preencher o lote automaticamente

              alert("Dados da ponte importados com sucesso!");
              closeSearchPontesModal();
            } else {
              alert("Ponte não encontrada.");
            }
          };

          request.onerror = function (event) {
            console.error("Erro ao obter ponte:", event.target.error);
            alert("Erro ao obter dados da ponte.");
          };
        } catch (error) {
          console.error("Erro ao usar dados da ponte:", error);
          alert("Erro ao usar dados da ponte: " + error.message);
        }
      }

      // Fechar modal de busca de pontes
      function closeSearchPontesModal() {
        const modal = document.getElementById("search-pontes-modal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      // Realizar busca de pontes
      function performPontesSearch() {
        const searchTerm = document
          .getElementById("filter-pontes")
          .value.trim();
        const resultsContainer = document.getElementById("pontes-results");

        if (!searchTerm) {
          resultsContainer.innerHTML =
            '<div class="work-item">Digite um termo para buscar pontes</div>';
          return;
        }

        resultsContainer.innerHTML = '<div class="work-item">Buscando...</div>';

        searchPontesReference(searchTerm, function (results) {
          if (results.length === 0) {
            resultsContainer.innerHTML =
              '<div class="work-item">Nenhuma ponte encontrada</div>';
            return;
          }

          resultsContainer.innerHTML = "";

          results.forEach((ponte) => {
            const ponteItem = document.createElement("div");
            ponteItem.className = "work-item";
            ponteItem.setAttribute("data-id", ponte.Id);

            ponteItem.innerHTML = `
        <span>${ponte.CodigoSgo} - ${ponte.Identificacao} (${ponte.Uf} BR-${ponte.Br} KM ${ponte.Km})</span>
        <button type="button" onclick="usePonteData('${ponte.Id}')">Usar</button>
      `;

            resultsContainer.appendChild(ponteItem);
          });
        });
      }

      // Usar os dados da ponte selecionada
      function usePonteData(ponteId) {
        try {
          if (!db) {
            alert("Banco de dados não está disponível.");
            return;
          }

          const transaction = db.transaction(["pontes"], "readonly");
          const objectStore = transaction.objectStore("pontes");
          const request = objectStore.get(ponteId);

          request.onsuccess = function (event) {
            const ponte = event.target.result;

            if (ponte) {
              // Preencher os campos do formulário com os dados da ponte
              document.getElementById("codigo").value = ponte.CodigoSgo || "";
              document.getElementById("nome").value = ponte.Identificacao || "";
              document.getElementById("uf").value = ponte.Uf || "";
              document.getElementById("rodovia").value = ponte.Br
                ? `BR-${ponte.Br}`
                : "";
              document.getElementById("km").value = ponte.Km || 0;

              alert("Dados da ponte importados com sucesso!");
              closeSearchPontesModal();
            } else {
              alert("Ponte não encontrada.");
            }
          };

          request.onerror = function (event) {
            console.error("Erro ao obter ponte:", event.target.error);
            alert("Erro ao obter dados da ponte.");
          };
        } catch (error) {
          console.error("Erro ao usar dados da ponte:", error);
          alert("Erro ao usar dados da ponte: " + error.message);
        }
      }

      // Ativação das abas
      document.addEventListener("DOMContentLoaded", function () {
        // Inicializar banco de dados
        initDB();

        // Configurar sistema de abas
        // Configurar sistema de abas
        document.querySelectorAll(".tab").forEach((tab) => {
          tab.addEventListener("click", function () {
            // Desativar todas as abas e conteúdos
            document
              .querySelectorAll(".tab")
              .forEach((t) => t.classList.remove("active"));
            document
              .querySelectorAll(".tab-content")
              .forEach((c) => c.classList.remove("active"));

            // Ativar a aba clicada
            this.classList.add("active");

            // Ativar o conteúdo correspondente
            const contentId = this.getAttribute("data-tab") + "-content";
            const content = document.getElementById(contentId);
            if (content) {
              content.classList.add("active");
            } else {
              console.error("Conteúdo não encontrado:", contentId);
            }
          });
        });

        // Configurar abas iniciais
        const activeTab = document.querySelector(".tab.active");
        if (activeTab) {
          const contentId = activeTab.getAttribute("data-tab") + "-content";
          const content = document.getElementById(contentId);
          if (content) {
            content.classList.add("active");
          }
        }

        // Inicializar campos dinâmicos
        generateTramosFields();

        // Configurar evento para mostrar/esconder opções de select
        document
          .querySelectorAll('input[name="field-type"]')
          .forEach((radio) => {
            radio.addEventListener("change", function () {
              if (this.value === "select") {
                document.getElementById("select-options").style.display =
                  "block";
              } else {
                document.getElementById("select-options").style.display =
                  "none";
              }
            });
          });

        // Configurar mostrar/ocultar painel de obras
        document
          .getElementById("toggle-works-panel")
          .addEventListener("click", function () {
            const panel = document.getElementById("works-panel");
            if (panel.style.display === "none") {
              panel.style.display = "block";
              this.textContent = "Ocultar Obras";
            } else {
              panel.style.display = "none";
              this.textContent = "Mostrar Obras";
            }
            loadWorksList(); // Recarregar lista de obras ao abrir o painel
          });

        // Adicionar evento ao campo de filtro para permitir filtrar com Enter
        document
          .getElementById("filter-works")
          .addEventListener("keypress", function (e) {
            if (e.key === "Enter") {
              filterWorks();
            }
          });

        // Configurar mascaras e validações
        setupMasks();
        setupValidations();

        // Debug - verificar se todos os elementos de conteúdo existem
        console.log("Verificando elementos de conteúdo das abas:");
        document.querySelectorAll(".tab").forEach((tab) => {
          const tabId = tab.getAttribute("data-tab");
          const contentElement = document.getElementById(`${tabId}-content`);
          console.log(
            `Aba ${tabId}: ${contentElement ? "OK" : "NÃO ENCONTRADO"}`
          );
        });
      });

      // Configurar máscara de data
      function setupMasks() {
        const dataInput = document.getElementById("data");
        dataInput.addEventListener("input", function (e) {
          let value = e.target.value.replace(/\D/g, "");

          if (value.length > 0) {
            // Formatar como dd/mm/aaaa
            if (value.length <= 2) {
              value = value;
            } else if (value.length <= 4) {
              value = value.substring(0, 2) + "/" + value.substring(2);
            } else {
              value =
                value.substring(0, 2) +
                "/" +
                value.substring(2, 4) +
                "/" +
                value.substring(4, 8);
            }
          }

          e.target.value = value;
        });
      }

      




// Versão: 4.7
// Função setupValidations completa com validação de soma dos tramos

function setupValidations() {

  
  // Adicionar validação para campos numéricos (mínimo 0)
  document.querySelectorAll('input[type="number"]').forEach((input) => {
    // Garantir que o valor não seja negativo
    input.addEventListener("change", function () {
      const min = parseFloat(this.getAttribute("min") || 0);
      const value = parseFloat(this.value) || 0;

      if (value < min) {
        this.value = min;
      }
    });

    // Validação ao sair do campo
    input.addEventListener("blur", function () {
      validateField(this.id);
    });
  });

  // Validação para campos de texto obrigatórios
  document
    .querySelectorAll('input[type="text"][required], select[required]')
    .forEach((input) => {
      input.addEventListener("blur", function () {
        validateField(this.id);
      });
    });

  // Validações específicas para campos condicionais
  document
    .getElementById("tipo-ala-paralela")
    .addEventListener("change", function () {
      validateField("comprimento-ala");
      validateField("espessura-ala");
    });

  document
    .getElementById("tipo-ala-perpendicular")
    .addEventListener("change", function () {
      validateField("comprimento-ala");
      validateField("espessura-ala");
    });

  // ALTERAÇÃO: Substituir "encontro" por "tipo-encontro"
  document
    .getElementById("tipo-encontro")
    .addEventListener("change", function () {
      validateField("deslocamento-esquerdo-encontro-laje");
      validateField("deslocamento-direito-encontro-laje");
      validateField("comprimento-encontro-laje");
    });

  document
    .getElementById("qtd-transversinas")
    .addEventListener("change", function () {
      validateField("espessura-transversina");
    });

  document
    .getElementById("tipo-travessa")
    .addEventListener("change", function () {
      validateField("altura-travessa");
    });

  document
    .getElementById("tipo-bloco-sapata")
    .addEventListener("change", function () {
      validateField("altura-bloco-sapata");
      validateField("largura-bloco-sapata");
    });

  // Validações para proteção lateral
  const lateralProtectionFields = [
    "tipo-barreira-esquerda",
    "tipo-barreira-direita",
    "guarda-rodas-esquerdo",
    "guarda-rodas-direito",
    "tipo-calcada-esquerda",
    "tipo-calcada-direita",
  ];

  lateralProtectionFields.forEach((fieldId) => {
    document
      .getElementById(fieldId)
      .addEventListener("change", validateLateralProtection);
  });

  // Validação para campos dependentes da quantidade de pilares
  document
    .getElementById("qtd-pilares")
    .addEventListener("change", function () {
      const qtdPilares = parseInt(this.value) || 0;
      const campoLarguraPilar = document.getElementById("largura-pilar");
      const campoComprimentoPilares = document.getElementById(
        "comprimento-pilares"
      );

      // CORREÇÃO: Nunca desabilitar os campos, independentemente da quantidade de pilares
      campoLarguraPilar.disabled = false;
      campoComprimentoPilares.disabled = false;

      // Manter apenas a lógica de validação visual
      if (qtdPilares === 0) {
        // Remover marcações de erro
        campoLarguraPilar.classList.remove("error");
        campoComprimentoPilares.classList.remove("error");

        // Remover mensagens de erro se existirem
        const larguraErro = document.getElementById(
          "largura-pilar-error"
        );
        const comprimentoErro = document.getElementById(
          "comprimento-pilares-error"
        );

        if (larguraErro) larguraErro.classList.remove("visible");
        if (comprimentoErro) comprimentoErro.classList.remove("visible");
      }
    });

  // ALTERAÇÃO: Substituir "encontro" por "tipo-encontro"
  document
    .getElementById("tipo-encontro")
    .addEventListener("change", validateAlaWithEncountro);
  document
    .getElementById("tipo-ala-paralela")
    .addEventListener("change", validateAlaWithEncountro);
  document
    .getElementById("tipo-ala-perpendicular")
    .addEventListener("change", validateAlaWithEncountro);

  // Validar soma dos tramos quando comprimento total mudar
  document
    .getElementById("comprimento")
    .addEventListener("blur", validateTramosSum);

  // Verificar estado inicial dos campos de pilares
  const qtdPilaresInicial =
    parseInt(document.getElementById("qtd-pilares").value) || 0;

  // CORREÇÃO: Garantir que os campos de pilar nunca estejam desabilitados na inicialização
  document.getElementById("largura-pilar").disabled = false;
  document.getElementById("comprimento-pilares").disabled = false;
}









      // Verificar estado inicial dos campos de pilares
      const qtdPilaresInicial =
        parseInt(document.getElementById("qtd-pilares").value) || 0;
      if (qtdPilaresInicial === 0) {
        document.getElementById("largura-pilar").disabled = true;
        document.getElementById("comprimento-pilares").disabled = true;
      }

      // Adicionar validação para campos numéricos (mínimo 0)
      document.querySelectorAll('input[type="number"]').forEach((input) => {
        // Garantir que o valor não seja negativo
        input.addEventListener("change", function () {
          const min = parseFloat(this.getAttribute("min") || 0);
          const value = parseFloat(this.value) || 0;

          if (value < min) {
            this.value = min;
          }
        });

        // Validação ao sair do campo
        input.addEventListener("blur", function () {
          validateField(this.id);
        });
      });

      // Validação para campos de texto obrigatórios
      document
        .querySelectorAll('input[type="text"][required], select[required]')
        .forEach((input) => {
          input.addEventListener("blur", function () {
            validateField(this.id);
          });
        });

      // Validações específicas para campos condicionais
      document
        .getElementById("tipo-ala-paralela")
        .addEventListener("change", function () {
          validateField("comprimento-ala");
          validateField("espessura-ala");
        });

      document
        .getElementById("tipo-ala-perpendicular")
        .addEventListener("change", function () {
          validateField("comprimento-ala");
          validateField("espessura-ala");
        });

      document
        .getElementById("encontro")
        .addEventListener("change", function () {
          validateField("deslocamento-esquerdo-encontro-laje");
          validateField("deslocamento-direito-encontro-laje");
          validateField("comprimento-encontro-laje");
        });

      document
        .getElementById("qtd-transversinas")
        .addEventListener("change", function () {
          validateField("espessura-transversina");
        });

      document
        .getElementById("tipo-travessa")
        .addEventListener("change", function () {
          validateField("altura-travessa");
        });

      document
        .getElementById("tipo-bloco-sapata")
        .addEventListener("change", function () {
          validateField("altura-bloco-sapata");
          validateField("largura-bloco-sapata");
        });

      // Validações para proteção lateral
      const lateralProtectionFields = [
        "tipo-barreira-esquerda",
        "tipo-barreira-direita",
        "guarda-rodas-esquerdo",
        "guarda-rodas-direito",
        "tipo-calcada-esquerda",
        "tipo-calcada-direita",
      ];

      lateralProtectionFields.forEach((fieldId) => {
        document
          .getElementById(fieldId)
          .addEventListener("change", validateLateralProtection);
      });

      // Validar um campo específico
      function validateField(fieldId) {
        const field = document.getElementById(fieldId);
        const errorElement = document.getElementById(`${fieldId}-error`);

        if (!field) return true;

        // Remover classe de erro
        field.classList.remove("error");
        if (errorElement) errorElement.classList.remove("visible");

        // Verificar se o campo está nas validações obrigatórias
        if (requiredFields[fieldId]) {
          const config = requiredFields[fieldId];

          // Verificar se é realmente obrigatório (pode ser função condicional)
          const isRequired =
            typeof config.required === "function"
              ? config.required()
              : config.required;

          if (isRequired) {
            // Validar conforme o tipo
            if (config.type === "number") {
              const value = parseFloat(field.value) || 0;
              if (
                field.value === "" ||
                (config.min !== null && value < config.min)
              ) {
                field.classList.add("error");
                if (errorElement) {
                  errorElement.classList.add("visible");
                }
                return false;
              }
            } else if (config.type === "text") {
              if (!field.value.trim()) {
                field.classList.add("error");
                if (errorElement) {
                  errorElement.classList.add("visible");
                }
                return false;
              }
            }
          }
        }

        return true;
      }

      // Validar tramos
      function validateTramos() {
        const tramosFields = document.querySelectorAll(".tramo-field");
        const errorElement = document.getElementById("tramos-error");
        let valid = true;

        tramosFields.forEach((field) => {
          field.classList.remove("error");
          const value = parseFloat(field.value) || 0;
          if (value < 0.5) {
            field.classList.add("error");
            valid = false;
          }
        });

        if (!valid && errorElement) {
          errorElement.classList.add("visible");
        } else if (errorElement) {
          errorElement.classList.remove("visible");
        }

        return valid;
      }

// Versão: 4.9
// Validar que todos os 3 campos de cada apoio estejam preenchidos
function validateApoios() {
  const apoiosRows = document.querySelectorAll(".apoio-row");
  const errorElement = document.getElementById("apoios-error");
  let valid = true;
  const emptyFields = [];

  apoiosRows.forEach((row, index) => {
    const alturaField = row.querySelector(".apoio-altura-field");
    const compField = row.querySelector(".apoio-comp-field");
    const largField = row.querySelector(".apoio-larg-field");
    
    // Remover marcação de erro primeiro
    if (alturaField) alturaField.classList.remove("error");
    if (compField) compField.classList.remove("error");
    if (largField) largField.classList.remove("error");
    
    // Verificar se algum campo está vazio
    const alturaVazia = !alturaField || !alturaField.value.trim() || parseFloat(alturaField.value) === 0;
    const compVazio = !compField || !compField.value.trim() || parseFloat(compField.value) === 0;
    const largVazio = !largField || !largField.value.trim() || parseFloat(largField.value) === 0;
    
    if (alturaVazia || compVazio || largVazio) {
      valid = false;
      
      // Marcar campos vazios com erro
      if (alturaVazia && alturaField) {
        alturaField.classList.add("error");
        emptyFields.push(`Apoio ${index + 1} - Altura`);
      }
      if (compVazio && compField) {
        compField.classList.add("error");
        emptyFields.push(`Apoio ${index + 1} - Comprimento`);
      }
      if (largVazio && largField) {
        largField.classList.add("error");
        emptyFields.push(`Apoio ${index + 1} - Largura`);
      }
    }
  });

  // Mostrar ou ocultar mensagem de erro
  if (!valid && errorElement) {
    errorElement.textContent = `Campos obrigatórios vazios: ${emptyFields.join(", ")}`;
    errorElement.style.display = "block";
  } else if (errorElement) {
    errorElement.style.display = "none";
  }

  return valid;
}


      // Modificar a função validateForm() para adicionar nova validação
      function validateForm() {
        let isValid = true;
        const missingFields = [];

        // Validar campos obrigatórios
        for (const fieldId in requiredFields) {
          const isFieldValid = validateField(fieldId);

          if (!isFieldValid) {
            isValid = false;
            const field = document.getElementById(fieldId);
            const label = document.querySelector(`label[for="${fieldId}"]`);
            missingFields.push(
              label ? label.textContent.replace(":", "") : fieldId
            );

            // Se não estiver visível, mostrar a aba correspondente
            const tabContent = field.closest(".tab-content");
            if (tabContent && !tabContent.classList.contains("active")) {
              const tabId = tabContent.id.replace("-content", "");
              document.querySelector(`.tab[data-tab="${tabId}"]`).click();
            }
          }
        }

        // Validar tramos
        const tramosValid = validateTramos();
        if (!tramosValid) {
          isValid = false;
          missingFields.push("Comprimento dos Tramos (mínimo 0.5m)");
        }

        // Validar apoios
        const apoiosValid = validateApoios();
        if (!apoiosValid) {
          isValid = false;
          missingFields.push("Altura dos Apoios");
        }

        // Validar proteção lateral (deve ter pelo menos um tipo em cada lado)
        const lateralProtectionValid = validateLateralProtection();
        if (!lateralProtectionValid) {
          isValid = false;
          missingFields.push(
            "Proteção Lateral (barreira, guarda-rodas ou CALCADA) em ambos os lados"
          );
        }

        // Adicionar validação das alas com o encontro
        const alaWithEncontroValid = validateAlaWithEncountro();
        if (!alaWithEncontroValid) {
          isValid = false;
          missingFields.push(
            "Ala obrigatória quando o encontro é Parede Frontal Portante"
          );
        }

        return { isValid, missingFields };
      }

      // Validar proteção lateral
      function validateLateralProtection() {
        // Verificar lado esquerdo
        const hasLeftProtection =
          (document.getElementById("tipo-barreira-esquerda").value !== "" &&
            document.getElementById("tipo-barreira-esquerda").value !== "Nenhum") ||
          (document.getElementById("guarda-rodas-esquerdo").value !== "" &&
            document.getElementById("guarda-rodas-esquerdo").value !==
              "Nenhum") ||
          (document.getElementById("tipo-calcada-esquerda").value !== "" &&
            document.getElementById("tipo-calcada-esquerda").value !== "Nenhum");

        // Verificar lado direito
        const hasRightProtection =
          (document.getElementById("tipo-barreira-direita").value !== "" &&
            document.getElementById("tipo-barreira-direita").value !== "Nenhum") ||
          (document.getElementById("guarda-rodas-direito").value !== "" &&
            document.getElementById("guarda-rodas-direito").value !==
              "Nenhum") ||
          (document.getElementById("tipo-calcada-direita").value !== "" &&
            document.getElementById("tipo-calcada-direita").value !== "Nenhum");

        // Destacar campos com erro se não houver proteção
        if (!hasLeftProtection) {
          document.getElementById("tipo-barreira-esquerda").classList.add("error");
          document
            .getElementById("guarda-rodas-esquerdo")
            .classList.add("error");
          document.getElementById("tipo-calcada-esquerda").classList.add("error");
        } else {
          document
            .getElementById("tipo-barreira-esquerda")
            .classList.remove("error");
          document
            .getElementById("guarda-rodas-esquerdo")
            .classList.remove("error");
          document.getElementById("tipo-calcada-esquerda").classList.remove("error");
        }

        if (!hasRightProtection) {
          document.getElementById("tipo-barreira-direita").classList.add("error");
          document
            .getElementById("guarda-rodas-direito")
            .classList.add("error");
          document.getElementById("tipo-calcada-direita").classList.add("error");
        } else {
          document.getElementById("tipo-barreira-direita").classList.remove("error");
          document
            .getElementById("guarda-rodas-direito")
            .classList.remove("error");
          document.getElementById("tipo-calcada-direita").classList.remove("error");
        }

        // Mostrar/ocultar mensagem de erro
        const errorMessage = document.getElementById(
          "lateral-protection-error"
        );
        if (!hasLeftProtection || !hasRightProtection) {
          errorMessage.style.display = "block";
        } else {
          errorMessage.style.display = "none";
        }

        return hasLeftProtection && hasRightProtection;
      }

      // Mostrar resumo antes de salvar
      function showSummaryBeforeSave() {
        // Validar o formulário
        const { isValid, missingFields } = validateForm();

        // Preparar o modal
        const summaryContent = document.getElementById("summary-content");
        const missingFieldsContainer = document.getElementById(
          "missing-fields-container"
        );
        const missingFieldsList = document.getElementById(
          "missing-fields-list"
        );
        const confirmSaveBtn = document.getElementById("confirm-save-btn");

        // Limpar conteúdo anterior
        summaryContent.innerHTML = "";
        missingFieldsList.innerHTML = "";

        // Coletar dados do formulário
        const formData = collectFormData();

        // Tratar campos obrigatórios não preenchidos
        if (!isValid) {
          missingFieldsContainer.style.display = "block";
          missingFields.forEach((field) => {
            const li = document.createElement("li");
            li.className = "missing-field";
            li.textContent = field;
            missingFieldsList.appendChild(li);
          });

          // Desabilitar botão de confirmar
          confirmSaveBtn.disabled = true;
        } else {
          missingFieldsContainer.style.display = "none";
          confirmSaveBtn.disabled = false;
        }

        // Gerar o resumo
        generateSummary(formData, summaryContent);

        // Exibir o modal
        document.getElementById("summary-modal").style.display = "block";
      }

      // Fechar modal de resumo
      function closeSummaryModal() {
        document.getElementById("summary-modal").style.display = "none";
      }

      // Versão: 3.0
      // Função corrigida para categorizar corretamente os campos no resumo

      function generateSummary(data, container) {
        // Lista completa de campos conhecidos para cada seção
        const allKnownSections = {
          "Informações Gerais": [
            "MODELADO",
            "NOME",
            "CODIGO",
            "LOTE",
            "GPS",
            "FOTOS SUPERIORES",
            "FOTOS INFERIORES",
            "UF",
            "RODOVIA",
            "KM",
            "DATA",
            "ENGENHEIRO",
            "TECNICO",
            "LATITUDE",
            "LONGITUDE",
          ],
          "Configurações Gerais": [
            "COMPRIMENTO",
            "LARGURA",
            "ALTURA",
            "QTD TRAMOS",
            "COMPRIMENTO TRAMOS",
          ],
          Transição: [
            "CORTINA ALTURA",
            "TIPO ALA PARALELA",
            "TIPO ALA PERPENDICULAR",
            "COMPRIMENTO ALA",
            "ESPESSURA ALA",
            "TIPO ENCONTRO",
            "DESLOCAMENTO ESQUERDO ENCONTRO LAJE",
            "DESLOCAMENTO DIREITO ENCONTRO LAJE",
            "COMPRIMENTO ENCONTRO LAJE",
            "LAJE TRANSICAO",
          ],
          Superestrutura: [
            "ALTURA LONGARINA",
            "DESLOCAMENTO ESQUERDO",
            "DESLOCAMENTO DIREITO",
            "QTD LONGARINAS",
            "QTD TRANSVERSINAS",
            "ESPESSURA LONGARINA",
            "ESPESSURA TRANSVERSINA",
            "ESPESSURA LAJE",
          ],
          Apoio: [
            "QTD PILARES",
            "PILAR DESCENTRALIZADO",
            "LARGURA PILAR",
            "COMPRIMENTO PILARES",
            "ALTURA APOIO",
            "TIPO APARELHO APOIO",
            "TIPO TRAVESSA",
            "ALTURA TRAVESSA",
            "TIPO ENCAMISAMENTO",
            "TIPO BLOCO SAPATA",
            "ALTURA BLOCO SAPATA",
            "LARGURA BLOCO SAPATA",
            "TIPO CONTRAVENTAMENTO PILAR",
          ],
          "Elementos Complementares": [
            "TIPO BARREIRA ESQUERDA",
            "LARGURA BARREIRA ESQUERDA",
            "TIPO BARREIRA DIREITA",
            "LARGURA BARREIRA DIREITA",
            "TIPO CALCADA ESQUERDA",
            "LARGURA CALCADA ESQUERDA",
            "TIPO CALCADA DIREITA",
            "LARGURA CALCADA DIREITA",
            "GUARDA RODAS ESQUERDO",
            "LARGURA GUARDA RODAS ESQUERDO",
            "GUARDA RODAS DIREITO",
            "LARGURA GUARDA RODAS DIREITO",
            "TIPO PAVIMENTO",
            "QTD BUZINOTES",
          ],
        };

        // Conjunto de todos os campos conhecidos
        const allKnownFields = new Set();
        Object.values(allKnownSections).forEach((fields) => {
          fields.forEach((field) => allKnownFields.add(field));
        });

        // Para cada seção, criar um container
        for (const [sectionTitle, knownFields] of Object.entries(
          allKnownSections
        )) {
          const sectionDiv = document.createElement("div");
          sectionDiv.className = "summary-section";

          const sectionHeader = document.createElement("h3");
          sectionHeader.textContent = sectionTitle;
          sectionDiv.appendChild(sectionHeader);

          // Verificar se a seção tem dados para mostrar
          let hasData = false;

          // Para cada campo conhecido na seção
          knownFields.forEach((fieldName) => {
            if (data[fieldName] !== undefined) {
              hasData = true;
              const rowDiv = document.createElement("div");
              rowDiv.className = "summary-row";

              const labelDiv = document.createElement("div");
              labelDiv.className = "summary-label";
              labelDiv.textContent = fieldName;

              const valueDiv = document.createElement("div");
              valueDiv.className = "summary-value";
              valueDiv.textContent = data[fieldName] || "-";

              rowDiv.appendChild(labelDiv);
              rowDiv.appendChild(valueDiv);
              sectionDiv.appendChild(rowDiv);
            }
          });

          // Adicionar seção ao container somente se tiver dados
          if (hasData) {
            container.appendChild(sectionDiv);
          }
        }

        // Tratar campos personalizados (os que não estão na lista conhecida)
        const customFields = Object.keys(data).filter(
          (key) => !allKnownFields.has(key)
        );

        if (customFields.length > 0) {
          const customSection = document.createElement("div");
          customSection.className = "summary-section";

          const customTitle = document.createElement("h3");
          customTitle.textContent = "Campos Personalizados";
          customSection.appendChild(customTitle);

          customFields.forEach((field) => {
            const rowDiv = document.createElement("div");
            rowDiv.className = "summary-row";

            const labelDiv = document.createElement("div");
            labelDiv.className = "summary-label";
            labelDiv.textContent = field;

            const valueDiv = document.createElement("div");
            valueDiv.className = "summary-value";
            valueDiv.textContent = data[field] || "-";

            rowDiv.appendChild(labelDiv);
            rowDiv.appendChild(valueDiv);
            customSection.appendChild(rowDiv);
          });

          container.appendChild(customSection);
        }
      }

      // Substituir a função global
      window.generateSummary = generateSummary;


// Versão: 4.11
// Modificação da função generateTramosFields com validação de soma
function generateTramosFields() {
  const qtdTramos =
    parseInt(document.getElementById("qtd-tramos").value) || 1;
  const tramosContainer = document.getElementById("tramos-fields");
  
  // Garantir mínimo de 1 tramo
  if (qtdTramos < 1) {
    document.getElementById("qtd-tramos").value = 1;
    return generateTramosFields();
  }

  // Verificar se já existem campos com a quantidade correta
  const existingFields = tramosContainer.querySelectorAll(".tramo-field");
  if (existingFields.length === qtdTramos) {
    // Campos já existem com a quantidade correta, não recriar
    generateApoiosFields(qtdTramos);
    return;
  }

  // Salvar valores existentes antes de recriar
  const savedValues = {};
  existingFields.forEach((field) => {
    if (field.value) {
      savedValues[field.id] = field.value;
    }
  });

  // Limpar e recriar apenas se a quantidade mudou
  tramosContainer.innerHTML = "";

  // Gerar campos para tramos em pilha
  for (let i = 1; i <= qtdTramos; i++) {
    const div = document.createElement("div");
    div.className = "dynamic-field";
    const fieldId = `tramo-${i}`;
    const savedValue = savedValues[fieldId] || (i === 1 ? "0.5" : "");
    
    div.innerHTML = `
      <label for="${fieldId}">Tramo ${i}:</label>
      <input type="number" id="${fieldId}" name="${fieldId}" step="0.01" min="0.5" class="tramo-field" value="${savedValue}">
    `;
    tramosContainer.appendChild(div);

    // Adicionar validação
    const input = div.querySelector("input");
    input.addEventListener("blur", validateTramos);
    input.addEventListener("blur", validateTramosSum); // Validar soma ao sair do campo
    input.addEventListener("change", validateTramosSum); // Validar soma ao mudar valor
  }

  // Atualizar também os campos de apoios
  generateApoiosFields(qtdTramos);
}




      // Adicionar uma função de inicialização que será chamada ao abrir a aba
      function initConfiguracao() {
        // Certificar-se de que o valor de qtd-tramos seja pelo menos 1
        const qtdTramosInput = document.getElementById("qtd-tramos");
        if (!qtdTramosInput.value || parseInt(qtdTramosInput.value) < 1) {
          qtdTramosInput.value = 1;
        }

        // Gerar os campos de tramos
        generateTramosFields();

        // Verificar se o primeiro tramo está visível e tem um valor
        const firstTramoField = document.querySelector(".tramo-field");
        if (firstTramoField && !firstTramoField.value) {
          firstTramoField.value = "0.5";
        }
      }

      // Modificar a função de inicialização das abas para chamar initConfiguracao quando necessário
      function initTabSystem() {
        const tabs = document.querySelectorAll(".tab");

        if (tabs.length === 0) {
          console.error("Nenhuma aba encontrada na página!");
          return;
        }

        tabs.forEach((tab) => {
          tab.addEventListener("click", function (event) {
            event.preventDefault();

            const tabId = this.getAttribute("data-tab");

            // Desativar todas as abas e conteúdos
            document
              .querySelectorAll(".tab")
              .forEach((t) => t.classList.remove("active"));
            document
              .querySelectorAll(".tab-content")
              .forEach((c) => c.classList.remove("active"));

            // Ativar a aba clicada
            this.classList.add("active");

            // Ativar o conteúdo correspondente
            const tabContent = document.getElementById(tabId + "-content");
            if (tabContent) {
              tabContent.classList.add("active");

              // Se for a aba de configuração, inicializar os campos
              if (tabId === "configuracao") {
                initConfiguracao();
              }
            } else {
              console.error(`Conteúdo da aba não encontrado: ${tabId}-content`);
            }
          });
        });

        // Verificar se já existe uma aba ativa
        const activeTab = document.querySelector(".tab.active");
        if (activeTab) {
          const activeTabId = activeTab.getAttribute("data-tab");
          if (activeTabId === "configuracao") {
            initConfiguracao();
          }
        } else if (tabs.length > 0) {
          // Ativar a primeira aba por padrão
          const firstTab = tabs[0];
          firstTab.classList.add("active");

          const firstTabId = firstTab.getAttribute("data-tab");
          const firstTabContent = document.getElementById(
            firstTabId + "-content"
          );
          if (firstTabContent) {
            firstTabContent.classList.add("active");
            if (firstTabId === "configuracao") {
              initConfiguracao();
            }
          }
        }

        console.log("Sistema de abas inicializado com sucesso!");
      }

      // Inicializar o sistema de abas ao carregar a página
      document.addEventListener("DOMContentLoaded", function () {
        initTabSystem();

        // Verificar o estado inicial
        if (
          document
            .querySelector('.tab[data-tab="configuracao"]')
            .classList.contains("active")
        ) {
          initConfiguracao();
        }
      });

      // Se a página já estiver carregada, inicializar imediatamente
      if (document.readyState !== "loading") {
        initTabSystem();
      }



      
      // Versão: 4.8
// Gerar campos dinâmicos para apoios com 3 inputs: altura, comprimento e largura
function generateApoiosFields(qtdTramos) {
  const qtdApoios = qtdTramos > 1 ? qtdTramos - 1 : 0;
  const apoiosContainer = document.getElementById("apoios-fields");
  
  // Verificar se já existem campos com a quantidade correta
  const existingRows = apoiosContainer.querySelectorAll(".apoio-row");
  if (existingRows.length === qtdApoios) {
    // Campos já existem com a quantidade correta, não recriar
    return;
  }
  
  // Salvar valores existentes antes de recriar
  const savedValues = {
    alturas: {},
    comprimentos: {},
    larguras: {}
  };
  
  existingRows.forEach((row, index) => {
    const alturaField = row.querySelector(".apoio-altura-field");
    const compField = row.querySelector(".apoio-comp-field");
    const largField = row.querySelector(".apoio-larg-field");
    
    if (alturaField && alturaField.value) savedValues.alturas[index + 1] = alturaField.value;
    if (compField && compField.value) savedValues.comprimentos[index + 1] = compField.value;
    if (largField && largField.value) savedValues.larguras[index + 1] = largField.value;
  });
  
  // Limpar e recriar apenas se a quantidade mudou
  apoiosContainer.innerHTML = "";

  for (let i = 1; i <= qtdApoios; i++) {
    const div = document.createElement("div");
    div.className = "apoio-row";
    
    const alturaValue = savedValues.alturas[i] || "";
    const compValue = savedValues.comprimentos[i] || "";
    const largValue = savedValues.larguras[i] || "";
    
    div.innerHTML = `
      <div class="apoio-label">Apoio ${i}</div>
      <input type="number" id="apoio-altura-${i}" name="apoio-altura-${i}" step="0.01" min="0" class="apoio-altura-field" placeholder="0.00" value="${alturaValue}">
      <input type="number" id="apoio-comp-${i}" name="apoio-comp-${i}" step="0.01" min="0" class="apoio-comp-field" placeholder="0.00" value="${compValue}">
      <input type="number" id="apoio-larg-${i}" name="apoio-larg-${i}" step="0.01" min="0" class="apoio-larg-field" placeholder="0.00" value="${largValue}">
    `;
    apoiosContainer.appendChild(div);

    // Adicionar validação para os 3 inputs
    const inputs = div.querySelectorAll("input");
    inputs.forEach(input => {
      input.addEventListener("blur", validateApoios);
    });
  }
}





      // Mostrar modal para adicionar campo
      function showAddField(targetContainer) {
        document.getElementById("target-container").value = targetContainer;
        document.getElementById("new-field-name").value = "";
        document.getElementById("select-options-input").value = "Nenhum";
        document.getElementById("add-field-modal").style.display = "block";
        document.querySelectorAll('input[name="field-type"]')[0].checked = true;
        document.getElementById("select-options").style.display = "none";
      }

      // Fechar modal
      function closeModal() {
        document.getElementById("add-field-modal").style.display = "none";
      }

      // Adicionar campo personalizado
      function addCustomField() {
        const fieldName = document
          .getElementById("new-field-name")
          .value.trim();
        if (!fieldName) {
          alert("Por favor, digite um nome para o campo.");
          return;
        }

        const targetContainer =
          document.getElementById("target-container").value;
        const container = document.getElementById(targetContainer);
        const fieldType = document.querySelector(
          'input[name="field-type"]:checked'
        ).value;

        // Criar div para o campo personalizado
        const customFieldDiv = document.createElement("div");
        customFieldDiv.className = "form-row";

        // Criar o campo baseado no tipo selecionado
        let fieldHtml = "";
        const fieldId =
          "custom-" + fieldName.replace(/\s+/g, "-").toLowerCase();
        const fieldNameAttr = fieldName.toUpperCase();

        if (fieldType === "select") {
          const optionsText = document.getElementById(
            "select-options-input"
          ).value;
          const options = optionsText
            .split("\n")
            .map((opt) => opt.trim())
            .filter((opt) => opt);

          const optionsHtml = options
            .map((opt) => `<option value="${opt}">${opt}</option>`)
            .join("");

          fieldHtml = `
                    <div class="form-group">
                        <label for="${fieldId}">${fieldName}:</label>
                        <select id="${fieldId}" name="${fieldNameAttr}" class="custom-field">
                            <option value="">Selecione</option>
                            ${optionsHtml}
                        </select>
                    </div>
                `;
        } else if (fieldType === "number-int") {
          fieldHtml = `
                    <div class="form-group">
                        <label for="${fieldId}">${fieldName}:</label>
                        <input type="number" id="${fieldId}" name="${fieldNameAttr}" min="0" class="custom-field">
                    </div>
                `;
        } else if (fieldType === "number-double") {
          fieldHtml = `
                    <div class="form-group">
                        <label for="${fieldId}">${fieldName}:</label>
                        <input type="number" id="${fieldId}" name="${fieldNameAttr}" step="0.01" min="0" class="custom-field">
                    </div>
                `;
        }

        customFieldDiv.innerHTML = fieldHtml;
        container.appendChild(customFieldDiv);

        // Adicionar validação para campos numéricos
        const newField = customFieldDiv.querySelector('input[type="number"]');
        if (newField) {
          newField.addEventListener("change", function () {
            const min = parseFloat(this.getAttribute("min") || 0);
            const value = parseFloat(this.value) || 0;

            if (value < min) {
              this.value = min;
            }
          });
        }

        closeModal();
      }


      
      // Mostrar modal de importação
      function showImportModal() {
        document.getElementById("import-modal").style.display = "block";
      }

      // Fechar modal de importação
      function closeImportModal() {
        document.getElementById("import-modal").style.display = "none";
      }

      // Carregar dados do CSV para o formulário
      function loadCSVDataToForm(headers, values) {
        try {
          clearForm(); // Limpar o formulário antes

          // Mapear valores para os campos do formulário
          for (let i = 0; i < headers.length; i++) {
            const header = headers[i];
            if (i < values.length) {
              const value = values[i];

              // Tratar campos especiais
              if (header === "MODELADO") {
                document.getElementById("modelado").checked =
                  value.toLowerCase() === "true";
              } else if (header === "COMPRIMENTO TRAMOS") {
                const tramos = value.split(";");
                document.getElementById("qtd-tramos").value = tramos.length;
                generateTramosFields(); // Regenerar campos de tramos

                // Preencher valores dos tramos
                const tramosFields = document.querySelectorAll(".tramo-field");
                for (let j = 0; j < tramosFields.length; j++) {
                  if (j < tramos.length) {
                    tramosFields[j].value = tramos[j];
                  }
                }
              } else if (header === "ALTURA APOIO") {
                const apoios = value.split(";");
                // Não precisamos definir o número de apoios, pois isso é calculado com base nos tramos

                // Preencher valores dos apoios
                const apoiosFields = document.querySelectorAll(".apoio-field");
                for (let j = 0; j < apoiosFields.length; j++) {
                  if (j < apoios.length) {
                    apoiosFields[j].value = apoios[j];
                  }
                }
              } else {
                // Outros campos
                const field = document.querySelector(`[name="${header}"]`);
                if (field) {
                  field.value = value;
                }
              }
            }
          }

          // Definir o código atual
          const codigoField = document.getElementById("codigo");
          if (codigoField.value) {
            currentWorkCode = codigoField.value;
          }

          // Executar validação após carregar
          validateForm();
        } catch (error) {
          console.error("Erro ao carregar dados do CSV:", error);
          alert("Erro ao carregar dados do CSV: " + error.message);
        }
      }


// Versão: 4.10
// Salvar a obra atual no banco de dados com validação completa de apoios
function saveCurrentWork() {
  try {
    // Validar o formulário
    const { isValid, missingFields } = validateForm();
    if (!isValid) {
      alert(
        "Por favor, preencha todos os campos obrigatórios antes de salvar."
      );
      return;
    }

    // Validar dimensões
    if (
      !validateTramosLength() ||
      !validateHeights() ||
      !validateDisplacements()
    ) {
      return; // Interrompe a execução se qualquer validação falhar
    }
    
    // Validar soma dos tramos
    if (!validateTramosSum()) {
      alert("A soma dos tramos deve ser igual ao comprimento total da ponte.");
      return;
    }
    
    // Validar apoios (apenas se houver apoios)
    const apoiosRows = document.querySelectorAll(".apoio-row");
    if (apoiosRows.length > 0 && !validateApoios()) {
      alert("Por favor, preencha todos os campos dos apoios (altura, comprimento e largura).");
      return;
    }
    
    const codigo = document.getElementById("codigo").value.trim();

    if (!codigo) {
      alert("Por favor, preencha o campo Código antes de salvar.");
      return;
    }

    const formData = collectFormData();

    if (db) {
      const transaction = db.transaction(["obras"], "readwrite");
      const objectStore = transaction.objectStore("obras");

      const request = objectStore.put(formData);

      request.onsuccess = function (event) {
        alert(`Obra ${codigo} salva com sucesso!`);
        currentWorkCode = codigo;
        loadWorksList(); // Recarregar a lista de obras
        closeSummaryModal(); // Fechar o modal de resumo se estiver aberto
      };

      request.onerror = function (event) {
        console.error("Erro ao salvar a obra:", event.target.error);
        alert(`Erro ao salvar a obra: ${event.target.error}`);
      };
    } else {
      alert("Banco de dados não está disponível.");
    }
  } catch (error) {
    console.error("Erro ao salvar obra:", error);
    alert("Erro ao salvar obra: " + error.message);
  }
}



      // Salvar múltiplas obras no banco de dados
      function saveMultipleWorks(works) {
        try {
          if (!db) {
            alert("Banco de dados não está disponível.");
            return;
          }

          const transaction = db.transaction(["obras"], "readwrite");
          const objectStore = transaction.objectStore("obras");

          let countSuccess = 0;
          let countError = 0;

          works.forEach((work) => {
            const request = objectStore.put(work);

            request.onsuccess = function () {
              countSuccess++;
              if (countSuccess + countError === works.length) {
                alert(
                  `Importação concluída: ${countSuccess} obras importadas com sucesso, ${countError} erros.`
                );
                loadWorksList(); // Recarregar a lista de obras
              }
            };

            request.onerror = function (event) {
              countError++;
              console.error(
                `Erro ao salvar a obra ${work.CODIGO}:`,
                event.target.error
              );
              if (countSuccess + countError === works.length) {
                alert(
                  `Importação concluída: ${countSuccess} obras importadas com sucesso, ${countError} erros.`
                );
                loadWorksList(); // Recarregar a lista de obras
              }
            };
          });
        } catch (error) {
          console.error("Erro ao salvar múltiplas obras:", error);
          alert("Erro ao salvar múltiplas obras: " + error.message);
        }
      }




// Versão: 2.0
// Função atualizada para coletar dados do formulário com normalização de decimais
function collectFormData() {
  try {
    const form = document.getElementById("oae-form");
    const formData = new FormData(form);

    // Objeto para armazenar os dados
    const data = {};

    // Processar campos comuns
    for (let [key, value] of formData.entries()) {
      // Ignorar campos dos tramos/apoios dinâmicos (eles são tratados separadamente)
      if (!key.startsWith("tramo-") && !key.startsWith("apoio-")) {
        // Aplicar normalização em campos numéricos/medidas
        // Lista de campos que devem ser normalizados
        const camposNumericos = [
          "COMPRIMENTO",
          "LARGURA",
          "ALTURA",
          "DESLOCAMENTO",
          "KM_INICIAL",
          "KM_FINAL"
        ];
        
        if (camposNumericos.includes(key.toUpperCase())) {
          data[key] = normalizeDecimal(value);
        } else {
          data[key] = value;
        }
      }
    }

    // Verificar se o modelado está marcado
    if (document.getElementById("modelado").checked) {
      data["MODELADO"] = "TRUE";
    } else {
      data["MODELADO"] = "FALSE";
    }

    if (document.getElementById("gps").checked) {
      data["GPS"] = "TRUE";
    } else {
      data["GPS"] = "FALSE";
    }

    // Coletar valores dos tramos COM normalização
    const tramosValues = [];
    const tramosFields = document.querySelectorAll(".tramo-field");
    tramosFields.forEach((field) => {
      // Garantir valor mínimo de 0.5
      const value = parseFloat(field.value) || 0;
      const normalizedValue = normalizeDecimal(value < 0.5 ? "0.50" : field.value);
      tramosValues.push(normalizedValue);
    });
    data["COMPRIMENTO TRAMOS"] = tramosValues.join(";");

    // Coletar valores dos apoios COM normalização
    const alturas = [];
    const larguras = [];
    const comprimentos = [];

    document.querySelectorAll(".apoio-altura-field").forEach(f => {
      alturas.push(normalizeDecimal(f.value || "0.00"));
    });
    
    document.querySelectorAll(".apoio-larg-field").forEach(f => {
      larguras.push(normalizeDecimal(f.value || "0.00"));
    });
    
    document.querySelectorAll(".apoio-comp-field").forEach(f => {
      comprimentos.push(normalizeDecimal(f.value || "0.00"));
    });

    data["ALTURA APOIO"] = alturas.join(";");
    data["LARGURA PILAR"] = larguras.join(";");
    data["COMPRIMENTO PILARES"] = comprimentos.join(";");

    return data;
  } catch (error) {
    console.error("Erro ao coletar dados do formulário:", error);
    alert("Erro ao coletar dados do formulário: " + error.message);
    return {};
  }
}

      


      // Carregar obra específica do banco de dados
      function loadWork(codigo) {
        try {
          if (!db) {
            alert("Banco de dados não está disponível.");
            return;
          }

          const transaction = db.transaction(["obras"], "readonly");
          const objectStore = transaction.objectStore("obras");
          const request = objectStore.get(codigo);

          request.onsuccess = function (event) {
            const work = event.target.result;

            if (work) {
              loadWorkToForm(work);
              currentWorkCode = codigo;

              // Marcar a obra como selecionada na lista
              const workItems = document.querySelectorAll(".work-item");
              workItems.forEach((item) => {
                if (item.getAttribute("data-code") === codigo) {
                  item.classList.add("selected");
                } else {
                  item.classList.remove("selected");
                }
              });
            } else {
              alert(`Obra com código ${codigo} não encontrada.`);
            }
          };

          request.onerror = function (event) {
            console.error("Erro ao carregar a obra:", event.target.error);
            alert(`Erro ao carregar a obra: ${event.target.error}`);
          };
        } catch (error) {
          console.error("Erro ao carregar obra:", error);
          alert("Erro ao carregar obra: " + error.message);
        }
      }




      // Versão: 4.5
// Função para carregar dados de uma obra no formulário
function loadWorkToForm(work) {
  try {
    clearForm(); // Limpar o formulário antes

    // Processar campos especiais
    if (work["MODELADO"] === "TRUE") {
      document.getElementById("modelado").checked = true;
    } else {
      document.getElementById("modelado").checked = false;
    }

    if (work["COMPRIMENTO TRAMOS"]) {
      const tramos = work["COMPRIMENTO TRAMOS"].split(";");
      document.getElementById("qtd-tramos").value = tramos.length;
      generateTramosFields(); // Regenerar campos de tramos

      // Preencher valores dos tramos
      const tramosFields = document.querySelectorAll(".tramo-field");
      for (let i = 0; i < tramosFields.length; i++) {
        if (i < tramos.length) {
          tramosFields[i].value = tramos[i];
        }
      }
    }

    // Carregar os 3 campos de apoio: altura, largura e comprimento dos pilares
    if (work["ALTURA APOIO"] || work["LARGURA PILAR"] || work["COMPRIMENTO PILARES"]) {
      const alturas = work["ALTURA APOIO"] ? work["ALTURA APOIO"].split(";") : [];
      const larguras = work["LARGURA PILAR"] ? work["LARGURA PILAR"].split(";") : [];
      const comprimentos = work["COMPRIMENTO PILARES"] ? work["COMPRIMENTO PILARES"].split(";") : [];

      // Preencher valores dos apoios nos 3 campos
      const apoiosAlturaFields = document.querySelectorAll(".apoio-altura-field");
      const apoiosLargFields = document.querySelectorAll(".apoio-larg-field");
      const apoiosCompFields = document.querySelectorAll(".apoio-comp-field");

      for (let i = 0; i < apoiosAlturaFields.length; i++) {
        if (i < alturas.length) apoiosAlturaFields[i].value = alturas[i];
        if (i < larguras.length) apoiosLargFields[i].value = larguras[i];
        if (i < comprimentos.length) apoiosCompFields[i].value = comprimentos[i];
      }
    }

    // Processar outros campos
    for (const [key, value] of Object.entries(work)) {
      if (
        key !== "MODELADO" &&
        key !== "COMPRIMENTO TRAMOS" &&
        key !== "ALTURA APOIO" &&
        key !== "LARGURA PILAR" &&
        key !== "COMPRIMENTO PILARES"
      ) {
        const field = document.querySelector(`[name="${key}"]`);
        if (field) {
          field.value = value;
        }
      }
    }

    // Executar validação após carregar
    validateForm();
  } catch (error) {
    console.error("Erro ao carregar dados no formulário:", error);
    alert("Erro ao carregar dados no formulário: " + error.message);
  }
}




      // Carregar lista de obras do banco de dados
      function loadWorksList() {
        try {
          if (!db) {
            console.warn("Banco de dados não está disponível.");
            return;
          }

          const worksList = document.getElementById("works-list");
          worksList.innerHTML = '<div class="work-item">Carregando...</div>';

          const transaction = db.transaction(["obras"], "readonly");
          const objectStore = transaction.objectStore("obras");
          const request = objectStore.getAll();

          request.onsuccess = function (event) {
            const works = event.target.result;

            if (works.length === 0) {
              worksList.innerHTML =
                '<div class="work-item">Nenhuma obra cadastrada</div>';
            } else {
              worksList.innerHTML = "";

              works.forEach((work) => {
                const workItem = document.createElement("div");
                workItem.className = "work-item";
                if (work.CODIGO === currentWorkCode) {
                  workItem.classList.add("selected");
                }
                workItem.setAttribute("data-code", work.CODIGO);
                workItem.setAttribute("data-lote", work.LOTE || "");

                workItem.innerHTML = `
            <span>${work.CODIGO} - Lote: ${work.LOTE || "N/A"} - ${
                  work.NOME || "Sem nome"
                }</span>
            <button type="button" class="delete-btn" onclick="deleteWork('${
              work.CODIGO
            }', event)">Excluir</button>
          `;

                workItem.addEventListener("click", function (e) {
                  if (!e.target.classList.contains("delete-btn")) {
                    loadWork(work.CODIGO);
                  }
                });

                worksList.appendChild(workItem);
              });
            }
          };

          request.onerror = function (event) {
            console.error(
              "Erro ao carregar a lista de obras:",
              event.target.error
            );
            worksList.innerHTML =
              '<div class="work-item">Erro ao carregar obras</div>';
          };
        } catch (error) {
          console.error("Erro ao carregar lista de obras:", error);
          alert("Erro ao carregar lista de obras: " + error.message);
        }
      }

      // Filtrar obras por código e/ou lote

      function filterWorks() {
        try {
          const filterText = document
            .getElementById("filter-works")
            .value.trim()
            .toLowerCase();
          const filterLote = document
            .getElementById("filter-lote")
            .value.trim()
            .toLowerCase();

          if (!db) {
            alert("Banco de dados não está disponível.");
            return;
          }

          const worksList = document.getElementById("works-list");
          worksList.innerHTML = '<div class="work-item">Filtrando...</div>';

          const transaction = db.transaction(["obras"], "readonly");
          const objectStore = transaction.objectStore("obras");
          const request = objectStore.getAll();

          request.onsuccess = function (event) {
            const works = event.target.result;
            let filteredWorks = works;

            // Filtrar por código e nome
            if (filterText) {
              filteredWorks = filteredWorks.filter(
                (work) =>
                  (work.CODIGO &&
                    work.CODIGO.toLowerCase().includes(filterText)) ||
                  (work.NOME && work.NOME.toLowerCase().includes(filterText))
              );
            }

            // Filtrar por lote
            if (filterLote) {
              filteredWorks = filteredWorks.filter(
                (work) =>
                  work.LOTE && work.LOTE.toLowerCase().includes(filterLote)
              );
            }

            if (filteredWorks.length === 0) {
              worksList.innerHTML =
                '<div class="work-item">Nenhuma obra encontrada</div>';
            } else {
              worksList.innerHTML = "";

              filteredWorks.forEach((work) => {
                const workItem = document.createElement("div");
                workItem.className = "work-item";
                if (work.CODIGO === currentWorkCode) {
                  workItem.classList.add("selected");
                }
                workItem.setAttribute("data-code", work.CODIGO);
                workItem.setAttribute("data-lote", work.LOTE || "");

                workItem.innerHTML = `
            <span>${work.CODIGO} - Lote: ${work.LOTE || "N/A"} - ${
                  work.NOME || "Sem nome"
                }</span>
            <button type="button" class="delete-btn" onclick="deleteWork('${
              work.CODIGO
            }', event)">Excluir</button>
          `;

                workItem.addEventListener("click", function (e) {
                  if (!e.target.classList.contains("delete-btn")) {
                    loadWork(work.CODIGO);
                  }
                });

                worksList.appendChild(workItem);
              });
            }
          };

          request.onerror = function (event) {
            console.error("Erro ao filtrar obras:", event.target.error);
            worksList.innerHTML =
              '<div class="work-item">Erro ao filtrar obras</div>';
          };
        } catch (error) {
          console.error("Erro ao filtrar obras:", error);
          alert("Erro ao filtrar obras: " + error.message);
        }
      }

 
      // Excluir uma obra do banco de dados
      function deleteWork(codigo, event) {
        try {
          event.stopPropagation(); // Evitar que o clique propague para o elemento pai

          if (confirm(`Tem certeza que deseja excluir a obra ${codigo}?`)) {
            if (!db) {
              alert("Banco de dados não está disponível.");
              return;
            }

            const transaction = db.transaction(["obras"], "readwrite");
            const objectStore = transaction.objectStore("obras");
            const request = objectStore.delete(codigo);

            request.onsuccess = function () {
              alert(`Obra ${codigo} excluída com sucesso.`);

              // Se a obra excluída for a atual, limpar o formulário
              if (codigo === currentWorkCode) {
                clearForm();
                currentWorkCode = null;
              }

              loadWorksList(); // Recarregar a lista de obras
            };

            request.onerror = function (event) {
              console.error("Erro ao excluir a obra:", event.target.error);
              alert(`Erro ao excluir a obra: ${event.target.error}`);
            };
          }
        } catch (error) {
          console.error("Erro ao excluir obra:", error);
          alert("Erro ao excluir obra: " + error.message);
        }
      }

      // Limpar todo o banco de dados
      function clearDatabase() {
        try {
          if (
            confirm(
              "Tem certeza que deseja limpar todas as obras do banco de dados? Esta ação não pode ser desfeita!"
            )
          ) {
            if (!db) {
              alert("Banco de dados não está disponível.");
              return;
            }

            const transaction = db.transaction(["obras"], "readwrite");
            const objectStore = transaction.objectStore("obras");
            const request = objectStore.clear();

            request.onsuccess = function () {
              alert("Banco de dados limpo com sucesso.");
              clearForm();
              currentWorkCode = null;
              loadWorksList(); // Recarregar a lista de obras
            };

            request.onerror = function (event) {
              console.error(
                "Erro ao limpar o banco de dados:",
                event.target.error
              );
              alert(`Erro ao limpar o banco de dados: ${event.target.error}`);
            };
          }
        } catch (error) {
          console.error("Erro ao limpar banco de dados:", error);
          alert("Erro ao limpar banco de dados: " + error.message);
        }
      }

      // Criar nova obra
      function createNewWork() {
        clearForm();
        currentWorkCode = null;

        // Remover a seleção de todas as obras na lista
        const workItems = document.querySelectorAll(".work-item");
        workItems.forEach((item) => {
          item.classList.remove("selected");
        });
      }

      // Mostrar lembrete para salvar dados
      function showSaveReminder() {
        try {
          const reminder = document.getElementById("save-reminder");
          reminder.style.display = "block";

          // Ocultar o lembrete após 5 segundos
          setTimeout(function () {
            reminder.style.display = "none";
          }, 5000);
        } catch (error) {
          console.error("Erro ao mostrar lembrete:", error);
        }
      }

      // Iniciar lembretes periódicos para salvar dados
      function startSaveReminders() {
        try {
          // Mostrar lembrete a cada 5 minutos
          saveReminderInterval = setInterval(showSaveReminder, 5 * 60 * 1000);
        } catch (error) {
          console.error("Erro ao iniciar lembretes:", error);
        }
      }

      // Limpar formulário
      function clearForm() {
        try {
          document.getElementById("oae-form").reset();
          document.getElementById("csv-line").style.display = "none";

          // Limpar mensagens de erro
          document.querySelectorAll(".error").forEach((el) => {
            el.classList.remove("error");
          });

          document.querySelectorAll(".error-message").forEach((el) => {
            el.classList.remove("visible");
          });

          // Ocultar mensagem de erro de proteção lateral
          document.getElementById("lateral-protection-error").style.display =
            "none";

          generateTramosFields(); // Regenerar os campos dinâmicos
        } catch (error) {
          console.error("Erro ao limpar formulário:", error);
          alert("Erro ao limpar formulário: " + error.message);
        }
      }

      // Mostrar o modal de importação de múltiplas obras
      function showImportModal() {
        document.getElementById("csv-file-input").value = "";
        document.getElementById("import-modal").style.display = "block";
      }

      // Versão: 1.0
      // Função corrigida para validar o comprimento dos tramos com tolerância numérica

      function validateTramosLength() {
        // Obter o comprimento total e arredondar para 2 casas decimais
        const comprimentoTotal =
          parseFloat(document.getElementById("comprimento").value) || 0;
        const comprimentoTotalArredondado =
          Math.round(comprimentoTotal * 100) / 100;

        // Somar comprimentos dos tramos
        let somaTramos = 0;
        const tramosFields = document.querySelectorAll(".tramo-field");
        tramosFields.forEach((field) => {
          somaTramos += parseFloat(field.value) || 0;
        });

        // Arredondar a soma dos tramos para 2 casas decimais
        const somaTramosArredondada = Math.round(somaTramos * 100) / 100;

        // Definir uma pequena tolerância para comparações de ponto flutuante
        const epsilon = 0.01; // Tolerância de 1cm

        // Verificar se a soma dos tramos excede o comprimento total (com tolerância)
        if (somaTramosArredondada > comprimentoTotalArredondado + epsilon) {
          // Destacar os campos com problema
          document.getElementById("comprimento").classList.add("error");
          tramosFields.forEach((field) => field.classList.add("error"));

          // Mostrar mensagem de erro com valores arredondados
          alert(
            `O comprimento total dos tramos (${somaTramosArredondada.toFixed(
              2
            )}m) não pode exceder o comprimento da estrutura (${comprimentoTotalArredondado.toFixed(
              2
            )}m).`
          );
          return false;
        }

        // Remover destaque de erro se estiver tudo certo
        document.getElementById("comprimento").classList.remove("error");
        tramosFields.forEach((field) => field.classList.remove("error"));
        return true;
      }

      // Atualizar evento do input de arquivo
      document.addEventListener("DOMContentLoaded", function () {
        const fileInput = document.getElementById("csv-file-input");
        if (fileInput) {
          fileInput.addEventListener("change", function () {
            if (this.files.length > 0) {
              processImportFile();
            }
          });
        }
      });

      // Validar relação entre altura da longarina e altura do apoio
      function validateHeights() {
        const alturaTotal =
          parseFloat(document.getElementById("altura").value) || 0;
        const alturaLongarina =
          parseFloat(document.getElementById("altura-longarina").value) || 0;

        // Obter as alturas dos apoios (pode haver múltiplos)
        const apoiosFields = document.querySelectorAll(".apoio-field");
        let alturaMaxApoio = 0;

        // Encontrar a altura máxima dos apoios
        apoiosFields.forEach((field) => {
          const alturaApoio = parseFloat(field.value) || 0;
          if (alturaApoio > alturaMaxApoio) {
            alturaMaxApoio = alturaApoio;
          }
        });

        // Calcular soma
        const somaAlturas = alturaLongarina + alturaMaxApoio;

        // Verificar se a soma excede a altura total
        if (somaAlturas > alturaTotal) {
          // Destacar campos com problema
          document.getElementById("altura").classList.add("error");
          document.getElementById("altura-longarina").classList.add("error");
          apoiosFields.forEach((field) => field.classList.add("error"));

          // Mostrar mensagem de erro
          alert(
            `A soma da altura da longarina (${alturaLongarina.toFixed(
              2
            )}m) e do apoio (${alturaMaxApoio.toFixed(
              2
            )}m) não pode exceder a altura total da estrutura (${alturaTotal.toFixed(
              2
            )}m).`
          );
          return false;
        }

        // Remover destaque de erro se estiver tudo certo
        document.getElementById("altura").classList.remove("error");
        document.getElementById("altura-longarina").classList.remove("error");
        apoiosFields.forEach((field) => field.classList.remove("error"));
        return true;
      }

      // Validar relação entre deslocamentos e largura
      function validateDisplacements() {
        const larguraTotal =
          parseFloat(document.getElementById("largura").value) || 0;
        const deslocamentoEsquerdo =
          parseFloat(document.getElementById("deslocamento-esquerdo").value) ||
          0;
        const deslocamentoDireito =
          parseFloat(document.getElementById("deslocamento-direito").value) ||
          0;

        // Calcular soma dos deslocamentos
        const somaDeslocamentos = deslocamentoEsquerdo + deslocamentoDireito;

        // Verificar se a soma excede a largura total
        if (somaDeslocamentos >= larguraTotal) {
          // Destacar campos com problema
          document.getElementById("largura").classList.add("error");
          document
            .getElementById("deslocamento-esquerdo")
            .classList.add("error");
          document
            .getElementById("deslocamento-direito")
            .classList.add("error");

          // Mostrar mensagem de erro
          alert(
            `A soma do deslocamento esquerdo (${deslocamentoEsquerdo.toFixed(
              2
            )}m) e do deslocamento direito (${deslocamentoDireito.toFixed(
              2
            )}m) deve ser menor que a largura total (${larguraTotal.toFixed(
              2
            )}m).`
          );
          return false;
        }

        // Remover destaque de erro se estiver tudo certo
        document.getElementById("largura").classList.remove("error");
        document
          .getElementById("deslocamento-esquerdo")
          .classList.remove("error");
        document
          .getElementById("deslocamento-direito")
          .classList.remove("error");
        return true;
      }





      function showExportLoteModal() {
        try {
          if (!db) {
            alert("Banco de dados não está disponível.");
            return;
          }

          // Limpar e preencher o select com os lotes disponíveis
          const loteSelect = document.getElementById("export-lote-select");
          loteSelect.innerHTML =
            '<option value="">Carregando lotes...</option>';

          const transaction = db.transaction(["obras"], "readonly");
          const objectStore = transaction.objectStore("obras");
          const index = objectStore.index("LOTE");
          const request = index.openCursor(null, "nextunique");

          const lotes = new Set();

          request.onsuccess = function (event) {
            const cursor = event.target.result;

            if (cursor) {
              // Adicionar lote ao conjunto se existir
              if (cursor.key) {
                lotes.add(cursor.key);
              }
              cursor.continue();
            } else {
              // Todos os lotes foram coletados, preencher o select
              loteSelect.innerHTML = "";

              if (lotes.size === 0) {
                loteSelect.innerHTML =
                  '<option value="">Nenhum lote encontrado</option>';
              } else {
                // Ordenar os lotes
                const lotesOrdenados = Array.from(lotes).sort();

                // Adicionar opção para cada lote
                lotesOrdenados.forEach((lote) => {
                  const option = document.createElement("option");
                  option.value = lote;
                  option.textContent = lote;
                  loteSelect.appendChild(option);
                });
              }
            }
          };

          request.onerror = function (event) {
            console.error("Erro ao carregar lotes:", event.target.error);
            loteSelect.innerHTML =
              '<option value="">Erro ao carregar lotes</option>';
          };

          // Mostrar o modal
          document.getElementById("export-lote-modal").style.display = "block";
        } catch (error) {
          console.error("Erro ao exibir modal de exportação por lote:", error);
          alert(
            "Erro ao exibir modal de exportação por lote: " + error.message
          );
        }
      }

      function closeExportLoteModal() {
        document.getElementById("export-lote-modal").style.display = "none";
      }


      // Função para importar CSV de pontes para o IndexedDB
      function importPontesCSV() {
        try {
          // Criar um input de arquivo oculto
          const fileInput = document.createElement("input");
          fileInput.type = "file";
          fileInput.accept = ".csv";
          fileInput.style.display = "none";
          document.body.appendChild(fileInput);

          fileInput.addEventListener("change", function () {
            if (this.files && this.files[0]) {
              const file = this.files[0];
              const reader = new FileReader();

              reader.onload = function (event) {
                const csvData = event.target.result;
                processPontesCSV(csvData);
              };

              reader.onerror = function () {
                alert("Erro ao ler o arquivo.");
              };

              reader.readAsText(file);
            }

            // Remover o input após uso
            document.body.removeChild(fileInput);
          });

          // Acionar o clique para abrir o seletor de arquivos
          fileInput.click();
        } catch (error) {
          console.error("Erro ao importar CSV de pontes:", error);
          alert("Erro ao importar CSV de pontes: " + error.message);
        }
      }

      // Função para processar o conteúdo do CSV de pontes
      function processPontesCSV(csvData) {
        try {
          // Dividir as linhas do CSV
          const lines = csvData.split("\n");
          if (lines.length < 2) {
            alert("O arquivo CSV não contém dados válidos.");
            return;
          }

          // Detectar o separador
          const headerLine = lines[0];
          let separator = ",";
          if (headerLine.includes(";")) separator = ";";
          if (headerLine.includes("\t")) separator = "\t";

          // Obter os cabeçalhos
          const headers = headerLine
            .split(separator)
            .map((header) => header.trim());

          // Array para armazenar as pontes
          const pontes = [];

          // Processar cada linha de dados
          for (let i = 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue; // Pular linhas vazias

            // Processar linha respeitando aspas
            const values = parseCSVLine(line, separator);

            if (values.length < 5) continue; // Ignorar linhas muito curtas

            // Mapear cabeçalhos para índices
            const headerMap = {};
            headers.forEach((header, index) => {
              const normalizedHeader = header
                .toLowerCase()
                .replace(/[\s"']/g, "");
              headerMap[normalizedHeader] = index;
            });

            // Extrair dados com base nos índices
            const ponte = {
              Id: values[headerMap["id"] || 0] || "",
              CodigoSgo:
                values[headerMap["codigosgo"] || headerMap["códigosgo"] || 1] ||
                "",
              Identificacao:
                values[
                  headerMap["identificacao"] || headerMap["identificação"] || 2
                ] || "",
              Municipio:
                values[headerMap["municipio"] || headerMap["município"] || 3] ||
                "",
              Uf: values[headerMap["uf"] || 4] || "",
              Br: values[headerMap["rodovia"] || 6] || "",
              Km:
                parseFloat(
                  (values[headerMap["km"] || 7] || "0")
                    .toString()
                    .replace(",", ".")
                ) || 0,
              Comprimento:
                parseFloat(
                  (values[headerMap["comprimento"] || 9] || "0")
                    .toString()
                    .replace(",", ".")
                ) || 0,
              Largura:
                parseFloat(
                  (values[headerMap["largura"] || 10] || "0")
                    .toString()
                    .replace(",", ".")
                ) || 0,
              AnoConstrucao: values[headerMap["ano"] || 11] || "",
              Latitude:
                parseFloat(
                  (values[headerMap["latitude"] || 12] || "0")
                    .toString()
                    .replace(",", ".")
                ) || 0,
              Longitude:
                parseFloat(
                  (values[headerMap["longitude"] || 13] || "0")
                    .toString()
                    .replace(",", ".")
                ) || 0,
            };

            // Verificar se o objeto tem dados mínimos
            if (ponte.Id && ponte.CodigoSgo) {
              pontes.push(ponte);
            }
          }

          if (pontes.length > 0) {
            // Salvar as pontes no banco de dados
            savePontesReference(pontes);
            alert(
              `Importação concluída: ${pontes.length} pontes de referência importadas.`
            );
          } else {
            alert("Nenhuma ponte válida encontrada no arquivo CSV.");
          }
        } catch (error) {
          console.error("Erro ao processar arquivo CSV de pontes:", error);
          alert("Erro ao processar arquivo CSV de pontes: " + error.message);
        }
      }

      // Versão: 1.5
      // Função corrigida para verificar existência de elementos

      function validateAlaWithEncountro() {
        // Obter o valor do campo encontro
        const encontroField = document.getElementById("tipo-encontro");
        if (!encontroField) return true; // Se o campo não existir, não validar

        const encontroValue = encontroField.value;

        // Obter os campos de ala
        const alaParalelaField = document.getElementById("tipo-ala-paralela");
        const alaPerpendicularField =
          document.getElementById("tipo-ala-perpendicular");

        // Se algum dos campos não existir, não validar
        if (!alaParalelaField || !alaPerpendicularField) return true;

        // Obter os elementos de erro
        const alaParalelaError = document.getElementById("tipo-ala-paralela-error");
        const alaPerpendicularError = document.getElementById(
          "tipo-ala-perpendicular-error"
        );

        // Inicialmente remover classes de erro
        alaParalelaField.classList.remove("error");
        alaPerpendicularField.classList.remove("error");

        if (alaParalelaError) alaParalelaError.classList.remove("visible");
        if (alaPerpendicularError)
          alaPerpendicularError.classList.remove("visible");

        // Se o encontro for PAREDE FRONTAL PORTANTE, pelo menos uma ala deve estar selecionada
        if (encontroValue === "ENCONTRO - PAREDE FRONTAL PORTANTE") {
          const alaParalelaValue = alaParalelaField.value || "";
          const alaPerpendicularValue = alaPerpendicularField.value || "";

          const temAlaParalela =
            alaParalelaValue && alaParalelaValue !== "Nenhum";
          const temAlaPerpendicular =
            alaPerpendicularValue && alaPerpendicularValue !== "Nenhum";

          if (!temAlaParalela && !temAlaPerpendicular) {
            // Se não tiver nenhuma ala selecionada, mostrar erro
            alaParalelaField.classList.add("error");
            alaPerpendicularField.classList.add("error");

            if (alaParalelaError) alaParalelaError.classList.add("visible");
            if (alaPerpendicularError)
              alaPerpendicularError.classList.add("visible");

            return false;
          }
        }

        return true;
      }

      // Função para verificar se um elemento existe antes de usar
      function safeElement(id, callback) {
        const element = document.getElementById(id);
        if (element && typeof callback === "function") {
          callback(element);
          return true;
        }
        return false;
      }

      // Versão: 2.0
      // Função robusta para fixar o sistema de validação

      function fixRequiredFieldsValidation() {
        console.log(
          "Aplicando correções para validação de campos de forma segura..."
        );

        try {
          // Garantir que o objeto requiredFields exista
          if (typeof requiredFields === "undefined" || !requiredFields) {
            console.warn("Objeto requiredFields não encontrado, criando...");
            checkAndCreateRequiredFields();
          }

          // Para cada campo obrigatório, verificar se o elemento existe antes de tentar adicionar eventos
          if (typeof requiredFields !== "undefined") {
            for (const fieldId in requiredFields) {
              try {
                const field = document.getElementById(fieldId);
                if (field) {
                  field.addEventListener("input", function () {
                    try {
                      // Remover classe de erro ao digitar
                      field.classList.remove("error");

                      // Remover mensagem de erro
                      const errorElement = document.getElementById(
                        `${fieldId}-error`
                      );
                      if (errorElement) {
                        errorElement.classList.remove("visible");
                      }
                    } catch (innerError) {
                      console.warn(
                        `Erro ao processar evento input para ${fieldId}:`,
                        innerError
                      );
                    }
                  });
                } else {
                  console.warn(`Campo ${fieldId} não encontrado no DOM`);
                }
              } catch (fieldError) {
                console.warn(`Erro ao processar campo ${fieldId}:`, fieldError);
              }
            }
          }

          // Lista segura de campos a serem validados para proteção lateral
          const lateralProtectionFields = [
            "tipo-barreira-esquerda",
            "tipo-barreira-direita",
            "guarda-rodas-esquerdo",
            "guarda-rodas-direito",
            "tipo-calcada-esquerda",
            "tipo-calcada-direita",
          ];

          // Adicionar eventos apenas para elementos que existem
          for (const fieldId of lateralProtectionFields) {
            try {
              const field = document.getElementById(fieldId);
              if (field) {
                field.addEventListener("change", function () {
                  try {
                    validateLateralProtection();
                  } catch (validationError) {
                    console.warn(
                      `Erro ao validar proteção lateral para ${fieldId}:`,
                      validationError
                    );
                  }
                });
              } else {
                console.warn(
                  `Campo de proteção lateral ${fieldId} não encontrado no DOM`
                );
              }
            } catch (fieldError) {
              console.warn(
                `Erro ao processar campo de proteção lateral ${fieldId}:`,
                fieldError
              );
            }
          }

          // Campos relacionados ao encontro e alas
          const relatedFields = {
            "tipo-encontro": validateAlaWithEncountro,
            "tipo-ala-paralela": validateAlaWithEncountro,
            "tipo-ala-perpendicular": validateAlaWithEncountro,
          };

          // Adicionar event listeners apenas para elementos que existem
          for (const [fieldId, validator] of Object.entries(relatedFields)) {
            try {
              const field = document.getElementById(fieldId);
              if (field) {
                if (typeof validator === "function") {
                  field.addEventListener("change", validator);
                } else {
                  console.warn(`Validador para ${fieldId} não é uma função`);
                }
              } else {
                console.warn(`Campo ${fieldId} não encontrado no DOM`);
              }
            } catch (fieldError) {
              console.warn(`Erro ao processar campo ${fieldId}:`, fieldError);
            }
          }

          console.log(
            "Correções para validação de campos aplicadas com sucesso!"
          );
        } catch (error) {
          console.error(
            "Erro ao aplicar correções para validação de campos:",
            error
          );
        }
      }

      // Função para inicializar o formulário de forma segura
      function safeInit() {
        try {
          console.log("Inicializando sistemas de forma segura...");

          // Verificar se o sistema de abas está ativo
          if (typeof initTabSystem === "function") {
            initTabSystem();
          } else {
            console.warn("Função initTabSystem não encontrada");
          }

          // Aplicar correções para validação com um pequeno atraso
          setTimeout(function () {
            fixRequiredFieldsValidation();

            // Verificar o estado inicial da aba de configuração de forma segura
            try {
              const configTab = document.querySelector(
                '.tab[data-tab="configuracao"]'
              );
              if (
                configTab &&
                configTab.classList.contains("active") &&
                typeof initConfiguracao === "function"
              ) {
                initConfiguracao();
              }
            } catch (tabError) {
              console.warn(
                "Erro ao verificar estado inicial da aba:",
                tabError
              );
            }
          }, 500);
        } catch (error) {
          console.error("Erro na inicialização segura:", error);
        }
      }

      // Registrar eventos de inicialização de forma segura
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", safeInit);
      } else {
        // Documento já carregou, inicializar com um pequeno atraso
        setTimeout(safeInit, 100);
      }

      // Sobrescrever a função global para garantir a compatibilidade
      window.fixRequiredFieldsValidation = fixRequiredFieldsValidation;

      // Inicializar quando o documento estiver pronto
      document.addEventListener("DOMContentLoaded", function () {
        console.log("DOM carregado, inicializando sistemas...");

        // Inicializar sistema de abas
        initTabSystem();

        // Aguardar um pequeno tempo para garantir que todos os elementos foram criados
        setTimeout(function () {
          // Aplicar correções para validação
          fixRequiredFieldsValidation();

          // Verificar o estado inicial da aba de configuração
          const configTab = document.querySelector(
            '.tab[data-tab="configuracao"]'
          );
          if (configTab && configTab.classList.contains("active")) {
            initConfiguracao();
          }
        }, 500);
      });

      // Se o documento já estiver pronto, inicializar com delay
      if (document.readyState !== "loading") {
        console.log("Documento já carregado, inicializando com delay...");
        setTimeout(function () {
          fixRequiredFieldsValidation();
        }, 500);
      }

      // Iniciar a correção quando o documento estiver pronto
      document.addEventListener("DOMContentLoaded", function () {
        initTabSystem();
        fixRequiredFieldsValidation();

        // Verificar o estado inicial
        if (
          document
            .querySelector('.tab[data-tab="configuracao"]')
            .classList.contains("active")
        ) {
          initConfiguracao();
        }
      });

      // Se o documento já estiver pronto, aplicar as correções imediatamente
      if (document.readyState !== "loading") {
        fixRequiredFieldsValidation();
      }



      // Versão: 3.1
// Função para obter colunas padrão para exportação CSV com CODIGO como segunda coluna
// Atualização: Campo "VIGA LIGACAO FUNDACOES" renomeado para "TIPO LIGAÇÃO FUNDAÇÕES"
function getCsvColumns() {
    // Array com todas as colunas padrão em ordem lógica por seção
    return [
        // Informações Gerais - CODIGO movido para segunda posição
        "MODELADO",
        "CODIGO",  // Agora como segunda coluna
        "NOME",
        "LOTE",
        "GPS",
        "FOTOS SUPERIORES",
        "FOTOS INFERIORES",
        "UF",
        "RODOVIA",
        "KM",
        "DATA",
        "ENGENHEIRO",
        "TECNICO",
        "LATITUDE",
        "LONGITUDE",

        // Configurações Gerais
        "COMPRIMENTO",
        "LARGURA",
        "ALTURA",
        "QTD TRAMOS",
        "COMPRIMENTO TRAMOS",

        // Elementos de Transição
        "CORTINA ALTURA",
        "TIPO ALA PARALELA",
        "TIPO ALA PERPENDICULAR",
        "COMPRIMENTO ALA",
        "ESPESSURA ALA",
        "TIPO ENCONTRO",
        "DESLOCAMENTO ESQUERDO ENCONTRO LAJE",
        "DESLOCAMENTO DIREITO ENCONTRO LAJE",
        "COMPRIMENTO ENCONTRO LAJE",
        "LAJE TRANSICAO",

        // Elementos de Superestrutura
        "ALTURA LONGARINA",
        "DESLOCAMENTO ESQUERDO",
        "DESLOCAMENTO DIREITO",
        "QTD LONGARINAS",
        "QTD TRANSVERSINAS",
        "ESPESSURA LONGARINA",
        "ESPESSURA TRANSVERSINA",
        "ESPESSURA LAJE",

        // Elementos de Apoio
        "QTD PILARES",
        "PILAR DESCENTRALIZADO",
        "LARGURA PILAR",
        "COMPRIMENTO PILARES",
        "ALTURA APOIO",
        "TIPO APARELHO APOIO",
        "TIPO TRAVESSA",
        "ALTURA TRAVESSA",
        "TIPO ENCAMISAMENTO",
        "TIPO BLOCO SAPATA",
        "ALTURA BLOCO SAPATA",
        "LARGURA BLOCO SAPATA",
        "TIPO CONTRAVENTAMENTO PILAR",
        "TIPO LIGACAO FUNDACOES",

        // Elementos Complementares
        "TIPO BARREIRA ESQUERDA",
        "LARGURA BARREIRA ESQUERDA",
        "TIPO BARREIRA DIREITA",
        "LARGURA BARREIRA DIREITA",
        "TIPO CALCADA ESQUERDA",
        "LARGURA CALCADA ESQUERDA",
        "TIPO CALCADA DIREITA",
        "LARGURA CALCADA DIREITA",
        "GUARDA RODAS ESQUERDO",
        "LARGURA GUARDA RODAS ESQUERDO",
        "GUARDA RODAS DIREITO",
        "LARGURA GUARDA RODAS DIREITO",
        "TIPO PAVIMENTO",
        "QTD BUZINOTES",
    ];
}



// Substituir a função global
window.getCsvColumns = getCsvColumns;





// Versão: 3.0
// Função atualizada para exportar CSV com CODIGO como texto preservando zeros à esquerda
function exportToCSV() {
    try {
        // Validar primeiro
        const { isValid, missingFields } = validateForm();
        if (!isValid) {
            alert("Por favor, preencha todos os campos obrigatórios antes de exportar para CSV.");
            return;
        }

        // Validar dimensões
        if (!validateTramosLength() || !validateHeights() || !validateDisplacements()) {
            return; // Interrompe a execução se qualquer validação falhar
        }
        const form = document.getElementById("oae-form");
        const formData = new FormData(form);

        // Obter colunas definidas
        const csvColumns = getCsvColumns();

        // Coletar campos personalizados
        document.querySelectorAll(".custom-field").forEach((field) => {
            const name = field.getAttribute("name");
            if (!csvColumns.includes(name)) {
                csvColumns.push(name);
            }
        });

        // Coletar todos os campos padrão
        const data = {};
        // Inicializar com valores vazios
        csvColumns.forEach((column) => {
            data[column] = "";
        });

        for (let [key, value] of formData.entries()) {
            // Ignorar campos dos tramos/apoios dinâmicos (eles são tratados separadamente)
            if (!key.startsWith("tramo-") && !key.startsWith("apoio-")) {
                data[key] = value;
            }
        }

        // Checkbox - verificar se está marcado
        if (document.getElementById("modelado").checked) {
            data["MODELADO"] = "TRUE";
        } else {
            data["MODELADO"] = "FALSE";
        }

        // Coletar valores dos tramos
        const tramosValues = [];
        const tramosFields = document.querySelectorAll(".tramo-field");
        tramosFields.forEach((field) => {
            tramosValues.push(field.value || "0.50");
        });
        data["COMPRIMENTO TRAMOS"] = tramosValues.join(";");

        // Coletar valores dos apoios
        const apoiosValues = [];
        const apoiosFields = document.querySelectorAll(".apoio-field");
        apoiosFields.forEach((field) => {
            apoiosValues.push(field.value || "0.00");
        });
        data["ALTURA APOIO"] = apoiosValues.join(";");

        // Construir cabeçalhos e linha de dados
        const csvContent = csvColumns.join(",") + "\n" + csvColumns.map((column) => {
            // Valores com vírgula devem ser envolvidos em aspas duplas
            const value = data[column] || "";
            
            // Tratamento especial para CODIGO - sempre como texto com aspas para preservar zeros à esquerda
            if (column === "CODIGO") {
                return `"${value}"`; // Sempre colocar entre aspas para garantir tratamento como texto
            }
            
            // Para outros campos, só coloca aspas se tiver vírgulas
            return value && value.includes(",") ? `"${value}"` : value;
        }).join(",");

        // Criar e baixar o arquivo CSV
        const blob = new Blob([csvContent], {
            type: "text/csv;charset=utf-8;",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.setAttribute("href", url);
        link.setAttribute("download", `OAE_${data["CODIGO"] || "nova"}_${new Date().toISOString().split("T")[0]}.csv`);
        link.style.display = "none";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    } catch (error) {
        console.error("Erro ao exportar CSV:", error);
        alert("Erro ao exportar CSV: " + error.message);
    }
}

// Substituir a função global
window.exportToCSV = exportToCSV;



// Versão: 3.0
// Função atualizada para exportar todas as obras com CODIGO tratado como texto
function exportAllWorks() {
    try {
        if (!db) {
            alert("Banco de dados não está disponível.");
            return;
        }

        const transaction = db.transaction(["obras"], "readonly");
        const objectStore = transaction.objectStore("obras");
        const request = objectStore.getAll();

        request.onsuccess = function (event) {
            const works = event.target.result;

            if (works.length === 0) {
                alert("Não há obras para exportar.");
                return;
            }

            // Obter colunas definidas
            const csvColumns = getCsvColumns();

            // Verificar campos personalizados em todas as obras
            works.forEach((work) => {
                Object.keys(work).forEach((field) => {
                    if (!csvColumns.includes(field)) {
                        csvColumns.push(field);
                    }
                });
            });

            // Inicializar o conteúdo CSV com os cabeçalhos
            let csvContent = csvColumns.join("\t") + "\n";

            works.forEach((work) => {
                const row = csvColumns.map((column) => {
                    const value = work[column] || "";
                    
                    // Tratamento especial para CODIGO - sempre como texto para preservar zeros à esquerda
                    if (column === "CODIGO") {
                        // Usar aspas duplas para garantir que seja tratado como texto
                        return `"${value}"`;
                    }
                    
                    // Valores com tabs devem ser envolvidos em aspas duplas
                    return value && value.includes("\t") ? `"${value}"` : value;
                });

                csvContent += row.join("\t") + "\n";
            });

            // Criar e baixar o arquivo CSV
            const blob = new Blob([csvContent], {
                type: "text/csv;charset=utf-8;",
            });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.setAttribute("href", url);
            link.setAttribute("download", `Todas_OAEs_${new Date().toISOString().split("T")[0]}.csv`);
            link.style.display = "none";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        };

        request.onerror = function (event) {
            console.error("Erro ao exportar obras:", event.target.error);
            alert(`Erro ao exportar obras: ${event.target.error}`);
        };
    } catch (error) {
        console.error("Erro ao exportar todas as obras:", error);
        alert("Erro ao exportar todas as obras: " + error.message);
    }
}

// Substituir a função global
window.exportAllWorks = exportAllWorks;


// Versão: 3.1
// Função atualizada para exportar obras por lote com CODIGO e LOTE tratados como texto, e normalização de decimais
function exportLoteWorks() {
    try {
        const loteSelect = document.getElementById("export-lote-select");
        const lote = loteSelect.value;

        if (!lote) {
            alert("Por favor, selecione um lote para exportar.");
            return;
        }

        if (!db) {
            alert("Banco de dados não está disponível.");
            return;
        }

        const transaction = db.transaction(["obras"], "readonly");
        const objectStore = transaction.objectStore("obras");
        const index = objectStore.index("LOTE");
        const request = index.getAll(lote);

        request.onsuccess = function (event) {
            const works = event.target.result;

            if (works.length === 0) {
                alert(`Não há obras no lote "${lote}" para exportar.`);
                return;
            }

            // Obter colunas definidas
            const csvColumns = getCsvColumns();

            // Verificar campos personalizados em todas as obras
            works.forEach((work) => {
                Object.keys(work).forEach((field) => {
                    if (!csvColumns.includes(field)) {
                        csvColumns.push(field);
                    }
                });
            });

            // Construir o conteúdo do CSV (usando TAB como separador)
            let csvContent = csvColumns.join("\t") + "\n";

            works.forEach((work) => {
                const row = csvColumns.map((column) => {
                    let value = work[column] || "";
                    
                    // Tratamento especial para CODIGO e LOTE - sempre como texto para preservar zeros à esquerda
                    if (column === "CODIGO" || column === "LOTE") {
                        return `"${value}"`;
                    }
                    
                    // Aplicar normalização em campos numéricos/medidas
                    const camposNumericos = [
                        "COMPRIMENTO",
                        "LARGURA",
                        "ALTURA",
                        "DESLOCAMENTO",
                        "KM_INICIAL",
                        "KM_FINAL"
                    ];
                    
                    if (camposNumericos.includes(column)) {
                        value = normalizeDecimal(value);
                    }
                    
                    // Aplicar normalização em campos que contêm múltiplos valores separados por ";"
                    const camposMultiplos = [
                        "COMPRIMENTO TRAMOS",
                        "ALTURA APOIO",
                        "LARGURA PILAR",
                        "COMPRIMENTO PILARES"
                    ];
                    
                    if (camposMultiplos.includes(column) && value) {
                        // Dividir, normalizar cada valor e juntar novamente
                        const valoresNormalizados = value.split(";").map(v => normalizeDecimal(v.trim()));
                        value = valoresNormalizados.join(";");
                    }
                    
                    // Valores com tabs devem ser envolvidos em aspas duplas
                    return value && value.includes("\t") ? `"${value}"` : value;
                });

                csvContent += row.join("\t") + "\n";
            });

            // Criar e baixar o arquivo CSV
            const blob = new Blob([csvContent], {
                type: "text/csv;charset=utf-8;",
            });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.setAttribute("href", url);
            link.setAttribute("download", `OAEs_Lote_${lote.replace(/[^a-zA-Z0-9]/g, "_")}_${new Date().toISOString().split("T")[0]}.csv`);
            link.style.display = "none";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            // Fechar o modal após exportação
            closeExportLoteModal();
        };

        request.onerror = function (event) {
            console.error(`Erro ao exportar obras do lote "${lote}":`, event.target.error);
            alert(`Erro ao exportar obras do lote "${lote}": ${event.target.error}`);
        };
    } catch (error) {
        console.error("Erro ao exportar obras por lote:", error);
        alert("Erro ao exportar obras por lote: " + error.message);
    }
}



// Substituir a função global
window.exportLoteWorks = exportLoteWorks;




// Versão: 4.5
// Função atualizada para gerar linha CSV com LOTE e CODIGO como texto, e normalização de decimais
function generateAndShowCSVLine() {
    try {
        // Validar primeiro
        const { isValid, missingFields } = validateForm();
        if (!isValid) {
            alert("Por favor, preencha todos os campos obrigatórios antes de gerar a linha CSV.");
            return;
        }

        // Validar dimensões
        if (!validateTramosLength() || !validateHeights() || !validateDisplacements()) {
            return; // Interrompe a execução se qualquer validação falhar
        }

        const form = document.getElementById("oae-form");
        const formData = new FormData(form);

        // Obter colunas definidas
        const csvColumns = getCsvColumns();

        // Coletar campos personalizados
        document.querySelectorAll(".custom-field").forEach((field) => {
            const name = field.getAttribute("name");
            if (!csvColumns.includes(name)) {
                csvColumns.push(name);
            }
        });

        // Dados para a linha CSV
        const data = {};

        // Preencher com valores vazios para garantir que todos os campos existam
        csvColumns.forEach((column) => {
            data[column] = "";
        });

        // Preencher com os valores do formulário
        for (let [key, value] of formData.entries()) {
            // Ignorar campos dos tramos/apoios dinâmicos (eles são tratados separadamente)
            if (!key.startsWith("tramo-") && !key.startsWith("apoio-")) {
                // Aplicar normalização em campos numéricos/medidas
                const camposNumericos = [
                    "COMPRIMENTO",
                    "LARGURA",
                    "ALTURA",
                    "DESLOCAMENTO",
                    "KM_INICIAL",
                    "KM_FINAL"
                ];
                
                if (camposNumericos.includes(key.toUpperCase())) {
                    data[key] = normalizeDecimal(value);
                } else {
                    data[key] = value;
                }
            }
        }

        // Checkbox - verificar se está marcado
        if (document.getElementById("modelado").checked) {
            data["MODELADO"] = "TRUE";
        } else {
            data["MODELADO"] = "FALSE";
        }

        // Coletar valores dos tramos COM normalização
        const tramosValues = [];
        const tramosFields = document.querySelectorAll(".tramo-field");
        tramosFields.forEach((field) => {
            const normalizedValue = normalizeDecimal(field.value || "0.50");
            tramosValues.push(normalizedValue);
        });
        data["COMPRIMENTO TRAMOS"] = tramosValues.join(";");

        // Coletar valores dos apoios COM normalização
        const alturas = [];
        const larguras = [];
        const comprimentos = [];

        document.querySelectorAll(".apoio-altura-field").forEach(f => {
            alturas.push(normalizeDecimal(f.value || "0.00"));
        });
        
        document.querySelectorAll(".apoio-larg-field").forEach(f => {
            larguras.push(normalizeDecimal(f.value || "0.00"));
        });
        
        document.querySelectorAll(".apoio-comp-field").forEach(f => {
            comprimentos.push(normalizeDecimal(f.value || "0.00"));
        });

        data["ALTURA APOIO"] = alturas.join(";");
        data["LARGURA PILAR"] = larguras.join(";");
        data["COMPRIMENTO PILARES"] = comprimentos.join(";");

        // Gerar a linha CSV
        const csvLine = csvColumns.map((column) => {
            // Tratamento especial para CODIGO e LOTE para preservar como texto (zeros à esquerda)
            if (column === "CODIGO" || column === "LOTE") {
                return `"${data[column] || ""}"`;
            }
            
            // Para os demais campos, manter o comportamento original
            return data[column] || "";
        }).join("\t");

        // Mostrar a linha para copiar
        const csvLineElement = document.getElementById("csv-line");
        csvLineElement.style.display = "block";
        csvLineElement.textContent = csvLine;

        // Selecionar o texto para facilitar a cópia
        const range = document.createRange();
        range.selectNode(csvLineElement);
        window.getSelection().removeAllRanges();
        window.getSelection().addRange(range);

        try {
            // Copiar para o clipboard
            document.execCommand("copy");
            window.getSelection().removeAllRanges();
            alert("Linha copiada para a área de transferência!");
        } catch (err) {
            console.error("Não foi possível copiar automaticamente:", err);
            alert("Selecione o texto e use Ctrl+C para copiar.");
        }
    } catch (error) {
        console.error("Erro ao gerar linha CSV:", error);
        alert("Erro ao gerar linha CSV: " + error.message);
    }
}



// Substituir a função global
window.generateAndShowCSVLine = generateAndShowCSVLine;








// Versão: 5.0
// Função para validar que todos os tramos estejam preenchidos e a soma seja igual ao comprimento total
function validateTramosSum() {
  const comprimentoTotal = parseFloat(document.getElementById("comprimento").value) || 0;
  const qtdTramos = parseInt(document.getElementById("qtd-tramos").value) || 1;
  const tramosFields = document.querySelectorAll(".tramo-field");
  
  // Se não houver comprimento total definido, não validar ainda
  if (comprimentoTotal === 0) {
    return true;
  }
  
  // Se não houver tramos, não validar
  if (tramosFields.length === 0) {
    return true;
  }
  
  const errorElement = document.getElementById("tramos-sum-error");
  let valid = true;
  const tramosVazios = [];
  
  // Verificar se todos os tramos estão preenchidos
  tramosFields.forEach((field, index) => {
    const valor = parseFloat(field.value) || 0;
    
    // Remover marcação de erro primeiro
    field.classList.remove("error");
    
    // Se houver mais de 1 tramo, TODOS devem estar preenchidos
    if (qtdTramos > 1 && valor === 0) {
      field.classList.add("error");
      tramosVazios.push(`Tramo ${index + 1}`);
      valid = false;
    }
  });
  
  // Se houver tramos vazios, mostrar erro específico
  if (tramosVazios.length > 0) {
    if (errorElement) {
      errorElement.textContent = `ERRO: Os seguintes tramos precisam ser preenchidos: ${tramosVazios.join(", ")}`;
      errorElement.style.display = "block";
    }
    document.getElementById("comprimento").classList.remove("error");
    return false;
  }
  
  // Calcular a soma dos tramos
  let somaTramos = 0;
  tramosFields.forEach((field) => {
    const valor = parseFloat(field.value) || 0;
    somaTramos += valor;
  });
  
  // Arredondar para 2 casas decimais para evitar problemas de precisão
  somaTramos = Math.round(somaTramos * 100) / 100;
  const comprimentoArredondado = Math.round(comprimentoTotal * 100) / 100;
  
  // Verificar se a soma é exatamente igual ao comprimento
  if (somaTramos !== comprimentoArredondado) {
    const diferenca = Math.abs(comprimentoArredondado - somaTramos).toFixed(2);
    
    if (errorElement) {
      errorElement.textContent = `ERRO: A soma dos tramos (${somaTramos.toFixed(2)}m) deve ser igual ao comprimento total (${comprimentoArredondado.toFixed(2)}m). Diferença: ${diferenca}m`;
      errorElement.style.display = "block";
    }
    
    // Destacar campos com erro
    tramosFields.forEach(field => field.classList.add("error"));
    document.getElementById("comprimento").classList.add("error");
    
    return false;
  } else {
    // Remover erro se estiver correto
    if (errorElement) {
      errorElement.style.display = "none";
    }
    
    tramosFields.forEach(field => field.classList.remove("error"));
    document.getElementById("comprimento").classList.remove("error");
    
    return true;
  }
}




// Versão: 1.0
/**
 * Normaliza valores decimais adicionando zero à esquerda quando necessário
 * @param {string|number} value - Valor a ser normalizado
 * @returns {string} - Valor normalizado
 * Exemplos:
 * ".5" → "0.5"
 * ".25" → "0.25"
 * "5" → "5"
 * "" → ""
 * null → ""
 */
function normalizeDecimal(value) {
    // Se valor for nulo, undefined ou string vazia, retorna vazio
    if (value === null || value === undefined || value === "") {
        return "";
    }
    
    // Converter para string se for número
    const stringValue = String(value).trim();
    
    // Se começar com ponto, adicionar zero à esquerda
    if (stringValue.startsWith(".")) {
        return "0" + stringValue;
    }
    
    return stringValue;
}




// Versão: 4.1

/**
 * Exporta todas as obras do IndexedDB para um arquivo JSON com estrutura hierárquica BridgeData
 * Cada obra é convertida para o formato completo com BridgeProjectData, GeneralConfigData, etc.
 */
function exportToJSON() {
    // Abrir com a versão atual do banco (não especificar versão força usar a existente)
    const request = indexedDB.open("OAEDatabase");
    
    request.onerror = function() {
        console.error("Erro ao abrir IndexedDB:", request.error);
        alert("❌ Erro ao acessar o banco de dados: " + request.error);
    };
    
    request.onsuccess = function(event) {
        const db = event.target.result;
        
        console.log(`IndexedDB aberto com sucesso. Versão: ${db.version}`);
        
        if (!db.objectStoreNames.contains("obras")) {
            alert("❌ Tabela 'obras' não encontrada no banco de dados!");
            db.close();
            return;
        }
        
        const transaction = db.transaction(["obras"], "readonly");
        const objectStore = transaction.objectStore("obras");
        const getAllRequest = objectStore.getAll();
        
        getAllRequest.onsuccess = function() {
            const obrasFlat = getAllRequest.result;
            
            if (!obrasFlat || obrasFlat.length === 0) {
                alert("Nenhuma obra encontrada para exportar!");
                db.close();
                return;
            }
            
            try {
                const bridges = [];
                let errorsCount = 0;
                
                // Converte cada obra flat para estrutura hierárquica BridgeData
                // Converte cada obra flat para estrutura hierárquica BridgeData
for (const obraFlat of obrasFlat) {
    try {
        const bridgeData = convertObraFlatToBridgeData(obraFlat);
        bridges.push(bridgeData);
                    } catch (conversionError) {
                        errorsCount++;
                        console.error(`Erro ao converter obra ${obraFlat.CODIGO}:`, conversionError);
                        // Continua processando outras obras
                    }
                }
                
                if (bridges.length === 0) {
                    alert("❌ Nenhuma obra pôde ser convertida para o formato JSON!");
                    db.close();
                    return;
                }
                
                // Monta o JSON final com metadata
                const exportData = {
                    ExportDate: new Date().toISOString(),
                    ExportVersion: "1.0",
                    ExportSource: "OAEDatabase - IndexedDB",
                    TotalBridges: bridges.length,
                    ErrorsCount: errorsCount,
                    Bridges: bridges
                };
                
                // Gera o JSON formatado
                const jsonString = JSON.stringify(exportData, null, 2);
                
                // Cria o blob e faz download
                const blob = new Blob([jsonString], { type: "application/json;charset=utf-8;" });
                const url = URL.createObjectURL(blob);
                const link = document.createElement("a");
                
                // Nome do arquivo com timestamp
                const timestamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, -5);
                link.href = url;
                link.download = `bridges_export_${timestamp}.json`;
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Libera o objeto URL
                URL.revokeObjectURL(url);
                
                let message = `✅ ${bridges.length} obra(s) exportada(s) com sucesso para JSON hierárquico!`;
                if (errorsCount > 0) {
                    message += `\n\n⚠️ ${errorsCount} obra(s) com erro(s) na conversão (verifique o console).`;
                }
                alert(message);
                
            } catch (error) {
                console.error("Erro ao gerar JSON:", error);
                alert("❌ Erro ao gerar JSON: " + error.message);
            }
            
            db.close();
        };
        
        getAllRequest.onerror = function() {
            console.error("Erro ao buscar obras:", getAllRequest.error);
            alert("❌ Erro ao buscar obras do banco de dados!");
            db.close();
        };
    };
    
    request.onupgradeneeded = function(event) {
        // Este evento não deve ser disparado, mas caso seja, apenas ignora
        console.warn("onupgradeneeded disparado inesperadamente durante exportação");
    };
}

// Expor função globalmente
window.exportToJSON = exportToJSON;
// Versão: 1.0

/**
 * Converte uma obra flat do IndexedDB para estrutura hierárquica BridgeData
 * @param {object} obra - Objeto flat com campos do IndexedDB (CODIGO, LOTE, etc.)
 * @returns {object} Objeto BridgeData com hierarquia completa
 */
function convertObraFlatToBridgeData(obra) {
    if (!obra) {
        throw new Error("Obra não pode ser nula");
    }

    return {
        BridgeProjectData: generateBridgeProjectDataFromObra(obra),
        BridgeType: 0, // Padrão: 0 (pode ser configurado depois)
        GeneralConfigData: generateGeneralConfigDataFromObra(obra),
        BridgeTransitionData: generateBridgeTransitionDataFromObra(obra),
        SuperstructureData: generateSuperstructureDataFromObra(obra),
        BridgePierData: generateBridgePierDataFromObra(obra),
        BridgeComplementaryData: generateBridgeComplementaryDataFromObra(obra)
    };
}




/**
 * Gera BridgeProjectData a partir de uma obra flat
 * @param {object} obra - Obra do IndexedDB
 * @returns {object} BridgeProjectData
 */
// Versão: 2.0

function generateBridgeProjectDataFromObra(obra) {
    return {
        Name: obra.NOME || "",
        Id: 0,
        Code: obra.CODIGO || "",
        State: obra.UF || "",
        Highway: obra.RODOVIA || "",
        Km: parseFloat(obra.KM) || 0.0,
        Date: obra.DATA || "",
        Engineer: obra.ENGENHEIRO || "",
        Technician: obra.TECNICO || ""
    };
}




// Versão: 2.0




// Versão: 2.2

/**
 * Gera GeneralConfigData a partir de uma obra flat
 * Cria objeto Spans (BridgeSpanCollection) com tramos individuais
 * @param {object} obra - Obra do IndexedDB
 * @returns {object} GeneralConfigData com estrutura BridgeSpanCollection
 */
function generateGeneralConfigDataFromObra(obra) {
    const comprimento = parseFloat(obra.COMPRIMENTO) || 0.0;
    const qtdTramos = parseInt(obra["QTD TRAMOS"]) || parseInt(obra.QTD_TRAMOS) || 1;
    
    console.log(`[GeneralConfig] Processando obra ${obra.CODIGO}:`);
    console.log(`  - Comprimento total: ${comprimento}m`);
    console.log(`  - Quantidade de tramos: ${qtdTramos}`);
    
    // Processa comprimentos dos tramos (formato: "10;9;11")
    // CORREÇÃO: O campo no IndexedDB é "COMPRIMENTO TRAMOS" (com espaço)
    const spanLengths = [];
    const comprimentoTramosValue = obra["COMPRIMENTO TRAMOS"] || obra.COMPRIMENTO_TRAMOS;
    
    console.log(`  - COMPRIMENTO TRAMOS raw:`, comprimentoTramosValue);
    
    if (comprimentoTramosValue) {
        const tramosStr = comprimentoTramosValue.toString().trim();
        
        if (tramosStr.length > 0) {
            const tramosArray = tramosStr.split(';');
            
            tramosArray.forEach((t, index) => {
                const trimmed = t.trim();
                if (trimmed.length > 0) {
                    const valor = parseFloat(trimmed);
                    if (!isNaN(valor) && valor > 0) {
                        spanLengths.push(valor);
                        console.log(`  - Tramo ${index + 1}: ${valor}m`);
                    } else {
                        console.warn(`  - Tramo ${index + 1}: valor inválido "${trimmed}"`);
                    }
                }
            });
        }
    }
    
    // Se não houver tramos definidos, distribui igualmente
    if (spanLengths.length === 0) {
        console.warn(`  ⚠️ Nenhum tramo definido, distribuindo ${comprimento}m em ${qtdTramos} tramos iguais`);
        const spanLength = comprimento / qtdTramos;
        for (let i = 0; i < qtdTramos; i++) {
            spanLengths.push(spanLength);
        }
    }
    
    // Validar soma dos tramos
    const somaTramos = spanLengths.reduce((sum, length) => sum + length, 0);
    const diferenca = Math.abs(somaTramos - comprimento);
    
    console.log(`  - Soma dos tramos: ${somaTramos.toFixed(2)}m`);
    console.log(`  - Diferença: ${diferenca.toFixed(4)}m`);
    
    if (diferenca > 0.01) {
        console.warn(`  ⚠️ Soma dos tramos difere do comprimento total!`);
    }

    // Criar objeto BridgeSpanCollection compatível com C#
    const bridgeSpanCollection = createBridgeSpanCollection(spanLengths, comprimento);
    
    console.log(`  ✓ BridgeSpanCollection criado com ${bridgeSpanCollection.Count} tramos`);

    return {
        Length: comprimento,
        Width: parseFloat(obra.LARGURA) || 0.0,
        Height: parseFloat(obra.ALTURA) || 0.0,
        ExpansionJointLength: 0.020,
        Spans: bridgeSpanCollection,
        BridgeOption: createZSElementTypeFromValue(obra.BRIDGE_OPTION)
    };
}



// Versão: 1.0 - DEBUG

/**
 * Função temporária para listar TODOS os campos de uma obra
 * Remove depois de identificar os nomes corretos
 */
function debugObraFields(obra) {
    console.log("=== TODOS OS CAMPOS DA OBRA ===");
    for (const key in obra) {
        if (obra.hasOwnProperty(key)) {
            console.log(`${key}: ${typeof obra[key]} = ${obra[key]}`);
        }
    }
    console.log("===============================");
}


/**
 * Cria um objeto BridgeSpanCollection compatível com a classe C#
 * @param {Array<number>} spanLengths - Array com comprimentos dos tramos
 * @param {number} expectedTotalLength - Comprimento total esperado
 * @returns {object} BridgeSpanCollection
 */
function createBridgeSpanCollection(spanLengths, expectedTotalLength) {
    const spans = [];
    
    // Criar cada BridgeSpan individual
    for (let i = 0; i < spanLengths.length; i++) {
        const bridgeSpan = {
            Index: i,
            Length: spanLengths[i],
            IsManuallyDefined: true,
            IsLastSpan: (i === spanLengths.length - 1)
        };
        spans.push(bridgeSpan);
    }
    
    // Calcular soma total dos tramos
    const totalLength = spanLengths.reduce((sum, length) => sum + length, 0);
    const lengthDifference = expectedTotalLength - totalLength;
    const remainingLength = Math.max(0, lengthDifference);
    
    // Retornar BridgeSpanCollection
    return {
        ExpectedTotalLength: expectedTotalLength,
        Count: spans.length,
        TotalLength: totalLength,
        RemainingLength: remainingLength,
        LengthDifference: lengthDifference,
        IsValid: Math.abs(lengthDifference) <= 0.01,
        SpanLengths: spanLengths,
        _spans: spans  // Lista interna de BridgeSpan
    };
}



// Versão: 2.0

/**
 * Gera BridgeTransitionData a partir de uma obra flat
 * @param {object} obra - Obra do IndexedDB
 * @returns {object} BridgeTransitionData
 */
function generateBridgeTransitionDataFromObra(obra) {
    // CORREÇÃO: Usar nomes com ESPAÇO como no IndexedDB
    const cortinaAltura = parseFloat(obra["CORTINA ALTURA"] || obra.CORTINA_ALTURA) || 1.50;
    const tipoEncontro = obra["TIPO ENCONTRO"] || obra.TIPO_ENCONTRO || "";
    const isSlabAbutment = (tipoEncontro.toUpperCase() === "ENCONTRO LAJE" || 
                           tipoEncontro.toUpperCase() === "ENCONTRO DE LAJE");
    
    console.log(`[Transition] Cortina Altura: ${cortinaAltura}`);
    console.log(`[Transition] Tipo Encontro: "${tipoEncontro}" → IsSlabAbutment: ${isSlabAbutment}`);
    
    return {
        CurtainHeight: cortinaAltura,
        BearingThickness: 0.05,
        IsSlabAbutment: isSlabAbutment,
        SlabAbutmentLength: parseFloat(obra["COMPRIMENTO ENCONTRO LAJE"] || obra.COMPRIMENTO_ENCONTRO_LAJE) || 0.0,
        SlabAbutmentLeftOffset: parseFloat(obra["DESLOCAMENTO ESQUERDO ENCONTRO LAJE"] || obra.DESLOCAMENTO_ESQUERDO_ENCONTRO_LAJE) || 0.0,
        SlabAbutmentRightOffset: parseFloat(obra["DESLOCAMENTO DIREITO ENCONTRO LAJE"] || obra.DESLOCAMENTO_DIREITO_ENCONTRO_LAJE) || 0.0,
        ParallelWing: createZSElementTypeFromValue(obra["TIPO ALA PARALELA"] || obra.TIPO_ALA_PARALELA),
        PerpendicularWing: createZSElementTypeFromValue(obra["TIPO ALA PERPENDICULAR"] || obra.TIPO_ALA_PERPENDICULAR),
        WingLength: parseFloat(obra["COMPRIMENTO ALA"] || obra.COMPRIMENTO_ALA) || 0.0,
        WingThickness: parseFloat(obra["ESPESSURA ALA"] || obra.ESPESSURA_ALA) || 0.0,
        AbutmentType: createZSElementTypeFromValue(obra["TIPO ENCONTRO"] || obra.TIPO_ENCONTRO),
        TransitionSlabType: createZSElementTypeFromValue(obra["LAJE TRANSICAO"] || obra.LAJE_TRANSICAO),
        ReinforcedEarthWallType: createZSElementTypeFromValue(obra["TIPO TERRA ARMADA"] || obra.TIPO_TERRA_ARMADA)
    };
}



// Versão: 1.0

/**
 * Gera SuperstructureData a partir de uma obra flat
 * @param {object} obra - Obra do IndexedDB
 * @returns {object} BridgeSuperstructureData
 */
// Versão: 2.0

function generateSuperstructureDataFromObra(obra) {
    return {
        LongarineHeight: parseFloat(obra["ALTURA LONGARINA"] || obra.ALTURA_LONGARINA) || 0.0,
        LongarineThickness: parseFloat(obra["ESPESSURA LONGARINA"] || obra.ESPESSURA_LONGARINA) || 0.0,
        NumberOfLongarines: parseInt(obra["QTD LONGARINAS"] || obra.QTD_LONGARINAS) || 2,
        LongarineType: createZSElementTypeFromValue(obra["TIPO LONGARINA"] || obra.TIPO_LONGARINA),
        TransversineHeight: parseFloat(obra["ALTURA TRANSVERSINA"] || obra.ALTURA_TRANSVERSINA) || 0.0,
        TransversineThickness: parseFloat(obra["ESPESSURA TRANSVERSINA"] || obra.ESPESSURA_TRANSVERSINA) || 0.0,
        NumberOfTransversines: parseInt(obra["QTD TRANSVERSINAS"] || obra.QTD_TRANSVERSINAS) || 3,
        TransversineType: createZSElementTypeFromValue(obra["TIPO TRANSVERSINA"] || obra.TIPO_TRANSVERSINA),
        SlabType: createZSElementTypeFromValue(obra["TIPO LAJE"] || obra.TIPO_LAJE),
        SlabThickness: parseFloat(obra["ESPESSURA LAJE"] || obra.ESPESSURA_LAJE) || 0.0,
        SlabStiffeningLongarineType: createZSElementTypeFromValue(obra["TIPO LONGARINA ENRIJECIMENTO"] || obra.TIPO_LONGARINA_ENRIJECIMENTO),
        CornerAngleType: createZSElementTypeFromValue(obra["TIPO CANTONEIRA"] || obra.TIPO_CANTONEIRA),
        LeftDisplacement: parseFloat(obra["DESLOCAMENTO ESQUERDO"] || obra.DESLOCAMENTO_ESQUERDO) || 0.0,
        RightDisplacement: parseFloat(obra["DESLOCAMENTO DIREITO"] || obra.DESLOCAMENTO_DIREITO) || 0.0
    };
}



// Versão: 1.0

/**
 * Gera BridgePierData a partir de uma obra flat
 * @param {object} obra - Obra do IndexedDB
 * @returns {object} BridgePierData
 */


 // Versão: 2.0

function generateBridgePierDataFromObra(obra) {
    // Processa alturas dos apoios (formato: "1;1.1;1.2")
    const pierHeights = [];
    const alturaApoioValue = obra["ALTURA APOIO"] || obra.ALTURA_APOIO;
    if (alturaApoioValue) {
        const alturasStr = alturaApoioValue.toString();
        const alturasArray = alturasStr.split(';');
        alturasArray.forEach(a => {
            const valor = parseFloat(a.trim());
            if (!isNaN(valor)) {
                pierHeights.push(valor);
            }
        });
    }

    // Processa larguras dos pilares (formato: "0.4;0.4")
    const pillarWidths = [];
    const larguraPilarValue = obra["LARGURA PILAR"] || obra.LARGURA_PILAR;
    if (larguraPilarValue) {
        const largurasStr = larguraPilarValue.toString();
        const largurasArray = largurasStr.split(';');
        largurasArray.forEach(l => {
            const valor = parseFloat(l.trim());
            if (!isNaN(valor)) {
                pillarWidths.push(valor);
            }
        });
    }

    // Processa comprimentos dos pilares (formato: "2.2;2.2")
    const pillarLengths = [];
    const comprimentoPilaresValue = obra["COMPRIMENTO PILARES"] || obra.COMPRIMENTO_PILARES;
    if (comprimentoPilaresValue) {
        const comprimentosStr = comprimentoPilaresValue.toString();
        const comprimentosArray = comprimentosStr.split(';');
        comprimentosArray.forEach(c => {
            const valor = parseFloat(c.trim());
            if (!isNaN(valor)) {
                pillarLengths.push(valor);
            }
        });
    }

    return {
        PierConfigurations: {
            PierHeights: pierHeights
        },
        NumberOfPillarsPerPier: parseInt(obra["QTD PILARES"] || obra.QTD_PILARES) || 1,
        PillarType: createZSElementTypeFromValue(obra["TIPO PILAR"] || obra.TIPO_PILAR),
        CrossbeamType: createZSElementTypeFromValue(obra["TIPO TRAVESSA"] || obra.TIPO_TRAVESSA),
        FoundationType: createZSElementTypeFromValue(obra["TIPO BLOCO SAPATA"] || obra.TIPO_BLOCO_SAPATA),
        BearingType: createZSElementTypeFromValue(obra["TIPO APARELHO APOIO"] || obra.TIPO_APARELHO_APOIO),
        PillarBracingBeamType: createZSElementTypeFromValue(obra["TIPO CONTRAVENTAMENTO PILAR"] || obra.TIPO_CONTRAVENTAMENTO_PILAR),
        ConnectionBeamType: createZSElementTypeFromValue(obra["TIPO VIGA LIGACAO"] || obra.TIPO_VIGA_LIGACAO),
        PillarJacketType: createZSElementTypeFromValue(obra["TIPO ENCAMISAMENTO"] || obra.TIPO_ENCAMISAMENTO),
        FoundationConnectionBeamType: createZSElementTypeFromValue(obra["TIPO LIGACAO FUNDACOES"] || obra.TIPO_LIGACAO_FUNDACOES),
        PillarWidth: pillarWidths.length > 0 ? pillarWidths[0] : 0.0,
        PillarLength: pillarLengths.length > 0 ? pillarLengths[0] : 0.0,
        IsOffCenterPillar: (obra["PILAR DESCENTRALIZADO"] || obra.PILAR_DESCENTRALIZADO) === "Sim",
        CrossbeamLength: parseFloat(obra["COMPRIMENTO TRAVESSA"] || obra.COMPRIMENTO_TRAVESSA) || 0.0,
        CrossbeamHeight: parseFloat(obra["ALTURA TRAVESSA"] || obra.ALTURA_TRAVESSA) || 0.0,
        FoundationHeight: parseFloat(obra["ALTURA BLOCO SAPATA"] || obra.ALTURA_BLOCO_SAPATA) || 0.0,
        FoundationLength: parseFloat(obra["COMPRIMENTO BLOCO SAPATA"] || obra.COMPRIMENTO_BLOCO_SAPATA) || 0.0,
        FoundationWidth: parseFloat(obra["LARGURA BLOCO SAPATA"] || obra.LARGURA_BLOCO_SAPATA) || 0.0,
        PillarBracingBeamQuantity: parseInt(obra["QTD VIGAS CONTRAVENTAMENTO"] || obra.QTD_VIGAS_CONTRAVENTAMENTO) || 0,
        PillarBracingBeamHeight: parseFloat(obra["ALTURA VIGA CONTRAVENTAMENTO"] || obra.ALTURA_VIGA_CONTRAVENTAMENTO) || 0.0,
        PillarBracingBeamLength: parseFloat(obra["COMPRIMENTO VIGA CONTRAVENTAMENTO"] || obra.COMPRIMENTO_VIGA_CONTRAVENTAMENTO) || 0.0,
        FoundationConnectionBeamHeight: parseFloat(obra["ALTURA VIGA LIGACAO FUNDACOES"] || obra.ALTURA_VIGA_LIGACAO_FUNDACOES) || 0.0,
        FoundationConnectionBeamLength: parseFloat(obra["COMPRIMENTO VIGA LIGACAO FUNDACOES"] || obra.COMPRIMENTO_VIGA_LIGACAO_FUNDACOES) || 0.0,
        PierHeights: pierHeights,
        Height: pierHeights.length > 0 ? pierHeights.reduce((a, b) => a + b, 0) / pierHeights.length : 0.0
    };
}



// Versão: 1.0

/**
 * Gera BridgeComplementaryData a partir de uma obra flat
 * @param {object} obra - Obra do IndexedDB
 * @returns {object} BridgeComplementaryData
 */
// Versão: 2.0

function generateBridgeComplementaryDataFromObra(obra) {
    return {
        LeftBarrierType: createZSElementTypeFromValue(obra["TIPO BARREIRA ESQUERDA"] || obra.TIPO_BARREIRA_ESQUERDA),
        LeftBarrierWidth: parseFloat(obra["LARGURA BARREIRA ESQUERDA"] || obra.LARGURA_BARREIRA_ESQUERDA) || 0.0,
        RightBarrierType: createZSElementTypeFromValue(obra["TIPO BARREIRA DIREITA"] || obra.TIPO_BARREIRA_DIREITA),
        RightBarrierWidth: parseFloat(obra["LARGURA BARREIRA DIREITA"] || obra.LARGURA_BARREIRA_DIREITA) || 0.0,
        LeftSidewalkType: createZSElementTypeFromValue(obra["TIPO CALCADA ESQUERDA"] || obra.TIPO_CALCADA_ESQUERDA),
        LeftSidewalkWidth: parseFloat(obra["LARGURA CALCADA ESQUERDA"] || obra.LARGURA_CALCADA_ESQUERDA) || 0.0,
        RightSidewalkType: createZSElementTypeFromValue(obra["TIPO CALCADA DIREITA"] || obra.TIPO_CALCADA_DIREITA),
        RightSidewalkWidth: parseFloat(obra["LARGURA CALCADA DIREITA"] || obra.LARGURA_CALCADA_DIREITA) || 0.0,
        LeftGuardRailType: createZSElementTypeFromValue(obra["GUARDA RODAS ESQUERDO"] || obra.GUARDA_RODAS_ESQUERDO),
        LeftGuardRailWidth: parseFloat(obra["LARGURA GUARDA RODAS ESQUERDO"] || obra.LARGURA_GUARDA_RODAS_ESQUERDO) || 0.0,
        RightGuardRail: createZSElementTypeFromValue(obra["GUARDA RODAS DIREITO"] || obra.GUARDA_RODAS_DIREITO),
        RightGuardRailWidth: parseFloat(obra["LARGURA GUARDA RODAS DIREITO"] || obra.LARGURA_GUARDA_RODAS_DIREITO) || 0.0,
        LeftGuardBodyType: createZSElementTypeFromValue(obra["GUARDA CORPO ESQUERDO"] || obra.GUARDA_CORPO_ESQUERDO),
        LeftGuardBodyWidth: parseFloat(obra["LARGURA GUARDA CORPO ESQUERDO"] || obra.LARGURA_GUARDA_CORPO_ESQUERDO) || 0.0,
        RightGuardBodyType: createZSElementTypeFromValue(obra["GUARDA CORPO DIREITO"] || obra.GUARDA_CORPO_DIREITO),
        RightGuardBodyWidth: parseFloat(obra["LARGURA GUARDA CORPO DIREITO"] || obra.LARGURA_GUARDA_CORPO_DIREITO) || 0.0,
        PavementType: createZSElementTypeFromValue(obra["TIPO PAVIMENTO"] || obra.TIPO_PAVIMENTO),
        ExpansionJointType: createZSElementTypeFromValue(obra["TIPO JUNTA DILATACAO"] || obra.TIPO_JUNTA_DILATACAO),
        CradleType: createZSElementTypeFromValue(obra["TIPO BERCO"] || obra.TIPO_BERCO),
        NumberOfBuzinotes: parseInt(obra["QTD BUZINOTES"] || obra.QTD_BUZINOTES) || 0
    };
}


/**
 * Cria um objeto ZSElementType a partir de um valor do IndexedDB
 * @param {string} fieldValue - Valor do campo (geralmente string)
 * @returns {object|null} Objeto ZSElementType ou null se vazio
 */
function createZSElementTypeFromValue(fieldValue) {
    if (!fieldValue || 
        fieldValue === "" || 
        fieldValue === "Selecione" || 
        fieldValue === "Nenhum" ||
        fieldValue === "NULL" ||
        fieldValue === "null") {
        return null;
    }

    return {
        Name: fieldValue.toString(),
        Id: 0,
        Category: 0,
        TypeMark: "",
        FamilyName: "",
        IsActive: true,
        TypeComments: "",
        IsSystemFamily: false,
        CanBeTransferred: true
    };
}



/**
 * Exporta apenas as obras do IndexedDB como JSON
 * Esta é a função correta para exportar obras
 */
async function exportWorksToJSON() {
    try {
        console.log("Iniciando exportação de obras do IndexedDB...");
        showLoadingMessage("Buscando obras no banco de dados...");

        // Abrir conexão com o banco
        const db = await openDatabase();
        
        if (!db) {
            hideLoadingMessage();
            alert("❌ Erro ao acessar o banco de dados!");
            return;
        }

        // Listar todos os object stores disponíveis
        const storeNames = Array.from(db.objectStoreNames);
        console.log("Object stores disponíveis:", storeNames);

        if (storeNames.length === 0) {
            hideLoadingMessage();
            alert("⚠️ O banco de dados não possui tabelas (object stores).\n\nVerifique se as obras foram salvas corretamente.");
            db.close();
            return;
        }

        // Buscar dados de todos os object stores
        const allWorks = [];
        
        for (const storeName of storeNames) {
            try {
                const transaction = db.transaction([storeName], "readonly");
                const objectStore = transaction.objectStore(storeName);
                const request = objectStore.getAll();

                const data = await new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });

                if (data && data.length > 0) {
                    console.log(`✓ ${data.length} registro(s) encontrado(s) em '${storeName}'`);
                    allWorks.push(...data);
                }
            } catch (err) {
                console.warn(`Erro ao acessar '${storeName}':`, err);
            }
        }

        db.close();

        if (allWorks.length === 0) {
            hideLoadingMessage();
            alert("⚠️ Nenhuma obra encontrada no banco de dados!\n\nCadastre obras antes de exportar.");
            return;
        }

        console.log(`Total de obras encontradas: ${allWorks.length}`);

        // Converter obras para formato BridgeData
        showLoadingMessage(`Convertendo ${allWorks.length} obra(s)...`);
        
        const bridgeDataArray = [];
        let successCount = 0;
        let errorCount = 0;

        for (const work of allWorks) {
            try {
                const bridgeData = convertWorkToBridgeData(work);
                bridgeDataArray.push(bridgeData);
                successCount++;
            } catch (error) {
                console.error("Erro ao converter obra:", error, work);
                errorCount++;
            }
        }

        // Criar exportação final
        const exportData = {
            ExportDate: new Date().toISOString(),
            ExportVersion: "1.2",
            ExportSource: "IndexedDB",
            TotalWorks: bridgeDataArray.length,
            SuccessfulConversions: successCount,
            FailedConversions: errorCount,
            Works: bridgeDataArray
        };

        const jsonString = JSON.stringify(exportData, null, 2);

        hideLoadingMessage();

        // Mostrar modal com preview
        showExportPreviewModal(exportData, jsonString);

    } catch (error) {
        console.error("Erro ao exportar obras:", error);
        hideLoadingMessage();
        alert("❌ Erro ao exportar obras:\n\n" + error.message);
    }
}

/**
 * Abre conexão com o banco de dados IndexedDB
 * @returns {Promise<IDBDatabase>}
 */
function openDatabase() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open("PontesDB", 1);

        request.onerror = () => {
            console.error("Erro ao abrir banco:", request.error);
            reject(request.error);
        };

        request.onsuccess = () => {
            resolve(request.result);
        };

        request.onupgradeneeded = (event) => {
            console.log("Banco necessita upgrade");
            const db = event.target.result;
            
            // Criar object store se não existir
            if (!db.objectStoreNames.contains("pontes")) {
                db.createObjectStore("pontes", { keyPath: "CODIGO" });
                console.log("Object store 'pontes' criado");
            }
        };
    });
}

/**
 * Mostra modal com preview da exportação
 */
function showExportPreviewModal(exportData, jsonString) {
    const modal = document.createElement("div");
    modal.className = "modal";
    modal.style.display = "block";
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 900px; max-height: 85vh;">
            <span class="close" onclick="this.parentElement.parentElement.remove()">&times;</span>
            <h2>📦 Exportação de Obras - JSON</h2>
            <div style="margin: 20px 0; padding: 15px; background: rgba(52, 152, 219, 0.1); border-radius: 8px;">
                <p><strong>✅ Total de obras:</strong> ${exportData.TotalWorks}</p>
                <p><strong>✓ Convertidas com sucesso:</strong> ${exportData.SuccessfulConversions}</p>
                ${exportData.FailedConversions > 0 ? `<p style="color: #e74c3c;"><strong>⚠️ Falhas:</strong> ${exportData.FailedConversions}</p>` : ''}
                <p><strong>📅 Data:</strong> ${new Date(exportData.ExportDate).toLocaleString('pt-BR')}</p>
                <p><strong>📏 Tamanho:</strong> ${(new Blob([jsonString]).size / 1024).toFixed(2)} KB</p>
            </div>
            <h3>Preview do JSON (primeiras 50 linhas):</h3>
            <pre id="json-preview" style="background: #2c3e50; color: #ecf0f1; padding: 15px; border-radius: 5px; overflow: auto; max-height: 40vh; font-size: 12px;">${jsonString.split('\n').slice(0, 50).join('\n')}${jsonString.split('\n').length > 50 ? '\n\n... (mais ' + (jsonString.split('\n').length - 50) + ' linhas)' : ''}</pre>
            <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                <button onclick="window.downloadCurrentExportJSON()">⬇️ Download JSON</button>
                <button onclick="window.copyCurrentExportJSON()">📋 Copiar JSON</button>
                <button onclick="this.parentElement.parentElement.parentElement.remove()" style="background: #95a5a6;">❌ Fechar</button>
            </div>
        </div>
    `;

    document.body.appendChild(modal);

    // Armazenar para download/cópia
    window.currentExportJSON = jsonString;
    window.currentExportFilename = `Obras_Export_${getTimestamp()}.json`;
}

/**
 * Download do JSON
 */
window.downloadCurrentExportJSON = function() {
    if (window.currentExportJSON && window.currentExportFilename) {
        const blob = new Blob([window.currentExportJSON], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = window.currentExportFilename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        alert("✅ Download iniciado!");
    }
};

/**
 * Copia JSON para clipboard
 */
window.copyCurrentExportJSON = function() {
    if (!window.currentExportJSON) {
        alert("❌ Nenhum JSON disponível!");
        return;
    }

    navigator.clipboard.writeText(window.currentExportJSON).then(() => {
        alert("✅ JSON copiado para a área de transferência!");
    }).catch(err => {
        console.error("Erro ao copiar:", err);
        alert("❌ Erro ao copiar JSON");
    });
};

/**
 * Função de diagnóstico do banco de dados
 */
async function diagnosticarBancoDados() {
    console.log("=== DIAGNÓSTICO DO BANCO DE DADOS ===");
    
    try {
        const db = await openDatabase();
        
        console.log("✓ Banco aberto com sucesso");
        console.log("Nome:", db.name);
        console.log("Versão:", db.version);
        
        const storeNames = Array.from(db.objectStoreNames);
        console.log("Object Stores:", storeNames);
        
        if (storeNames.length === 0) {
            console.warn("⚠️ Nenhum object store encontrado!");
            db.close();
            return { success: false, message: "Banco vazio" };
        }

        const results = {};
        
        for (const storeName of storeNames) {
            try {
                const transaction = db.transaction([storeName], "readonly");
                const objectStore = transaction.objectStore(storeName);
                const countRequest = objectStore.count();
                
                const count = await new Promise((resolve, reject) => {
                    countRequest.onsuccess = () => resolve(countRequest.result);
                    countRequest.onerror = () => reject(countRequest.error);
                });
                
                results[storeName] = count;
                console.log(`  - ${storeName}: ${count} registro(s)`);
            } catch (err) {
                console.error(`Erro ao contar '${storeName}':`, err);
                results[storeName] = "ERRO";
            }
        }
        
        db.close();
        
        const totalRecords = Object.values(results).reduce((sum, val) => 
            sum + (typeof val === 'number' ? val : 0), 0
        );
        
        console.log(`\nTotal de registros: ${totalRecords}`);
        
        return { success: true, stores: results, total: totalRecords };
        
    } catch (error) {
        console.error("❌ Erro no diagnóstico:", error);
        return { success: false, error: error.message };
    }
}

/**
 * Helper para timestamp
 */
function getTimestamp() {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const seconds = String(now.getSeconds()).padStart(2, '0');
    return `${year}${month}${day}_${hours}${minutes}${seconds}`;
}

// Expor funções globalmente
window.exportToJSON = exportToJSON;
window.exportWorksToJSON = exportWorksToJSON;
window.diagnosticarBancoDados = diagnosticarBancoDados;

console.log("✅ Funções de exportação atualizadas!");
console.log("💡 Use: diagnosticarBancoDados() para verificar o banco");
console.log("💡 Use: exportWorksToJSON() para exportar obras");






// Versão: 1.0
// Função para gerar JSON do BridgeData compatível com a estrutura C#

/**
 * Função principal que gera o objeto BridgeData completo
 * @returns {object} Objeto BridgeData no formato esperado pelo backend C#
 */
function generateBridgeDataJSON() {
    try {
        const bridgeData = {
            BridgeProjectData: generateBridgeProjectData(),
            GeneralConfigData: generateGeneralConfigData(),
            BridgeTransitionData: generateBridgeTransitionData(),
            SuperstructureData: generateSuperstructureData(),
            BridgePierData: generateBridgePierData(),
            BridgeComplementaryData: generateBridgeComplementaryData()
        };

        return bridgeData;
    } catch (error) {
        console.error("Erro ao gerar BridgeData JSON:", error);
        throw error;
    }
}

/**
 * Gera o objeto BridgeProjectData
 * Herda de BasicData (Name, Id)
 */
function generateBridgeProjectData() {
    return {
        Name: getFieldValue("nome") || "",
        Id: 0,
        Code: getFieldValue("codigo") || "",
        State: getFieldValue("uf") || "",
        Highway: getFieldValue("rodovia") || "",
        Km: parseFloat(getFieldValue("km")) || 0.0,
        Date: getFieldValue("data") || "",
        Engineer: getFieldValue("engenheiro") || "",
        Technician: getFieldValue("tecnico") || ""
    };
}

/**
 * Gera o objeto GeneralConfigData
 */
function generateGeneralConfigData() {
    const comprimento = parseFloat(getFieldValue("comprimento")) || 0.0;
    const qtdTramos = parseInt(getFieldValue("qtd-tramos")) || 1;
    
    // Coletar comprimentos individuais dos tramos
    const spanLengths = [];
    const tramosFields = document.querySelectorAll(".tramo-field");
    tramosFields.forEach(field => {
        const valor = parseFloat(field.value) || 0.0;
        spanLengths.push(valor);
    });

    return {
        Length: comprimento,
        Width: parseFloat(getFieldValue("largura")) || 0.0,
        Height: parseFloat(getFieldValue("altura")) || 0.0,
        ExpansionJointLength: 0.020,
        Spans: {
            ExpectedTotalLength: comprimento,
            SpanLengths: spanLengths
        },
        BridgeOption: createZSElementType(getFieldValue("bridge-option")),
        BridgeLengthGaps: qtdTramos,
        SpanLengths: spanLengths
    };
}

/**
 * Gera o objeto BridgeTransitionData
 */
function generateBridgeTransitionData() {
    return {
        CurtainHeight: parseFloat(getFieldValue("cortina-altura")) || 1.50,
        BearingThickness: 0.05,
        IsSlabAbutment: getFieldValue("tipo-encontro") ? true : false,
        SlabAbutmentLength: parseFloat(getFieldValue("comprimento-encontro-laje")) || 0.0,
        SlabAbutmentLeftOffset: parseFloat(getFieldValue("deslocamento-esquerdo-encontro-laje")) || 0.0,
        SlabAbutmentRightOffset: parseFloat(getFieldValue("deslocamento-direito-encontro-laje")) || 0.0,
        ParallelWing: createZSElementType(getFieldValue("tipo-ala-paralela")),
        PerpendicularWing: createZSElementType(getFieldValue("tipo-ala-perpendicular")),
        WingLength: parseFloat(getFieldValue("comprimento-ala")) || 0.0,
        WingThickness: parseFloat(getFieldValue("espessura-ala")) || 0.0,
        AbutmentType: createZSElementType(getFieldValue("tipo-encontro")),
        TransitionSlabType: createZSElementType(getFieldValue("laje-transicao")),
        ReinforcedEarthWallType: null
    };
}

/**
 * Gera o objeto SuperstructureData
 */
function generateSuperstructureData() {
    return {
        LongarineHeight: parseFloat(getFieldValue("altura-longarina")) || 0.0,
        LongarineThickness: parseFloat(getFieldValue("espessura-longarina")) || 0.0,
        NumberOfLongarines: parseInt(getFieldValue("qtd-longarinas")) || 2,
        LongarineType: null,
        TransversineHeight: parseFloat(getFieldValue("altura-longarina")) || 0.0,
        TransversineThickness: parseFloat(getFieldValue("espessura-transversina")) || 0.0,
        NumberOfTransversines: parseInt(getFieldValue("qtd-transversinas")) || 3,
        TransversineType: null,
        SlabType: null,
        SlabThickness: parseFloat(getFieldValue("espessura-laje")) || 0.0,
        SlabStiffeningLongarineType: null,
        CornerAngleType: null,
        LeftDisplacement: parseFloat(getFieldValue("deslocamento-esquerdo")) || 0.0,
        RightDisplacement: parseFloat(getFieldValue("deslocamento-direito")) || 0.0
    };
}

/**
 * Gera o objeto BridgePierData
 */
function generateBridgePierData() {
    const qtdTramos = parseInt(getFieldValue("qtd-tramos")) || 1;
    const qtdPilares = Math.max(0, qtdTramos - 1);
    
    // Coletar alturas dos apoios
    const pierHeights = [];
    const alturasFields = document.querySelectorAll(".apoio-altura-field");
    alturasFields.forEach(field => {
        const altura = parseFloat(field.value) || 0.0;
        pierHeights.push(altura);
    });

    // Coletar larguras dos pilares
    const pillarWidths = [];
    const largurasFields = document.querySelectorAll(".apoio-larg-field");
    largurasFields.forEach(field => {
        const largura = parseFloat(field.value) || 0.0;
        pillarWidths.push(largura);
    });

    // Coletar comprimentos dos pilares
    const pillarLengths = [];
    const comprimentosFields = document.querySelectorAll(".apoio-comp-field");
    comprimentosFields.forEach(field => {
        const comprimento = parseFloat(field.value) || 0.0;
        pillarLengths.push(comprimento);
    });

    return {
        PierConfigurations: {
            PierHeights: pierHeights
        },
        NumberOfPillarsPerPier: parseInt(getFieldValue("qtd-pilares")) || 1,
        PillarType: null,
        CrossbeamType: createZSElementType(getFieldValue("tipo-travessa")),
        FoundationType: createZSElementType(getFieldValue("tipo-bloco-sapata")),
        BearingType: createZSElementType(getFieldValue("tipo-aparelho-apoio")),
        PillarBracingBeamType: createZSElementType(getFieldValue("tipo-contraventamento-pilar")),
        ConnectionBeamType: null,
        PillarJacketType: createZSElementType(getFieldValue("tipo-encamisamento")),
        FoundationConnectionBeamType: createZSElementType(getFieldValue("tipo-ligacao-fundacoes")),
        PillarWidth: pillarWidths.length > 0 ? pillarWidths[0] : 0.0,
        PillarLength: pillarLengths.length > 0 ? pillarLengths[0] : 0.0,
        IsOffCenterPillar: getFieldValue("pilar-descentralizado") === "Sim",
        CrossbeamLength: 0.0,
        CrossbeamHeight: parseFloat(getFieldValue("altura-travessa")) || 0.0,
        FoundationHeight: parseFloat(getFieldValue("altura-bloco-sapata")) || 0.0,
        FoundationLength: 0.0,
        FoundationWidth: parseFloat(getFieldValue("largura-bloco-sapata")) || 0.0,
        PillarBracingBeamQuantity: 0,
        PillarBracingBeamHeight: 0.0,
        PillarBracingBeamLength: 0.0,
        FoundationConnectionBeamHeight: 0.0,
        FoundationConnectionBeamLength: 0.0,
        PierHeights: pierHeights,
        Height: pierHeights.length > 0 ? pierHeights.reduce((a, b) => a + b, 0) / pierHeights.length : 0.0
    };
}

/**
 * Gera o objeto BridgeComplementaryData
 */
function generateBridgeComplementaryData() {
    return {
        LeftBarrierType: createZSElementType(getFieldValue("tipo-barreira-esquerda")),
        LeftBarrierWidth: parseFloat(getFieldValue("largura-barreira-esquerda")) || 0.0,
        RightBarrierType: createZSElementType(getFieldValue("tipo-barreira-direita")),
        RightBarrierWidth: parseFloat(getFieldValue("largura-barreira-direita")) || 0.0,
        LeftSidewalk: createZSElementType(getFieldValue("tipo-calcada-esquerda")),
        LeftSidewalkWidth: parseFloat(getFieldValue("largura-calcada-esquerda")) || 0.0,
        RightSidewalkType: createZSElementType(getFieldValue("tipo-calcada-direita")),
        RightSidewalkWidth: parseFloat(getFieldValue("largura-calcada-direita")) || 0.0,
        LeftGuardRailType: createZSElementType(getFieldValue("guarda-rodas-esquerdo")),
        LeftGuardRailWidth: parseFloat(getFieldValue("largura-guarda-rodas-esquerdo")) || 0.0,
        RightGuardRail: createZSElementType(getFieldValue("guarda-rodas-direito")),
        RightGuardRailWidth: parseFloat(getFieldValue("largura-guarda-rodas-direito")) || 0.0,
        LeftGuardBodyType: null,
        LeftGuardBodyWidth: 0.0,
        RightGuardBodyType: null,
        RightGuardBodyWidth: 0.0,
        PavementType: createZSElementType(getFieldValue("tipo-pavimento")),
        ExpansionJointType: null,
        CradleType: null,
        NumberOfBuzinotes: parseInt(getFieldValue("qtd-buzinotes")) || 0
    };
}

/**
 * Cria um objeto ZSElementType a partir de um valor de campo
 * @param {string} fieldValue - Valor do campo (geralmente de um select)
 * @returns {object|null} Objeto ZSElementType ou null se vazio
 */
function createZSElementType(fieldValue) {
    if (!fieldValue || fieldValue === "" || fieldValue === "Selecione" || fieldValue === "Nenhum") {
        return null;
    }

    return {
        Name: fieldValue,
        Id: 0,
        Category: 0,
        TypeMark: "",
        FamilyName: "",
        IsActive: true,
        TypeComments: "",
        IsSystemFamily: false,
        CanBeTransferred: true
    };
}

/**
 * Função auxiliar para obter valor de um campo do formulário
 * @param {string} fieldId - ID do campo HTML
 * @returns {string} Valor do campo ou string vazia
 */
function getFieldValue(fieldId) {
    const element = document.getElementById(fieldId);
    if (!element) {
        return "";
    }

    if (element.type === "checkbox") {
        return element.checked ? "TRUE" : "FALSE";
    }

    return element.value || "";
}

/**
 * Função para exibir o JSON gerado em um modal ou área de texto
 */
function showBridgeDataJSON() {
    try {
        const bridgeData = generateBridgeDataJSON();
        const jsonString = JSON.stringify(bridgeData, null, 2);

        // Criar modal para exibir o JSON
        const modal = document.createElement("div");
        modal.className = "modal";
        modal.style.display = "block";
        modal.innerHTML = `
            <div class="modal-content" style="max-width: 800px; max-height: 80vh; overflow: auto;">
                <span class="close" onclick="this.parentElement.parentElement.remove()">&times;</span>
                <h2>JSON BridgeData Gerado</h2>
                <pre id="json-output" style="background: #2c3e50; color: #ecf0f1; padding: 15px; border-radius: 5px; overflow: auto; max-height: 60vh;">${jsonString}</pre>
                <div style="margin-top: 15px;">
                    <button onclick="copyBridgeDataJSON()">Copiar JSON</button>
                    <button onclick="downloadBridgeDataJSON()">Download JSON</button>
                </div>
            </div>
        `;

        document.body.appendChild(modal);

        // Adicionar o JSON ao elemento global para facilitar cópia
        window.currentBridgeDataJSON = jsonString;

    } catch (error) {
        alert("Erro ao gerar JSON: " + error.message);
        console.error(error);
    }
}

/**
 * Função para copiar o JSON para a área de transferência
 */
function copyBridgeDataJSON() {
    const jsonString = window.currentBridgeDataJSON;
    
    if (!jsonString) {
        alert("Nenhum JSON gerado ainda!");
        return;
    }

    navigator.clipboard.writeText(jsonString).then(() => {
        alert("JSON copiado para a área de transferência!");
    }).catch(err => {
        console.error("Erro ao copiar:", err);
        
        // Fallback para navegadores antigos
        const textarea = document.createElement("textarea");
        textarea.value = jsonString;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand("copy");
        document.body.removeChild(textarea);
        alert("JSON copiado para a área de transferência!");
    });
}

/**
 * Função para fazer download do JSON como arquivo
 */
function downloadBridgeDataJSON() {
    const jsonString = window.currentBridgeDataJSON;
    
    if (!jsonString) {
        alert("Nenhum JSON gerado ainda!");
        return;
    }

    const blob = new Blob([jsonString], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `BridgeData_${new Date().getTime()}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

/**
 * Função para validar o JSON antes de gerar
 * @returns {object} Objeto com resultado da validação
 */
function validateBridgeData() {
    const errors = [];
    const warnings = [];

    // Validações obrigatórias
    if (!getFieldValue("codigo")) {
        errors.push("Código da obra é obrigatório");
    }

    if (!getFieldValue("lote")) {
        errors.push("Lote é obrigatório");
    }

    const comprimento = parseFloat(getFieldValue("comprimento"));
    if (!comprimento || comprimento <= 0) {
        errors.push("Comprimento deve ser maior que zero");
    }

    const largura = parseFloat(getFieldValue("largura"));
    if (!largura || largura <= 0) {
        errors.push("Largura deve ser maior que zero");
    }

    const qtdTramos = parseInt(getFieldValue("qtd-tramos"));
    if (!qtdTramos || qtdTramos <= 0) {
        errors.push("Quantidade de tramos deve ser maior que zero");
    }

    // Validar soma dos tramos
    const tramosFields = document.querySelectorAll(".tramo-field");
    let somaTramos = 0;
    tramosFields.forEach(field => {
        somaTramos += parseFloat(field.value) || 0;
    });

    if (Math.abs(somaTramos - comprimento) > 0.01) {
        warnings.push(`Soma dos tramos (${somaTramos.toFixed(2)}m) difere do comprimento total (${comprimento.toFixed(2)}m)`);
    }

    return {
        isValid: errors.length === 0,
        errors: errors,
        warnings: warnings
    };
}

/**
 * Função para gerar JSON com validação prévia
 */
function generateAndShowBridgeDataJSON() {
    const validation = validateBridgeData();

    if (!validation.isValid) {
        alert("Erros encontrados:\n\n" + validation.errors.join("\n"));
        return;
    }

    if (validation.warnings.length > 0) {
        const continuar = confirm("Avisos encontrados:\n\n" + validation.warnings.join("\n") + "\n\nDeseja continuar?");
        if (!continuar) {
            return;
        }
    }

    showBridgeDataJSON();
}

// Expor funções globalmente
window.generateBridgeDataJSON = generateBridgeDataJSON;
window.showBridgeDataJSON = showBridgeDataJSON;
window.copyBridgeDataJSON = copyBridgeDataJSON;
window.downloadBridgeDataJSON = downloadBridgeDataJSON;
window.generateAndShowBridgeDataJSON = generateAndShowBridgeDataJSON;





</script>
  

</body></html>