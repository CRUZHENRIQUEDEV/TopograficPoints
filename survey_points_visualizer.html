<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Analisador de Inclina√ß√µes - Tabuleiros de Ponte</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f5f5f5;
      }
      
      .container {
        background: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      }
      
      h1 {
        color: #333;
        text-align: center;
        margin-bottom: 10px;
      }
      
      .subtitle {
        text-align: center;
        color: #666;
        margin-bottom: 30px;
        font-size: 14px;
        padding: 10px;
        background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
        border-radius: 8px;
        border: 1px solid #2196f3;
      }
      
      .input-section {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 30px;
      }
      
      .csv-input {
        display: flex;
        flex-direction: column;
      }
      
      .csv-input label {
        font-weight: bold;
        margin-bottom: 10px;
        color: #333;
      }
      
      textarea {
        width: 100%;
        height: 200px;
        padding: 10px;
        border: 2px solid #ddd;
        border-radius: 5px;
        font-family: monospace;
        font-size: 12px;
        resize: vertical;
      }
      
      button {
        background: #007bff;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin: 10px 5px;
      }
      
      button:hover {
        background: #0056b3;
      }
      
      .controls {
        text-align: center;
        margin: 20px 0;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        gap: 10px;
      }
      
      .zoom-controls {
        display: flex;
        align-items: center;
        background: #f8f9fa;
        padding: 8px 15px;
        border-radius: 25px;
        border: 1px solid #dee2e6;
        margin-left: 20px;
        flex-wrap: wrap;
        gap: 5px;
      }
      
      @media (max-width: 768px) {
        .controls {
          flex-direction: column;
          gap: 15px;
        }
        
        .zoom-controls {
          margin-left: 0;
          width: 100%;
          justify-content: center;
        }
      }
      
      .zoom-controls button {
        margin: 0 5px;
        padding: 6px 10px;
        font-size: 14px;
        min-width: 40px;
      }
      
      #zoomLevel {
        margin: 0 15px;
        font-weight: bold;
        color: #495057;
        font-size: 14px;
        min-width: 80px;
        text-align: center;
      }
      
      .visualization {
        border: 2px solid #ddd;
        border-radius: 10px;
        background: white;
        min-height: 500px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 20px;
      }
      
      #canvas {
        border: 1px solid #ccc;
        background: #fafafa;
      }
      
      .info-panel {
        margin-top: 20px;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 5px;
        border-left: 4px solid #007bff;
      }
      
      .distance-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 12px;
        margin-top: 15px;
      }
      
      .distance-card {
        background: white;
        padding: 12px;
        border-radius: 5px;
        border: 1px solid #ddd;
        text-align: center;
        transition: transform 0.2s;
      }
      
      .distance-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      }
      
      .section-divider {
        grid-column: 1 / -1;
        height: 1px;
        background: linear-gradient(to right, transparent, #ddd, transparent);
        margin: 15px 0;
      }
      
      .distance-value {
        font-size: 18px;
        font-weight: bold;
        color: #007bff;
      }
      
      .elevation-value {
        font-size: 16px;
        font-weight: bold;
      }
      
      .inclination-value {
        font-size: 14px;
        font-weight: bold;
      }
      
      .cross-distance-card {
        background: linear-gradient(135deg, #fff3e0, #e8f5e8);
        border: 2px solid #ff9800;
      }
      
      .cross-distance-value {
        color: #ff9800;
      }
      
      .elevation-analysis-card {
        background: linear-gradient(135deg, #e8f5e8, #f3e5f5);
        border: 2px solid #4caf50;
      }
      
      .warning-card {
        background: linear-gradient(135deg, #fff3e0, #ffebee);
        border: 2px solid #ff5722;
      }
      
      .critical-warning-card {
        background: linear-gradient(135deg, #ffebee, #fce4ec);
        border: 3px solid #d32f2f;
        animation: pulse 2s infinite;
      }
      
      @keyframes pulse {
        0% { box-shadow: 0 0 0 0 rgba(211, 47, 47, 0.4); }
        70% { box-shadow: 0 0 0 10px rgba(211, 47, 47, 0); }
        100% { box-shadow: 0 0 0 0 rgba(211, 47, 47, 0); }
      }
      
      .good-card {
        background: linear-gradient(135deg, #e8f5e8, #f1f8e9);
        border: 2px solid #4caf50;
      }
      
      .acceptable-card {
        background: linear-gradient(135deg, #fff8e1, #f3e5f5);
        border: 2px solid #ff9800;
      }
      
      .error {
        color: #dc3545;
        background: #f8d7da;
        padding: 10px;
        border-radius: 5px;
        margin-top: 10px;
      }
      
      .csv-section {
        border: 1px solid #ddd;
        border-radius: 5px;
        padding: 15px;
        background: #fafafa;
      }
      
      .section-title {
        color: #007bff;
        font-size: 18px;
        margin-bottom: 10px;
        font-weight: bold;
      }
      
      .example-buttons {
        margin-top: 10px;
      }
      
      .example-btn {
        background: #28a745;
        font-size: 14px;
        padding: 8px 16px;
      }
      
      .example-btn:hover {
        background: #218838;
      }
      
      .cross-section {
        background: linear-gradient(135deg, #fff3e0, #e8f5e8);
        border: 2px solid #ff9800;
        margin: 20px 0 10px 0;
        grid-column: 1 / -1;
        text-align: center;
      }
      
      .structure-section {
        background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
        border: 2px solid #9c27b0;
        margin: 15px 0 5px 0;
        grid-column: 1 / -1;
        text-align: center;
      }
      
      .elevation-section {
        background: linear-gradient(135deg, #e8f5e8, #f3e5f5);
        border: 2px solid #4caf50;
        margin: 15px 0 5px 0;
        grid-column: 1 / -1;
        text-align: center;
      }
      
      .legend {
        margin: 10px 0;
        padding: 10px;
        background: #f8f9fa;
        border-radius: 5px;
        font-size: 12px;
      }
      
      .legend-item {
        display: inline-block;
        margin: 0 10px;
      }
      
      .legend-color {
        display: inline-block;
        width: 15px;
        height: 15px;
        border-radius: 3px;
        margin-right: 5px;
        vertical-align: middle;
      }

      .debug-info {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 5px;
        padding: 10px;
        margin: 10px 0;
        font-family: monospace;
        font-size: 12px;
        max-height: 200px;
        overflow-y: auto;
      }
      
      .limits-info {
        background: linear-gradient(135deg, #e3f2fd, #f8f9fa);
        border: 2px solid #1976d2;
        border-radius: 8px;
        padding: 15px;
        margin: 20px 0;
        text-align: center;
      }
      
      .limits-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
        margin-top: 10px;
      }
      
      .limit-item {
        background: white;
        padding: 10px;
        border-radius: 5px;
        border: 1px solid #1976d2;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üåâ Analisador de Inclina√ß√µes - Tabuleiros de Ponte</h1>
      <div class="subtitle">
        <strong>üìê Verifica√ß√£o de Conformidade T√©cnica</strong><br>
        Sistema de an√°lise autom√°tica de inclina√ß√µes transversais e longitudinais para tabuleiros de ponte
      </div>

      <!-- Informa√ß√µes dos Limites -->
      <div class="limits-info">
        <h3 style="margin: 0 0 10px 0; color: #1976d2;">üìè Limites T√©cnicos Recomendados para Inclina√ß√µes</h3>
        <div class="limits-grid">
          <div class="limit-item">
            <div style="font-weight: bold; color: #d32f2f;">üîÑ TRANSVERSAL (LD ‚Üî LE)</div>
            <div style="font-size: 18px; font-weight: bold; color: #d32f2f;">‚â§ 5,00%</div>
            <div style="font-size: 12px; color: #666;">Lado com lado no mesmo ponto</div>
            <div style="font-size: 11px; color: #999;">In√≠cio‚ÜîIn√≠cio | Final‚ÜîFinal</div>
          </div>
          <div class="limit-item">
            <div style="font-weight: bold; color: #ff9800;">‚ÜïÔ∏è LONGITUDINAL (In√≠cio ‚Üî Final)</div>
            <div style="font-size: 18px; font-weight: bold; color: #ff9800;">‚â§ 2,50%</div>
            <div style="font-size: 12px; color: #666;">Mesmo lado entre pontos</div>
            <div style="font-size: 11px; color: #999;">LD‚ÜîLD | LE‚ÜîLE</div>
          </div>
        </div>
        <div style="margin-top: 10px; font-size: 12px; color: #1976d2;">
          <strong>Nota:</strong> Valores baseados em boas pr√°ticas da engenharia de pontes<br>
          <strong>Regra de Verifica√ß√£o:</strong> Transversal = lado com lado no mesmo ponto | Longitudinal = mesmo lado entre pontos
        </div>
      </div>

      <div class="input-section">
        <!-- CSV 1 -->
        <div class="csv-section">
          <div class="section-title">üìç CSV 1 - Primeira Estrutura</div>
          <textarea
            id="csvData1"
            placeholder="Cole aqui os dados do primeiro CSV..."
          ></textarea>
          <div class="example-buttons">
            <button onclick="loadExample1()" class="example-btn">
              üìù Exemplo CSV 1
            </button>
          </div>
        </div>

        <!-- CSV 2 -->
        <div class="csv-section">
          <div class="section-title">üìç CSV 2 - Segunda Estrutura</div>
          <textarea
            id="csvData2"
            placeholder="Cole aqui os dados do segundo CSV (opcional)..."
          ></textarea>
          <div class="example-buttons">
            <button onclick="loadExample2()" class="example-btn">
              üìù Exemplo CSV 2
            </button>
          </div>
        </div>
      </div>

      <div class="controls">
        <button onclick="processData()">üîÑ Processar e Analisar</button>
        <button onclick="clearAll()" style="background: #dc3545;">
          üóëÔ∏è Limpar Tudo
        </button>
        <div class="zoom-controls">
          <button onclick="zoomOut()" style="background: #6c757d;">
            üîç-
          </button>
          <span id="zoomLevel">Zoom: 200%</span>
          <button onclick="zoomIn()" style="background: #6c757d;">
            üîç+
          </button>
          <button onclick="resetZoom()" style="background: #17a2b8; margin-left: 10px;">
            ‚Üª Reset
          </button>
          <button onclick="rotate45()" style="background: #28a745; margin-left: 15px;">
            üîÑ Rotacionar 22.5¬∞
          </button>
        </div>
      </div>

      <div class="legend">
        <strong>üé® Legenda de Cores (Eleva√ß√£o):</strong>
        <div class="legend-item">
          <span class="legend-color" style="background: #4caf50;"></span>
          <span>Eleva√ß√£o Baixa</span>
        </div>
        <div class="legend-item">
          <span class="legend-color" style="background: #ffeb3b;"></span>
          <span>Eleva√ß√£o M√©dia</span>
        </div>
        <div class="legend-item">
          <span class="legend-color" style="background: #ff9800;"></span>
          <span>Eleva√ß√£o Alta</span>
        </div>
        <div class="legend-item">
          <span class="legend-color" style="background: #f44336;"></span>
          <span>Eleva√ß√£o Muito Alta</span>
        </div>
        <br>
        <strong>üìè Informa√ß√µes dos Pontos:</strong>
        <span>Glob = Eleva√ß√£o Global | Rel = Eleva√ß√£o Relativa ao ponto mais alto (0,00m)</span>
        <br>
        <strong>üìã Formatos Suportados:</strong>
        <span>LAT/LONG | H_ORTHO ou H_ORTO | M√∫ltiplos formatos CSV</span>
      </div>

      <div class="visualization">
        <canvas id="canvas" width="1100" height="800"></canvas>
      </div>

      <div id="infoPanel" class="info-panel" style="display: none">
        <h3>üìä Relat√≥rio de An√°lise T√©cnica - Inclina√ß√µes</h3>
        <div id="distanceInfo" class="distance-grid"></div>
        
        <!-- Resumo Executivo -->
        <div id="executiveSummary" style="margin-top: 20px; padding: 15px; background: linear-gradient(135deg, #f8f9fa, #e9ecef); border-radius: 8px; border-left: 4px solid #007bff;"></div>
      </div>

      <div id="errorMsg"></div>
      <div id="debugInfo" class="debug-info" style="display: none;"></div>
    </div>

    <script>
      // Vari√°veis globais para zoom, dados e rota√ß√£o
      let currentZoom = 2.0; // Zoom padr√£o 200%
      let currentPoints1 = {};
      let currentPoints2 = {};
      let currentRotation = 0; // Rota√ß√£o em graus
      
      // Limites t√©cnicos
      const LIMIT_TRANSVERSAL = 5.0; // 5%
      const LIMIT_LONGITUDINAL = 2.5; // 2.5%
      
      function debugLog(message) {
        console.log(message);
        const debugDiv = document.getElementById('debugInfo');
        if (debugDiv) {
          debugDiv.innerHTML += message + '<br>';
          debugDiv.style.display = 'block';
        }
      }
      
      function loadExample1() {
        const exampleData1 = `Name,Code,Lat,Long,H_GEO,H_ORTO,x,y
"05",JUSESQ,-9.8976347800,-36.4167136000,188.80925,197.1262098000,-36.4167136710,-9.8976347823
"06",JUSDIR,-9.8975431900,-36.4167583000,189.01495,197.3316011000,-36.4167583598,-9.8975431976
P-04,LD_FINAL_OAE,-9.8974730300,-36.4166092000,188.93670,197.2531865000,-36.4166092614,-9.8974730373
P-03,LE_FINAL_OAE,-9.8975631400,-36.4165642000,188.78735,197.1041407000,-36.4165642134,-9.8975631483
P-01,LE_INICIO_OAE,-9.8975029500,-36.4164419000,188.77963,197.0962773000,-36.4164419708,-9.8975029554
P-02,LD_INICIO_OAE,-9.8974121600,-36.4164865000,188.99719,197.3135310000,-36.4164865650,-9.8974121660
"07",MONDIR,-9.8972934700,-36.4162403000,188.86808,197.1841401000,-36.4162403921,-9.8972934728
"08",MONESQ,-9.8973829800,-36.4161912000,188.66533,196.9816940000,-36.4161912260,-9.8973829816`;

        document.getElementById('csvData1').value = exampleData1;
        processData();
      }

      function loadExample2() {
        const exampleData2 = `Name,Code,LAT,LONG,H_GEO,OND_GEOIDAL,H_ORTHO
P-03,LE_FINAL_OAE,-9.5859031742,-35.9998403261,64.15077,-8.34781878249589,72.4985887825
P-04,LD_FINAL_OAE,-9.5858035005,-35.9998555991,65.02932,-8.34729391104167,73.3766139110
P-02,LD_INICIO_OAE,-9.5857831989,-35.9997202172,65.13386,-8.34760639575098,73.4814663958
P-01,LE_INICIO_OAE,-9.5858827982,-35.9997040603,64.19835,-8.34813373922375,72.5464837392
P-05,JUSDIR,-9.5859092793,-36.0002888500,64.13941,-8.34648921628544,72.4858992163
P-06,JUSDIR,-9.5860060249,-36.0002554090,63.39445,-8.34705462681217,71.7415046268
P-07,MONT DIR,-9.5858598116,-35.9994324627,64.59709,-8.34884602273111,72.9459360227
P-08,MONT DIR1,-9.5857541640,-35.9994383212,65.48179,-8.34832048405044,73.8301104841`;

        document.getElementById('csvData2').value = exampleData2;
        processData();
      }

      // Fun√ß√µes de zoom
      function zoomIn() {
        currentZoom = Math.min(currentZoom * 1.2, 100.0); // Zoom m√°ximo 10000%
        updateZoomDisplay();
        redrawVisualization();
      }
      
      function zoomOut() {
        currentZoom = Math.max(currentZoom / 1.2, 0.1); // Zoom m√≠nimo 10%
        updateZoomDisplay();
        redrawVisualization();
      }
      
      function resetZoom() {
        currentZoom = 2.0; // Reset para zoom padr√£o 200%
        updateZoomDisplay();
        redrawVisualization();
      }
      
      function updateZoomDisplay() {
        const zoomPercent = Math.round(currentZoom * 100);
        document.getElementById('zoomLevel').textContent = `Zoom: ${zoomPercent}%`;
      }
      
      // Fun√ß√£o de rota√ß√£o
      function rotate45() {
        currentRotation = (currentRotation + 22.5) % 360;
        redrawVisualization();
      }
      
      function redrawVisualization() {
        if (Object.keys(currentPoints1).length > 0) {
          drawVisualization(currentPoints1, currentPoints2);
        }
      }

      function clearAll() {
        document.getElementById('csvData1').value = '';
        document.getElementById('csvData2').value = '';
        document.getElementById('infoPanel').style.display = 'none';
        document.getElementById('errorMsg').innerHTML = '';
        document.getElementById('debugInfo').innerHTML = '';
        document.getElementById('debugInfo').style.display = 'none';
        
        currentZoom = 2.0;
        currentRotation = 0;
        currentPoints1 = {};
        currentPoints2 = {};
        updateZoomDisplay();
        
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      function parseCSV(csvText) {
        if (!csvText.trim()) return [];
        
        debugLog("=== INICIANDO PARSE CSV ===");
        const lines = csvText.trim().split("\n");
        debugLog(`Total de linhas: ${lines.length}`);
        
        const firstLine = lines[0];
        debugLog(`Primeira linha: ${firstLine}`);
        
        let headers;
        let dataStartIndex = 0;

        // Detectar se a primeira linha cont√©m cabe√ßalhos
        const commonHeaders = ["Name", "Code", "Lat", "LAT", "Long", "LONG", "x", "y", "H_ORTO", "H_ORTHO", "H_GEO"];
        const hasHeaders = commonHeaders.some(header => firstLine.includes(header));
        
        if (hasHeaders) {
          headers = lines[0].split(",").map((h) => h.trim().replace(/"/g, ''));
          dataStartIndex = 1;
          debugLog(`Cabe√ßalhos detectados: ${headers.join(', ')}`);
        } else {
          headers = ["Name", "Code", "LAT", "LONG", "H_GEO", "OND_GEOIDAL", "H_ORTHO"];
          dataStartIndex = 0;
          debugLog("Usando cabe√ßalhos padr√£o");
        }

        const data = [];
        for (let i = dataStartIndex; i < lines.length; i++) {
          if (lines[i].trim() === "") continue;

          const values = lines[i].split(",");
          const row = {};
          headers.forEach((header, index) => {
            row[header] = values[index]?.trim().replace(/"/g, '') || "";
          });
          data.push(row);
          debugLog(`Linha ${i}: ${JSON.stringify(row)}`);
        }
        
        debugLog(`Total de linhas processadas: ${data.length}`);
        return data;
      }

      function calculateDistance(point1, point2) {
        const x1 = parseFloat(point1.x);
        const y1 = parseFloat(point1.y);
        const x2 = parseFloat(point2.x);
        const y2 = parseFloat(point2.y);

        const deltaX = x2 - x1;
        const deltaY = y2 - y1;

        let distance;

        if ((point1.coordType === 'UTM' && point2.coordType === 'UTM') || 
            (point1.coordType === 'PLANE' && point2.coordType === 'PLANE')) {
          distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        } 
        else if ((point1.coordType === 'GEO' && point2.coordType === 'GEO') ||
                 (Math.abs(x1) < 180 && Math.abs(y1) < 90 && Math.abs(x2) < 180 && Math.abs(y2) < 90)) {
          const lat1Rad = (y1 * Math.PI) / 180;
          const lat2Rad = (y2 * Math.PI) / 180;
          const avgLatRad = (lat1Rad + lat2Rad) / 2;

          const deltaLatM = deltaY * 111320;
          const deltaLonM = deltaX * 111320 * Math.cos(avgLatRad);

          distance = Math.sqrt(deltaLatM * deltaLatM + deltaLonM * deltaLonM);
        }
        else {
          distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        }

        return distance;
      }

      function calculateElevationDifference(point1, point2) {
        const elev1 = parseFloat(point1.elevation);
        const elev2 = parseFloat(point2.elevation);
        return elev2 - elev1;
      }

      function calculateInclination(point1, point2) {
        const distance = calculateDistance(point1, point2);
        const elevationDiff = calculateElevationDifference(point1, point2);
        
        if (distance === 0) return { percentage: 0, degrees: 0, ratio: "0:1" };
        
        const percentage = (Math.abs(elevationDiff) / distance) * 100;
        const degrees = Math.atan(Math.abs(elevationDiff) / distance) * (180 / Math.PI);
        const ratio = `1:${(distance / Math.abs(elevationDiff)).toFixed(1)}`;
        
        return { 
          percentage: percentage, 
          degrees: degrees, 
          ratio: ratio,
          direction: elevationDiff > 0 ? "‚ÜóÔ∏è Subida" : elevationDiff < 0 ? "‚ÜòÔ∏è Descida" : "‚û°Ô∏è Nivelado"
        };
      }

      function getElevationColor(elevation, minElev, maxElev) {
        const normalized = (elevation - minElev) / (maxElev - minElev);
        
        if (normalized < 0.25) return "#4caf50"; // Verde - baixo
        else if (normalized < 0.5) return "#ffeb3b"; // Amarelo - m√©dio
        else if (normalized < 0.75) return "#ff9800"; // Laranja - alto
        else return "#f44336"; // Vermelho - muito alto
      }

      function findPoints(data) {
        debugLog("=== PROCURANDO PONTOS ===");
        const points = {};
        
        data.forEach((row, index) => {
          debugLog(`Processando linha ${index}: ${JSON.stringify(row)}`);
          
          const name = row.Name || row.Code || "";
          const code = row.Code || row.Name || "";

          debugLog(`Nome: ${name}, C√≥digo: ${code}`);

          // Verificar se √© um ponto de estrutura (OAE)
          const isStructurePoint = 
            code.includes("LD_INICIO_OAE") ||
            code.includes("LE_INICIO_OAE") ||
            code.includes("LD_FINAL_OAE") ||
            code.includes("LE_FINAL_OAE") ||
            name.includes("LD_INICIO_OAE") ||
            name.includes("LE_INICIO_OAE") ||
            name.includes("LD_FINAL_OAE") ||
            name.includes("LE_FINAL_OAE");

          if (isStructurePoint) {
            debugLog(`Ponto de estrutura encontrado: ${name || code}`);
            
            let xCoord, yCoord, elevation;

            // Coordenadas
            if (row.Northing && row.Easting) {
              xCoord = parseFloat(row.Easting);
              yCoord = parseFloat(row.Northing);
            }
            else if (row.x && row.y) {
              xCoord = parseFloat(row.x);
              yCoord = parseFloat(row.y);
            }
            else if (row.Long || row.LONG) {
              xCoord = parseFloat(row.Long || row.LONG);
              yCoord = parseFloat(row.Lat || row.LAT);
            }

            // Eleva√ß√£o - suporte para H_ORTHO e H_ORTO
            elevation = parseFloat(row.H_ORTHO) || 
                       parseFloat(row.H_ORTO) || 
                       parseFloat(row.Elevation) || 
                       parseFloat(row.H_GEO) || 
                       parseFloat(row.Altura) || 
                       parseFloat(row.Z) || 0;

            debugLog(`Coordenadas: x=${xCoord}, y=${yCoord}, eleva√ß√£o=${elevation}`);

            if (!isNaN(xCoord) && !isNaN(yCoord) && !isNaN(elevation)) {
              const pointData = {
                x: xCoord,
                y: yCoord,
                elevation: elevation,
                lat: parseFloat(row.Lat || row.LAT) || yCoord,
                long: parseFloat(row.Long || row.LONG) || xCoord,
                easting: parseFloat(row.Easting) || xCoord,
                northing: parseFloat(row.Northing) || yCoord,
                name: name || code,
                code: code || name,
                originalName: name,
                originalCode: code,
                coordType: row.Northing && row.Easting ? 'UTM' : (Math.abs(xCoord) < 180 && Math.abs(yCoord) < 90 ? 'GEO' : 'PLANE')
              };
              
              debugLog(`Ponto criado: ${JSON.stringify(pointData)}`);
              
              if (code) points[code] = pointData;
              if (name && name !== code) points[name] = pointData;
            } else {
              debugLog(`Erro: coordenadas ou eleva√ß√£o inv√°lidas`);
            }
          }
        });
        
        debugLog(`Total de pontos encontrados: ${Object.keys(points).length}`);
        debugLog(`Pontos: ${Object.keys(points).join(', ')}`);
        return points;
      }

      // Fun√ß√£o para determinar se inclina√ß√µes s√£o problem√°ticas (com novos limites)
      function getInclinationStatus(inclination, isTransversal = false) {
        const limit = isTransversal ? LIMIT_TRANSVERSAL : LIMIT_LONGITUDINAL;
        
        if (inclination.percentage > limit) {
          return { 
            class: "critical-warning-card", 
            icon: "üö®", 
            text: `ACIMA DO LIMITE (>${limit}%)`,
            color: "#d32f2f"
          };
        } else if (inclination.percentage > limit * 0.8) {
          return { 
            class: "warning-card", 
            icon: "‚ö†Ô∏è", 
            text: `Pr√≥ximo ao Limite (${(limit * 0.8).toFixed(1)}-${limit}%)`,
            color: "#ff5722"
          };
        } else if (inclination.percentage > limit * 0.5) {
          return { 
            class: "acceptable-card", 
            icon: "üî∂", 
            text: `Moderada (${(limit * 0.5).toFixed(1)}-${(limit * 0.8).toFixed(1)}%)`,
            color: "#ff9800"
          };
        } else {
          return { 
            class: "good-card", 
            icon: "‚úÖ", 
            text: `Dentro do Limite (<${(limit * 0.5).toFixed(1)}%)`,
            color: "#4caf50"
          };
        }
      }

      function drawVisualization(points1, points2 = {}) {
        debugLog("=== INICIANDO DESENHO ===");
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        let allStructurePoints = [];
        
        if (Object.keys(points1).length > 0) {
          allStructurePoints = allStructurePoints.concat(Object.values(points1));
        }
        
        if (Object.keys(points2).length > 0) {
          allStructurePoints = allStructurePoints.concat(Object.values(points2));
        }
        
        debugLog(`Total pontos para desenhar: ${allStructurePoints.length}`);
        
        if (allStructurePoints.length === 0) {
          debugLog("ERRO: Nenhum ponto para desenhar");
          return;
        }

        // Calcular min/max para coordenadas
        const minX = Math.min(...allStructurePoints.map((p) => p.x));
        const maxX = Math.max(...allStructurePoints.map((p) => p.x));
        const minY = Math.min(...allStructurePoints.map((p) => p.y));
        const maxY = Math.max(...allStructurePoints.map((p) => p.y));
        
        const minElev = Math.min(...allStructurePoints.map((p) => p.elevation));
        const maxElev = Math.max(...allStructurePoints.map((p) => p.elevation));
        
        debugLog(`Coordenadas - X: ${minX} a ${maxX}, Y: ${minY} a ${maxY}`);
        debugLog(`Eleva√ß√µes - Min: ${minElev}, Max: ${maxElev}`);

        const margin = 120;
        
        const dataRangeX = maxX - minX;
        const dataRangeY = maxY - minY;
        
        const rotationRad = (currentRotation * Math.PI) / 180;
        const cosTheta = Math.abs(Math.cos(rotationRad));
        const sinTheta = Math.abs(Math.sin(rotationRad));
        
        const effectiveWidth = dataRangeX * cosTheta + dataRangeY * sinTheta;
        const effectiveHeight = dataRangeX * sinTheta + dataRangeY * cosTheta;
        
        const scaleX = (canvas.width - 2 * margin) / effectiveWidth;
        const scaleY = (canvas.height - 2 * margin) / effectiveHeight;
        const scaleFactor = Object.keys(points2).length > 0 ? 0.3 : 0.5;
        const scale = Math.min(scaleX, scaleY) * scaleFactor * currentZoom;

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        function toCanvasCoords(point) {
          const relX = point.x - (minX + maxX) / 2;
          const relY = point.y - (minY + maxY) / 2;
          
          const rotationRad = (currentRotation * Math.PI) / 180;
          const cosTheta = Math.cos(rotationRad);
          const sinTheta = Math.sin(rotationRad);
          
          const rotatedX = relX * cosTheta - relY * sinTheta;
          const rotatedY = relX * sinTheta + relY * cosTheta;
          
          return {
            x: centerX + rotatedX * scale,
            y: centerY - rotatedY * scale,
          };
        }

        function drawStructure(points, color, label) {
          debugLog(`Desenhando estrutura ${label}`);
          
          const ldInicio = Object.values(points).find(p => 
            p.code.includes("LD_INICIO_OAE") || 
            p.name.includes("LD_INICIO_OAE") ||
            p.originalCode.includes("LD_INICIO_OAE") ||
            p.originalName.includes("LD_INICIO_OAE")
          );
          
          const leInicio = Object.values(points).find(p => 
            p.code.includes("LE_INICIO_OAE") || 
            p.name.includes("LE_INICIO_OAE") ||
            p.originalCode.includes("LE_INICIO_OAE") ||
            p.originalName.includes("LE_INICIO_OAE")
          );
          
          const ldFinal = Object.values(points).find(p => 
            p.code.includes("LD_FINAL_OAE") || 
            p.name.includes("LD_FINAL_OAE") ||
            p.originalCode.includes("LD_FINAL_OAE") ||
            p.originalName.includes("LD_FINAL_OAE")
          );
          
          const leFinal = Object.values(points).find(p => 
            p.code.includes("LE_FINAL_OAE") || 
            p.name.includes("LE_FINAL_OAE") ||
            p.originalCode.includes("LE_FINAL_OAE") ||
            p.originalName.includes("LE_FINAL_OAE")
          );

          debugLog(`Pontos encontrados - LD In√≠cio: ${!!ldInicio}, LE In√≠cio: ${!!leInicio}, LD Final: ${!!ldFinal}, LE Final: ${!!leFinal}`);

          if (!ldInicio || !leInicio || !ldFinal || !leFinal) {
            debugLog("ERRO: Nem todos os pontos da estrutura foram encontrados");
            return null;
          }

          const ldInicioCanvas = toCanvasCoords(ldInicio);
          const leInicioCanvas = toCanvasCoords(leInicio);
          const ldFinalCanvas = toCanvasCoords(ldFinal);
          const leFinalCanvas = toCanvasCoords(leFinal);

          // Desenhar ret√¢ngulo
          ctx.strokeStyle = color;
          const rectLineWidth = Math.max(1, Math.min(4, 2 * Math.sqrt(currentZoom)));
          ctx.lineWidth = rectLineWidth;
          ctx.beginPath();
          ctx.moveTo(ldInicioCanvas.x, ldInicioCanvas.y);
          ctx.lineTo(leInicioCanvas.x, leInicioCanvas.y);
          ctx.lineTo(leFinalCanvas.x, leFinalCanvas.y);
          ctx.lineTo(ldFinalCanvas.x, ldFinalCanvas.y);
          ctx.closePath();
          ctx.stroke();

          // Preencher ret√¢ngulo com transpar√™ncia
          const alpha = color === "#007bff" ? "0.08" : "0.04";
          ctx.fillStyle = color.replace("rgb", "rgba").replace(")", `, ${alpha})`);
          if (color.startsWith("#")) {
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
          }
          ctx.fill();

          // Desenhar pontos com cores baseadas na eleva√ß√£o
          const pointData = [
            { point: ldInicio, canvas: ldInicioCanvas, baseColor: "#dc3545", label: `LD IN√çCIO ${label}` },
            { point: leInicio, canvas: leInicioCanvas, baseColor: "#28a745", label: `LE IN√çCIO ${label}` },
            { point: ldFinal, canvas: ldFinalCanvas, baseColor: "#dc3545", label: `LD FINAL ${label}` },
            { point: leFinal, canvas: leFinalCanvas, baseColor: "#28a745", label: `LE FINAL ${label}` },
          ];

          pointData.forEach(({ point, canvas, baseColor, label }) => {
            const elevationColor = getElevationColor(point.elevation, minElev, maxElev);
            
            ctx.fillStyle = baseColor;
            ctx.beginPath();
            const pointRadius = Math.max(2, Math.min(8, 4 * Math.sqrt(currentZoom)));
            ctx.arc(canvas.x, canvas.y, pointRadius, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = elevationColor;
            ctx.beginPath();
            ctx.arc(canvas.x, canvas.y, pointRadius * 0.7, 0, 2 * Math.PI);
            ctx.fill();

            const zoomFactor = Math.max(0.3, Math.min(2.0, 2.0 / Math.sqrt(currentZoom)));
            
            ctx.fillStyle = "#333";
            const fontSize = Math.max(4, 12 * zoomFactor);
            ctx.font = `${fontSize}px Arial`;
            ctx.textAlign = "center";
            const labelOffset = Math.max(4, 15 * zoomFactor);
            ctx.fillText(label, canvas.x, canvas.y - labelOffset);
            
            const relativeElev = point.elevation - maxElev;
            
            const elevFontSize = Math.max(3, 9 * zoomFactor);
            ctx.font = `${elevFontSize}px Arial`;
            
            ctx.fillStyle = "#555";
            const elevOffset1 = Math.max(2, 8 * zoomFactor);
            const elevOffset2 = Math.max(4, 16 * zoomFactor);
            ctx.fillText(`Glob: ${point.elevation.toFixed(3)}m`, canvas.x, canvas.y + labelOffset + elevOffset1);
            
            if (Math.abs(relativeElev) < 0.001) {
              ctx.fillStyle = "#ff0000";
              ctx.font = `bold ${elevFontSize}px Arial`;
            } else {
              ctx.fillStyle = "#666";
              ctx.font = `${elevFontSize}px Arial`;
            }
            
            ctx.fillText(`Rel: ${relativeElev.toFixed(3)}m`, canvas.x, canvas.y + labelOffset + elevOffset2);
          });

          return { ldInicio, leInicio, ldFinal, leFinal };
        }

        const struct1 = drawStructure(points1, "#007bff", "(1)");
        const struct2 = Object.keys(points2).length > 0 ? drawStructure(points2, "#e91e63", "(2)") : null;

        // Desenhar linha de conex√£o
        if (struct1 && struct2) {
          const leInicio1Canvas = toCanvasCoords(struct1.leInicio);
          const ldInicio2Canvas = toCanvasCoords(struct2.ldInicio);

          ctx.strokeStyle = "#ff9800";
          const lineWidth = Math.max(1, Math.min(6, 3 * Math.sqrt(currentZoom)));
          ctx.lineWidth = lineWidth;
          const dashLength = Math.max(4, Math.min(20, 12 * Math.sqrt(currentZoom)));
          ctx.setLineDash([dashLength, dashLength/2]);
          ctx.beginPath();
          ctx.moveTo(leInicio1Canvas.x, leInicio1Canvas.y);
          ctx.lineTo(ldInicio2Canvas.x, ldInicio2Canvas.y);
          ctx.stroke();
          ctx.setLineDash([]);

          const zoomFactor = Math.max(0.3, Math.min(2.0, 2.0 / Math.sqrt(currentZoom)));
          const offsetDistance = Math.max(40, Math.min(150, 80 * Math.sqrt(currentZoom)));
          
          const rotationRad = (currentRotation * Math.PI) / 180;
          const offsetX = offsetDistance * Math.cos(-rotationRad);
          const offsetY = offsetDistance * Math.sin(-rotationRad);
          
          const midX = (leInicio1Canvas.x + ldInicio2Canvas.x) / 2 + offsetX;
          const midY = (leInicio1Canvas.y + ldInicio2Canvas.y) / 2 + offsetY;
          const crossDistance = calculateDistance(struct1.leInicio, struct2.ldInicio);
          
          const textWidth = Math.max(60, 110 * zoomFactor);
          const textHeight = Math.max(20, 35 * zoomFactor);
          ctx.fillStyle = "rgba(255, 255, 255, 0.95)";
          ctx.fillRect(midX - textWidth/2, midY - textHeight/2, textWidth, textHeight);
          
          ctx.strokeStyle = "#ff9800";
          ctx.lineWidth = 1;
          ctx.strokeRect(midX - textWidth/2, midY - textHeight/2, textWidth, textHeight);
          
          ctx.fillStyle = "#ff9800";
          const crossFontSize = Math.max(6, 18 * zoomFactor);
          ctx.font = `bold ${crossFontSize}px Arial`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(`${crossDistance.toFixed(3)}m`, midX, midY);
        }

        debugLog("Desenho conclu√≠do, chamando showDistanceInfo");
        showDistanceInfo(struct1, struct2);
      }

      function showDistanceInfo(struct1, struct2) {
        debugLog("=== GERANDO RELAT√ìRIO DE CONFORMIDADE ===");
        const infoPanel = document.getElementById("infoPanel");
        const distanceInfo = document.getElementById("distanceInfo");

        if (!struct1) {
          debugLog("ERRO: struct1 √© null, n√£o √© poss√≠vel gerar relat√≥rio");
          return;
        }

        let html = '';

        // C√°lculos estrutura 1
        const dist1Inicio = calculateDistance(struct1.ldInicio, struct1.leInicio);
        const dist1Final = calculateDistance(struct1.ldFinal, struct1.leFinal);
        const dist1LD = calculateDistance(struct1.ldInicio, struct1.ldFinal);
        const dist1LE = calculateDistance(struct1.leInicio, struct1.leFinal);
        const media1Largura = (dist1Inicio + dist1Final) / 2;
        const media1Comprimento = (dist1LD + dist1LE) / 2;

        // AN√ÅLISES DE ELEVA√á√ÉO ESTRUTURA 1
        const elev1_LD_LE_Inicio = calculateElevationDifference(struct1.ldInicio, struct1.leInicio);
        const elev1_LD_LE_Final = calculateElevationDifference(struct1.ldFinal, struct1.leFinal);
        const elev1_Inicio_Final_LD = calculateElevationDifference(struct1.ldInicio, struct1.ldFinal);
        const elev1_Inicio_Final_LE = calculateElevationDifference(struct1.leInicio, struct1.leFinal);

        // INCLINA√á√ïES ESTRUTURA 1
        const incl1_LD_LE_Inicio = calculateInclination(struct1.ldInicio, struct1.leInicio);
        const incl1_LD_LE_Final = calculateInclination(struct1.ldFinal, struct1.leFinal);
        const incl1_Inicio_Final_LD = calculateInclination(struct1.ldInicio, struct1.ldFinal);
        const incl1_Inicio_Final_LE = calculateInclination(struct1.leInicio, struct1.leFinal);

        // AN√ÅLISE COMPARATIVA PRIMEIRO se tiver 2 estruturas
        if (struct2) {
          const dist2Inicio = calculateDistance(struct2.ldInicio, struct2.leInicio);
          const dist2Final = calculateDistance(struct2.ldFinal, struct2.leFinal);
          const dist2LD = calculateDistance(struct2.ldInicio, struct2.ldFinal);
          const dist2LE = calculateDistance(struct2.leInicio, struct2.leFinal);
          const media2Largura = (dist2Inicio + dist2Final) / 2;
          const media2Comprimento = (dist2LD + dist2LE) / 2;

          // AN√ÅLISES ENTRE ESTRUTURAS
          const crossDistance = calculateDistance(struct1.leInicio, struct2.ldInicio);
          const crossElevation = calculateElevationDifference(struct1.leInicio, struct2.ldInicio);
          const crossInclination = calculateInclination(struct1.leInicio, struct2.ldInicio);
          
          // An√°lises comparativas
          const diferencaLargura = Math.abs(media1Largura - media2Largura);
          const diferencaComprimento = Math.abs(media1Comprimento - media2Comprimento);
          
          // M√©dias gerais entre as duas estruturas
          const mediaGeralLargura = (media1Largura + media2Largura) / 2;
          const mediaGeralComprimento = (media1Comprimento + media2Comprimento) / 2;

          // C√°lculos estrutura 2 para eleva√ß√£o
          const elev2_LD_LE_Inicio = calculateElevationDifference(struct2.ldInicio, struct2.leInicio);
          const elev2_LD_LE_Final = calculateElevationDifference(struct2.ldFinal, struct2.leFinal);
          const elev2_Inicio_Final_LD = calculateElevationDifference(struct2.ldInicio, struct2.ldFinal);
          const elev2_Inicio_Final_LE = calculateElevationDifference(struct2.leInicio, struct2.leFinal);

          const incl2_LD_LE_Inicio = calculateInclination(struct2.ldInicio, struct2.leInicio);
          const incl2_LD_LE_Final = calculateInclination(struct2.ldFinal, struct2.leFinal);
          const incl2_Inicio_Final_LD = calculateInclination(struct2.ldInicio, struct2.ldFinal);
          const incl2_Inicio_Final_LE = calculateInclination(struct2.leInicio, struct2.leFinal);

          // Calcular dist√¢ncias X e Y
          let deltaX = 0;
          let deltaY = 0;
          
          if (struct1.leInicio && struct2.ldInicio) {
            const x1 = parseFloat(struct1.leInicio.x);
            const y1 = parseFloat(struct1.leInicio.y);
            const x2 = parseFloat(struct2.ldInicio.x);
            const y2 = parseFloat(struct2.ldInicio.y);
            
            if (!isNaN(x1) && !isNaN(y1) && !isNaN(x2) && !isNaN(y2)) {
              deltaX = Math.abs(x2 - x1);
              deltaY = Math.abs(y2 - y1);
              
              if ((struct1.leInicio.coordType === 'UTM' && struct2.ldInicio.coordType === 'UTM') || 
                  (struct1.leInicio.coordType === 'PLANE' && struct2.ldInicio.coordType === 'PLANE')) {
                // deltaX e deltaY j√° est√£o em metros
              }
              else if ((struct1.leInicio.coordType === 'GEO' && struct2.ldInicio.coordType === 'GEO') ||
                       (Math.abs(x1) < 180 && Math.abs(y1) < 90 && Math.abs(x2) < 180 && Math.abs(y2) < 90)) {
                const avgLatRad = ((y1 + y2) / 2 * Math.PI) / 180;
                deltaX = deltaX * 111320 * Math.cos(avgLatRad);
                deltaY = deltaY * 111320;
              }
            }
          }
          
          // Status da inclina√ß√£o entre estruturas (considerar como longitudinal)
          const crossStatus = getInclinationStatus(crossInclination, false);
          
          html += `
            <div class="distance-card cross-section">
              <div><strong>üîç AN√ÅLISE COMPARATIVA ENTRE ESTRUTURAS</strong></div>
            </div>
            <div class="distance-card cross-distance-card">
              <div><strong>üåâ Dist√¢ncia Entre Estruturas</strong></div>
              <div class="distance-value cross-distance-value">${crossDistance.toFixed(3)} m</div>
              <small>LE_IN√çCIO (1) ‚Üî LD_IN√çCIO (2)</small>
            </div>
            <div class="distance-card elevation-analysis-card">
              <div><strong>üìè Diferen√ßa de Eleva√ß√£o</strong></div>
              <div class="elevation-value" style="color: ${crossElevation >= 0 ? '#4caf50' : '#f44336'};">${crossElevation >= 0 ? '+' : ''}${crossElevation.toFixed(3)} m</div>
              <small>Entre estruturas (LE1‚ÜíLD2)</small>
            </div>
            <div class="distance-card ${crossStatus.class}">
              <div><strong>${crossStatus.icon} Inclina√ß√£o Entre Estruturas</strong></div>
              <div class="inclination-value" style="color: ${crossStatus.color};">${crossInclination.percentage.toFixed(2)}% (${crossInclination.degrees.toFixed(1)}¬∞)</div>
              <small>${crossInclination.direction} - ${crossStatus.text}</small>
              <div style="font-size: 11px; margin-top: 5px; color: #666;">Limite longitudinal: ‚â§${LIMIT_LONGITUDINAL}%</div>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #f8f9fa, #e9ecef); border: 2px solid #6c757d;">
              <div><strong>üìê Dist√¢ncia em X</strong></div>
              <div class="distance-value" style="color: #6c757d;">${deltaX.toFixed(3)} m</div>
              <small>Diferen√ßa horizontal</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #f8f9fa, #e9ecef); border: 2px solid #6c757d;">
              <div><strong>üìê Dist√¢ncia em Y</strong></div>
              <div class="distance-value" style="color: #6c757d;">${deltaY.toFixed(3)} m</div>
              <small>Diferen√ßa vertical</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #e3f2fd, #f3e5f5); border: 2px solid #9c27b0;">
              <div><strong>üìè M√©dia Geral Largura</strong></div>
              <div class="distance-value" style="color: #9c27b0;">${mediaGeralLargura.toFixed(3)} m</div>
              <small>(Est.1 + Est.2) √∑ 2</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #e8f5e8, #fff3e0); border: 2px solid #ff9800;">
              <div><strong>üìê M√©dia Geral Comprimento</strong></div>
              <div class="distance-value" style="color: #ff9800;">${mediaGeralComprimento.toFixed(3)} m</div>
              <small>(Est.1 + Est.2) √∑ 2</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #ffebee, #f3e5f5); border: 2px solid #e91e63;">
              <div><strong>Diferen√ßa de Larguras</strong></div>
              <div class="distance-value" style="color: #e91e63;">${diferencaLargura.toFixed(3)} m</div>
              <small>|Estrutura 1 - Estrutura 2|</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #e8f5e8, #e0f2f1); border: 2px solid #4caf50;">
              <div><strong>Diferen√ßa de Comprimentos</strong></div>
              <div class="distance-value" style="color: #4caf50;">${diferencaComprimento.toFixed(3)} m</div>
              <small>|Estrutura 1 - Estrutura 2|</small>
            </div>
          `;
        }

        // ESTRUTURA 1 - DIST√ÇNCIAS E ELEVA√á√ïES
        html += `
          <div class="section-divider"></div>
          <div class="distance-card structure-section">
            <div><strong>üèóÔ∏è ESTRUTURA 1 (AZUL) - Dimens√µes</strong></div>
          </div>
          <div class="distance-card">
            <div><strong>Largura In√≠cio</strong></div>
            <div class="distance-value">${dist1Inicio.toFixed(3)} m</div>
            <small>LD_IN√çCIO ‚Üî LE_IN√çCIO</small>
          </div>
          <div class="distance-card">
            <div><strong>Largura Final</strong></div>
            <div class="distance-value">${dist1Final.toFixed(3)} m</div>
            <small>LD_FINAL ‚Üî LE_FINAL</small>
          </div>
          <div class="distance-card" style="background: linear-gradient(135deg, #e3f2fd, #f3e5f5); border: 2px solid #9c27b0;">
            <div><strong>üìè M√©dia Largura</strong></div>
            <div class="distance-value" style="color: #9c27b0;">${media1Largura.toFixed(3)} m</div>
            <small>Estrutura 1</small>
          </div>
          <div class="distance-card">
            <div><strong>Comprimento LD</strong></div>
            <div class="distance-value">${dist1LD.toFixed(3)} m</div>
            <small>LD_IN√çCIO ‚Üî LD_FINAL</small>
          </div>
          <div class="distance-card">
            <div><strong>Comprimento LE</strong></div>
            <div class="distance-value">${dist1LE.toFixed(3)} m</div>
            <small>LE_IN√çCIO ‚Üî LE_FINAL</small>
          </div>
          <div class="distance-card" style="background: linear-gradient(135deg, #e8f5e8, #fff3e0); border: 2px solid #ff9800;">
            <div><strong>üìê M√©dia Comprimento</strong></div>
            <div class="distance-value" style="color: #ff9800;">${media1Comprimento.toFixed(3)} m</div>
            <small>Estrutura 1</small>
          </div>
          
          <div class="distance-card elevation-section">
            <div><strong>üìè ESTRUTURA 1 - An√°lise de Eleva√ß√£o</strong></div>
          </div>
          <div class="distance-card elevation-analysis-card">
            <div><strong>Diferen√ßa LD‚ÜîLE (In√≠cio com In√≠cio)</strong></div>
            <div class="elevation-value" style="color: ${elev1_LD_LE_Inicio >= 0 ? '#4caf50' : '#f44336'};">${elev1_LD_LE_Inicio >= 0 ? '+' : ''}${elev1_LD_LE_Inicio.toFixed(3)} m</div>
            <small>Inclina√ß√£o transversal - mesmo ponto</small>
          </div>
          <div class="distance-card elevation-analysis-card">
            <div><strong>Diferen√ßa LD‚ÜîLE (Final com Final)</strong></div>
            <div class="elevation-value" style="color: ${elev1_LD_LE_Final >= 0 ? '#4caf50' : '#f44336'};">${elev1_LD_LE_Final >= 0 ? '+' : ''}${elev1_LD_LE_Final.toFixed(3)} m</div>
            <small>Inclina√ß√£o transversal - mesmo ponto</small>
          </div>
          <div class="distance-card elevation-analysis-card">
            <div><strong>Diferen√ßa LD: In√≠cio‚ÜîFinal (Direito com Direito)</strong></div>
            <div class="elevation-value" style="color: ${elev1_Inicio_Final_LD >= 0 ? '#4caf50' : '#f44336'};">${elev1_Inicio_Final_LD >= 0 ? '+' : ''}${elev1_Inicio_Final_LD.toFixed(3)} m</div>
            <small>Inclina√ß√£o longitudinal - mesmo lado</small>
          </div>
          <div class="distance-card elevation-analysis-card">
            <div><strong>Diferen√ßa LE: In√≠cio‚ÜîFinal (Esquerdo com Esquerdo)</strong></div>
            <div class="elevation-value" style="color: ${elev1_Inicio_Final_LE >= 0 ? '#4caf50' : '#f44336'};">${elev1_Inicio_Final_LE >= 0 ? '+' : ''}${elev1_Inicio_Final_LE.toFixed(3)} m</div>
            <small>Inclina√ß√£o longitudinal - mesmo lado</small>
          </div>
          
          <div class="distance-card elevation-section">
            <div><strong>üìê ESTRUTURA 1 - Verifica√ß√£o de Conformidade</strong></div>
          </div>
        `;

        // Verifica√ß√£o de conformidade para estrutura 1
        const status1_LD_LE_Inicio = getInclinationStatus(incl1_LD_LE_Inicio, true);
        const status1_LD_LE_Final = getInclinationStatus(incl1_LD_LE_Final, true);
        const status1_Inicio_Final_LD = getInclinationStatus(incl1_Inicio_Final_LD, false);
        const status1_Inicio_Final_LE = getInclinationStatus(incl1_Inicio_Final_LE, false);

        html += `
          <div class="distance-card ${status1_LD_LE_Inicio.class}">
            <div><strong>${status1_LD_LE_Inicio.icon} Transversal: LD‚ÜîLE (In√≠cio com In√≠cio)</strong></div>
            <div class="inclination-value" style="color: ${status1_LD_LE_Inicio.color};">${incl1_LD_LE_Inicio.percentage.toFixed(2)}% (${incl1_LD_LE_Inicio.degrees.toFixed(1)}¬∞)</div>
            <small>${incl1_LD_LE_Inicio.direction} - ${status1_LD_LE_Inicio.text}</small>
            <div style="font-size: 11px; margin-top: 5px; color: #666;">
              üìè Dist√¢ncia: ${dist1Inicio.toFixed(3)}m | Desn√≠vel: ${Math.abs(elev1_LD_LE_Inicio).toFixed(3)}m<br>
              üìê C√°lculo: ${Math.abs(elev1_LD_LE_Inicio).toFixed(3)}m √∑ ${dist1Inicio.toFixed(3)}m √ó 100 = ${incl1_LD_LE_Inicio.percentage.toFixed(2)}%<br>
              Limite transversal: ‚â§${LIMIT_TRANSVERSAL}%
            </div>
          </div>
          <div class="distance-card ${status1_LD_LE_Final.class}">
            <div><strong>${status1_LD_LE_Final.icon} Transversal: LD‚ÜîLE (Final com Final)</strong></div>
            <div class="inclination-value" style="color: ${status1_LD_LE_Final.color};">${incl1_LD_LE_Final.percentage.toFixed(2)}% (${incl1_LD_LE_Final.degrees.toFixed(1)}¬∞)</div>
            <small>${incl1_LD_LE_Final.direction} - ${status1_LD_LE_Final.text}</small>
            <div style="font-size: 11px; margin-top: 5px; color: #666;">
              üìè Dist√¢ncia: ${dist1Final.toFixed(3)}m | Desn√≠vel: ${Math.abs(elev1_LD_LE_Final).toFixed(3)}m<br>
              üìê C√°lculo: ${Math.abs(elev1_LD_LE_Final).toFixed(3)}m √∑ ${dist1Final.toFixed(3)}m √ó 100 = ${incl1_LD_LE_Final.percentage.toFixed(2)}%<br>
              Limite transversal: ‚â§${LIMIT_TRANSVERSAL}%
            </div>
          </div>
          <div class="distance-card ${status1_Inicio_Final_LD.class}">
            <div><strong>${status1_Inicio_Final_LD.icon} Longitudinal: LD (Direito com Direito)</strong></div>
            <div class="inclination-value" style="color: ${status1_Inicio_Final_LD.color};">${incl1_Inicio_Final_LD.percentage.toFixed(2)}% (${incl1_Inicio_Final_LD.degrees.toFixed(1)}¬∞)</div>
            <small>${incl1_Inicio_Final_LD.direction} - ${status1_Inicio_Final_LD.text}</small>
            <div style="font-size: 11px; margin-top: 5px; color: #666;">
              üìè Dist√¢ncia: ${dist1LD.toFixed(3)}m | Desn√≠vel: ${Math.abs(elev1_Inicio_Final_LD).toFixed(3)}m<br>
              üìê C√°lculo: ${Math.abs(elev1_Inicio_Final_LD).toFixed(3)}m √∑ ${dist1LD.toFixed(3)}m √ó 100 = ${incl1_Inicio_Final_LD.percentage.toFixed(2)}%<br>
              Limite longitudinal: ‚â§${LIMIT_LONGITUDINAL}%
            </div>
          </div>
          <div class="distance-card ${status1_Inicio_Final_LE.class}">
            <div><strong>${status1_Inicio_Final_LE.icon} Longitudinal: LE (Esquerdo com Esquerdo)</strong></div>
            <div class="inclination-value" style="color: ${status1_Inicio_Final_LE.color};">${incl1_Inicio_Final_LE.percentage.toFixed(2)}% (${incl1_Inicio_Final_LE.degrees.toFixed(1)}¬∞)</div>
            <small>${incl1_Inicio_Final_LE.direction} - ${status1_Inicio_Final_LE.text}</small>
            <div style="font-size: 11px; margin-top: 5px; color: #666;">
              üìè Dist√¢ncia: ${dist1LE.toFixed(3)}m | Desn√≠vel: ${Math.abs(elev1_Inicio_Final_LE).toFixed(3)}m<br>
              üìê C√°lculo: ${Math.abs(elev1_Inicio_Final_LE).toFixed(3)}m √∑ ${dist1LE.toFixed(3)}m √ó 100 = ${incl1_Inicio_Final_LE.percentage.toFixed(2)}%<br>
              Limite longitudinal: ‚â§${LIMIT_LONGITUDINAL}%
            </div>
          </div>
        `;

        // ESTRUTURA 2 (se existir)
        if (struct2) {
          const dist2Inicio = calculateDistance(struct2.ldInicio, struct2.leInicio);
          const dist2Final = calculateDistance(struct2.ldFinal, struct2.leFinal);
          const dist2LD = calculateDistance(struct2.ldInicio, struct2.ldFinal);
          const dist2LE = calculateDistance(struct2.leInicio, struct2.leFinal);
          const media2Largura = (dist2Inicio + dist2Final) / 2;
          const media2Comprimento = (dist2LD + dist2LE) / 2;

          const elev2_LD_LE_Inicio = calculateElevationDifference(struct2.ldInicio, struct2.leInicio);
          const elev2_LD_LE_Final = calculateElevationDifference(struct2.ldFinal, struct2.leFinal);
          const elev2_Inicio_Final_LD = calculateElevationDifference(struct2.ldInicio, struct2.ldFinal);
          const elev2_Inicio_Final_LE = calculateElevationDifference(struct2.leInicio, struct2.leFinal);

          const incl2_LD_LE_Inicio = calculateInclination(struct2.ldInicio, struct2.leInicio);
          const incl2_LD_LE_Final = calculateInclination(struct2.ldFinal, struct2.leFinal);
          const incl2_Inicio_Final_LD = calculateInclination(struct2.ldInicio, struct2.ldFinal);
          const incl2_Inicio_Final_LE = calculateInclination(struct2.leInicio, struct2.leFinal);

          html += `
            <div class="section-divider"></div>
            <div class="distance-card structure-section">
              <div><strong>üèóÔ∏è ESTRUTURA 2 (ROSA) - Dimens√µes</strong></div>
            </div>
            <div class="distance-card">
              <div><strong>Largura In√≠cio</strong></div>
              <div class="distance-value">${dist2Inicio.toFixed(3)} m</div>
              <small>LD_IN√çCIO ‚Üî LE_IN√çCIO</small>
            </div>
            <div class="distance-card">
              <div><strong>Largura Final</strong></div>
              <div class="distance-value">${dist2Final.toFixed(3)} m</div>
              <small>LD_FINAL ‚Üî LE_FINAL</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #e3f2fd, #f3e5f5); border: 2px solid #9c27b0;">
              <div><strong>üìè M√©dia Largura</strong></div>
              <div class="distance-value" style="color: #9c27b0;">${media2Largura.toFixed(3)} m</div>
              <small>Estrutura 2</small>
            </div>
            <div class="distance-card">
              <div><strong>Comprimento LD</strong></div>
              <div class="distance-value">${dist2LD.toFixed(3)} m</div>
              <small>LD_IN√çCIO ‚Üî LD_FINAL</small>
            </div>
            <div class="distance-card">
              <div><strong>Comprimento LE</strong></div>
              <div class="distance-value">${dist2LE.toFixed(3)} m</div>
              <small>LE_IN√çCIO ‚Üî LE_FINAL</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #e8f5e8, #fff3e0); border: 2px solid #ff9800;">
              <div><strong>üìê M√©dia Comprimento</strong></div>
              <div class="distance-value" style="color: #ff9800;">${media2Comprimento.toFixed(3)} m</div>
              <small>Estrutura 2</small>
            </div>
            
            <div class="distance-card elevation-section">
              <div><strong>üìè ESTRUTURA 2 - An√°lise de Eleva√ß√£o</strong></div>
            </div>
            <div class="distance-card elevation-analysis-card">
              <div><strong>Diferen√ßa LD‚ÜîLE (In√≠cio)</strong></div>
              <div class="elevation-value" style="color: ${elev2_LD_LE_Inicio >= 0 ? '#4caf50' : '#f44336'};">${elev2_LD_LE_Inicio >= 0 ? '+' : ''}${elev2_LD_LE_Inicio.toFixed(3)} m</div>
              <small>Inclina√ß√£o transversal in√≠cio</small>
            </div>
            <div class="distance-card elevation-analysis-card">
              <div><strong>Diferen√ßa LD‚ÜîLE (Final)</strong></div>
              <div class="elevation-value" style="color: ${elev2_LD_LE_Final >= 0 ? '#4caf50' : '#f44336'};">${elev2_LD_LE_Final >= 0 ? '+' : ''}${elev2_LD_LE_Final.toFixed(3)} m</div>
              <small>Inclina√ß√£o transversal final</small>
            </div>
            <div class="distance-card elevation-analysis-card">
              <div><strong>Diferen√ßa In√≠cio‚ÜîFinal (LD)</strong></div>
              <div class="elevation-value" style="color: ${elev2_Inicio_Final_LD >= 0 ? '#4caf50' : '#f44336'};">${elev2_Inicio_Final_LD >= 0 ? '+' : ''}${elev2_Inicio_Final_LD.toFixed(3)} m</div>
              <small>Inclina√ß√£o longitudinal LD</small>
            </div>
            <div class="distance-card elevation-analysis-card">
              <div><strong>Diferen√ßa In√≠cio‚ÜîFinal (LE)</strong></div>
              <div class="elevation-value" style="color: ${elev2_Inicio_Final_LE >= 0 ? '#4caf50' : '#f44336'};">${elev2_Inicio_Final_LE >= 0 ? '+' : ''}${elev2_Inicio_Final_LE.toFixed(3)} m</div>
              <small>Inclina√ß√£o longitudinal LE</small>
            </div>
            
            <div class="distance-card elevation-section">
              <div><strong>üìê ESTRUTURA 2 - Verifica√ß√£o de Conformidade</strong></div>
            </div>
          `;

          // Verifica√ß√£o de conformidade para estrutura 2
          const status2_LD_LE_Inicio = getInclinationStatus(incl2_LD_LE_Inicio, true);
          const status2_LD_LE_Final = getInclinationStatus(incl2_LD_LE_Final, true);
          const status2_Inicio_Final_LD = getInclinationStatus(incl2_Inicio_Final_LD, false);
          const status2_Inicio_Final_LE = getInclinationStatus(incl2_Inicio_Final_LE, false);

          html += `
            <div class="distance-card ${status2_LD_LE_Inicio.class}">
              <div><strong>${status2_LD_LE_Inicio.icon} Transversal: LD‚ÜîLE (In√≠cio com In√≠cio)</strong></div>
              <div class="inclination-value" style="color: ${status2_LD_LE_Inicio.color};">${incl2_LD_LE_Inicio.percentage.toFixed(2)}% (${incl2_LD_LE_Inicio.degrees.toFixed(1)}¬∞)</div>
              <small>${incl2_LD_LE_Inicio.direction} - ${status2_LD_LE_Inicio.text}</small>
              <div style="font-size: 11px; margin-top: 5px; color: #666;">Limite transversal: ‚â§${LIMIT_TRANSVERSAL}%</div>
            </div>
            <div class="distance-card ${status2_LD_LE_Final.class}">
              <div><strong>${status2_LD_LE_Final.icon} Transversal: LD‚ÜîLE (Final com Final)</strong></div>
              <div class="inclination-value" style="color: ${status2_LD_LE_Final.color};">${incl2_LD_LE_Final.percentage.toFixed(2)}% (${incl2_LD_LE_Final.degrees.toFixed(1)}¬∞)</div>
              <small>${incl2_LD_LE_Final.direction} - ${status2_LD_LE_Final.text}</small>
              <div style="font-size: 11px; margin-top: 5px; color: #666;">Limite transversal: ‚â§${LIMIT_TRANSVERSAL}%</div>
            </div>
            <div class="distance-card ${status2_Inicio_Final_LD.class}">
              <div><strong>${status2_Inicio_Final_LD.icon} Longitudinal: LD (Direito com Direito)</strong></div>
              <div class="inclination-value" style="color: ${status2_Inicio_Final_LD.color};">${incl2_Inicio_Final_LD.percentage.toFixed(2)}% (${incl2_Inicio_Final_LD.degrees.toFixed(1)}¬∞)</div>
              <small>${incl2_Inicio_Final_LD.direction} - ${status2_Inicio_Final_LD.text}</small>
              <div style="font-size: 11px; margin-top: 5px; color: #666;">Limite longitudinal: ‚â§${LIMIT_LONGITUDINAL}%</div>
            </div>
            <div class="distance-card ${status2_Inicio_Final_LE.class}">
              <div><strong>${status2_Inicio_Final_LE.icon} Longitudinal: LE (Esquerdo com Esquerdo)</strong></div>
              <div class="inclination-value" style="color: ${status2_Inicio_Final_LE.color};">${incl2_Inicio_Final_LE.percentage.toFixed(2)}% (${incl2_Inicio_Final_LE.degrees.toFixed(1)}¬∞)</div>
              <small>${incl2_Inicio_Final_LE.direction} - ${status2_Inicio_Final_LE.text}</small>
              <div style="font-size: 11px; margin-top: 5px; color: #666;">Limite longitudinal: ‚â§${LIMIT_LONGITUDINAL}%</div>
            </div>
          `;
        }

        distanceInfo.innerHTML = html;
        
        // Adicionar resumo executivo melhorado
        if (struct2) {
          const dist2Inicio = calculateDistance(struct2.ldInicio, struct2.leInicio);
          const dist2Final = calculateDistance(struct2.ldFinal, struct2.leFinal);
          const dist2LD = calculateDistance(struct2.ldInicio, struct2.ldFinal);
          const dist2LE = calculateDistance(struct2.leInicio, struct2.leFinal);
          const media2Largura = (dist2Inicio + dist2Final) / 2;
          const media2Comprimento = (dist2LD + dist2LE) / 2;

          const incl2_LD_LE_Inicio = calculateInclination(struct2.ldInicio, struct2.leInicio);
          const incl2_LD_LE_Final = calculateInclination(struct2.ldFinal, struct2.leFinal);
          const incl2_Inicio_Final_LD = calculateInclination(struct2.ldInicio, struct2.ldFinal);
          const incl2_Inicio_Final_LE = calculateInclination(struct2.leInicio, struct2.leFinal);

          const crossDistance = calculateDistance(struct1.leInicio, struct2.ldInicio);
          const crossElevation = calculateElevationDifference(struct1.leInicio, struct2.ldInicio);
          const crossInclination = calculateInclination(struct1.leInicio, struct2.ldInicio);
          const mediaGeralLargura = (media1Largura + media2Largura) / 2;
          const mediaGeralComprimento = (media1Comprimento + media2Comprimento) / 2;
          
          // Verificar problemas de inclina√ß√£o com novos limites
          const problemasTransversais = [];
          const problemasLongitudinais = [];
          
          if (incl1_LD_LE_Inicio.percentage > LIMIT_TRANSVERSAL) problemasTransversais.push("Est.1 Transversal In√≠cio (LD‚ÜîLE)");
          if (incl1_LD_LE_Final.percentage > LIMIT_TRANSVERSAL) problemasTransversais.push("Est.1 Transversal Final (LD‚ÜîLE)");
          if (incl2_LD_LE_Inicio.percentage > LIMIT_TRANSVERSAL) problemasTransversais.push("Est.2 Transversal In√≠cio (LD‚ÜîLE)");
          if (incl2_LD_LE_Final.percentage > LIMIT_TRANSVERSAL) problemasTransversais.push("Est.2 Transversal Final (LD‚ÜîLE)");
          
          if (incl1_Inicio_Final_LD.percentage > LIMIT_LONGITUDINAL) problemasLongitudinais.push("Est.1 Longitudinal LD (Direito)");
          if (incl1_Inicio_Final_LE.percentage > LIMIT_LONGITUDINAL) problemasLongitudinais.push("Est.1 Longitudinal LE (Esquerdo)");
          if (incl2_Inicio_Final_LD.percentage > LIMIT_LONGITUDINAL) problemasLongitudinais.push("Est.2 Longitudinal LD (Direito)");
          if (incl2_Inicio_Final_LE.percentage > LIMIT_LONGITUDINAL) problemasLongitudinais.push("Est.2 Longitudinal LE (Esquerdo)");
          if (crossInclination.percentage > LIMIT_LONGITUDINAL) problemasLongitudinais.push("Entre estruturas (Longitudinal)");
          
          const totalProblemas = problemasTransversais.length + problemasLongitudinais.length;
          
          const summaryHtml = `
            <h4 style="margin-bottom: 15px; color: #495057;">üìã Resumo Executivo - An√°lise T√©cnica</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; text-align: center;">
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: #007bff;">üåâ Dist√¢ncia Total</div>
                <div style="font-size: 16px; font-weight: bold; color: #007bff; margin: 5px 0;">${crossDistance.toFixed(3)}m</div>
                <div style="font-size: 12px; color: #6c757d;">LE(1) ‚Üî LD(2)</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: ${crossElevation >= 0 ? '#4caf50' : '#f44336'};">üìè Diferen√ßa Eleva√ß√£o</div>
                <div style="font-size: 16px; font-weight: bold; color: ${crossElevation >= 0 ? '#4caf50' : '#f44336'}; margin: 5px 0;">${crossElevation >= 0 ? '+' : ''}${crossElevation.toFixed(3)}m</div>
                <div style="font-size: 12px; color: #6c757d;">Entre estruturas</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: ${crossInclination.percentage > LIMIT_LONGITUDINAL ? '#f44336' : crossInclination.percentage > LIMIT_LONGITUDINAL * 0.8 ? '#ff9800' : '#4caf50'};">üìê Inclina√ß√£o Entre Estru.</div>
                <div style="font-size: 16px; font-weight: bold; color: ${crossInclination.percentage > LIMIT_LONGITUDINAL ? '#f44336' : crossInclination.percentage > LIMIT_LONGITUDINAL * 0.8 ? '#ff9800' : '#4caf50'}; margin: 5px 0;">${crossInclination.percentage.toFixed(2)}%</div>
                <div style="font-size: 12px; color: #6c757d;">Limite: ‚â§${LIMIT_LONGITUDINAL}%</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: #9c27b0;">üìè Largura M√©dia</div>
                <div style="font-size: 16px; font-weight: bold; color: #9c27b0; margin: 5px 0;">${mediaGeralLargura.toFixed(3)}m</div>
                <div style="font-size: 12px; color: #6c757d;">Geral (Est.1+2)</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: #ff9800;">üìê Comprimento M√©dio</div>
                <div style="font-size: 16px; font-weight: bold; color: #ff9800; margin: 5px 0;">${mediaGeralComprimento.toFixed(3)}m</div>
                <div style="font-size: 12px; color: #6c757d;">Geral (Est.1+2)</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid ${totalProblemas > 0 ? '#f44336' : '#4caf50'};">
                <div style="font-weight: bold; color: ${totalProblemas > 0 ? '#f44336' : '#4caf50'};">${totalProblemas > 0 ? 'üö®' : '‚úÖ'} Status Conformidade</div>
                <div style="font-size: 16px; font-weight: bold; color: ${totalProblemas > 0 ? '#f44336' : '#4caf50'}; margin: 5px 0;">${totalProblemas > 0 ? `${totalProblemas} N√£o Conformidades` : 'CONFORME'}</div>
                <div style="font-size: 12px; color: #6c757d;">${totalProblemas > 0 ? 'Revisar inclina√ß√µes' : 'Todas inclina√ß√µes OK'}</div>
              </div>
            </div>
            ${totalProblemas > 0 ? `
            <div style="margin-top: 15px; padding: 12px; background: #ffebee; border: 2px solid #f44336; border-radius: 6px;">
              <div style="font-weight: bold; color: #d32f2f; margin-bottom: 8px;">üö® INCLINA√á√ïES ACIMA DOS LIMITES T√âCNICOS:</div>
              ${problemasTransversais.length > 0 ? `<div style="font-size: 14px; color: #c62828; margin-bottom: 5px;"><strong>Transversais (>${LIMIT_TRANSVERSAL}%):</strong> ${problemasTransversais.join(', ')}</div>` : ''}
              ${problemasLongitudinais.length > 0 ? `<div style="font-size: 14px; color: #c62828;"><strong>Longitudinais (>${LIMIT_LONGITUDINAL}%):</strong> ${problemasLongitudinais.join(', ')}</div>` : ''}
              <div style="font-size: 12px; color: #d32f2f; margin-top: 8px; font-weight: bold;">‚ö†Ô∏è RECOMENDA-SE AN√ÅLISE ESTRUTURAL ESPEC√çFICA</div>
            </div>
            ` : `
            <div style="margin-top: 15px; padding: 12px; background: #e8f5e8; border: 2px solid #4caf50; border-radius: 6px;">
              <div style="font-weight: bold; color: #2e7d32; margin-bottom: 8px;">‚úÖ ESTRUTURAS DENTRO DOS LIMITES T√âCNICOS</div>
              <div style="font-size: 14px; color: #388e3c;">Todas as inclina√ß√µes est√£o dentro dos limites recomendados</div>
              <div style="font-size: 12px; color: #2e7d32; margin-top: 5px;">Transversais: ‚â§${LIMIT_TRANSVERSAL}% | Longitudinais: ‚â§${LIMIT_LONGITUDINAL}%</div>
            </div>
            `}
          `;
          document.getElementById('executiveSummary').innerHTML = summaryHtml;
        } else {
          // Para estrutura √∫nica
          const allPointsForAnalysis = [struct1.ldInicio, struct1.leInicio, struct1.ldFinal, struct1.leFinal];
          const maxElevForAnalysis = Math.max(...allPointsForAnalysis.map(p => p.elevation));
          const minElevForAnalysis = Math.min(...allPointsForAnalysis.map(p => p.elevation));
          
          // Verificar problemas de inclina√ß√£o para estrutura √∫nica
          const problemasTransversais = [];
          const problemasLongitudinais = [];
          
          if (incl1_LD_LE_Inicio.percentage > LIMIT_TRANSVERSAL) problemasTransversais.push("Transversal In√≠cio (LD‚ÜîLE)");
          if (incl1_LD_LE_Final.percentage > LIMIT_TRANSVERSAL) problemasTransversais.push("Transversal Final (LD‚ÜîLE)");
          
          if (incl1_Inicio_Final_LD.percentage > LIMIT_LONGITUDINAL) problemasLongitudinais.push("Longitudinal LD (Direito)");
          if (incl1_Inicio_Final_LE.percentage > LIMIT_LONGITUDINAL) problemasLongitudinais.push("Longitudinal LE (Esquerdo)");
          
          const totalProblemasUnica = problemasTransversais.length + problemasLongitudinais.length;
          
          const summaryHtml = `
            <h4 style="margin-bottom: 15px; color: #495057;">üìã Resumo Executivo - An√°lise T√©cnica (Estrutura √önica)</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 15px; text-align: center;">
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: #9c27b0;">üìè Largura M√©dia</div>
                <div style="font-size: 18px; font-weight: bold; color: #9c27b0; margin: 5px 0;">${media1Largura.toFixed(3)} m</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: #ff9800;">üìê Comprimento M√©dio</div>
                <div style="font-size: 18px; font-weight: bold; color: #ff9800; margin: 5px 0;">${media1Comprimento.toFixed(3)} m</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: ${incl1_LD_LE_Inicio.percentage > LIMIT_TRANSVERSAL || incl1_LD_LE_Final.percentage > LIMIT_TRANSVERSAL ? '#f44336' : '#4caf50'};">üîÑ Status Transversal</div>
                <div style="font-size: 14px; font-weight: bold; color: ${incl1_LD_LE_Inicio.percentage > LIMIT_TRANSVERSAL || incl1_LD_LE_Final.percentage > LIMIT_TRANSVERSAL ? '#f44336' : '#4caf50'}; margin: 5px 0;">${incl1_LD_LE_Inicio.percentage > LIMIT_TRANSVERSAL || incl1_LD_LE_Final.percentage > LIMIT_TRANSVERSAL ? 'ACIMA DO LIMITE' : 'DENTRO DO LIMITE'}</div>
                <div style="font-size: 12px; color: #6c757d;">Limite: ‚â§${LIMIT_TRANSVERSAL}%</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: ${incl1_Inicio_Final_LD.percentage > LIMIT_LONGITUDINAL || incl1_Inicio_Final_LE.percentage > LIMIT_LONGITUDINAL ? '#f44336' : '#4caf50'};">‚ÜïÔ∏è Status Longitudinal</div>
                <div style="font-size: 14px; font-weight: bold; color: ${incl1_Inicio_Final_LD.percentage > LIMIT_LONGITUDINAL || incl1_Inicio_Final_LE.percentage > LIMIT_LONGITUDINAL ? '#f44336' : '#4caf50'}; margin: 5px 0;">${incl1_Inicio_Final_LD.percentage > LIMIT_LONGITUDINAL || incl1_Inicio_Final_LE.percentage > LIMIT_LONGITUDINAL ? 'ACIMA DO LIMITE' : 'DENTRO DO LIMITE'}</div>
                <div style="font-size: 12px; color: #6c757d;">Limite: ‚â§${LIMIT_LONGITUDINAL}%</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid ${totalProblemasUnica > 0 ? '#f44336' : '#4caf50'};">
                <div style="font-weight: bold; color: ${totalProblemasUnica > 0 ? '#f44336' : '#4caf50'};">${totalProblemasUnica > 0 ? 'üö®' : '‚úÖ'} Status Geral</div>
                <div style="font-size: 16px; font-weight: bold; color: ${totalProblemasUnica > 0 ? '#f44336' : '#4caf50'}; margin: 5px 0;">${totalProblemasUnica > 0 ? `${totalProblemasUnica} Acima dos Limites` : 'DENTRO DOS LIMITES'}</div>
                <div style="font-size: 12px; color: #6c757d;">${totalProblemasUnica > 0 ? 'Revisar inclina√ß√µes' : 'Todas inclina√ß√µes OK'}</div>
              </div>
            </div>
            <div style="margin-top: 15px; padding: 12px; background: #e3f2fd; border: 2px solid #2196f3; border-radius: 6px;">
              <div style="font-weight: bold; color: #1976d2; margin-bottom: 8px;">üìè An√°lise de Eleva√ß√µes Relativas:</div>
              <div style="font-size: 14px; color: #1565c0;">
                üî∫ Ponto mais alto: ${maxElevForAnalysis.toFixed(3)}m (refer√™ncia 0,00m) | 
                üîª Ponto mais baixo: ${minElevForAnalysis.toFixed(3)}m (${(minElevForAnalysis - maxElevForAnalysis).toFixed(3)}m relativo)
              </div>
              <div style="font-size: 12px; color: #1976d2; margin-top: 5px;">Amplitude total: ${(maxElevForAnalysis - minElevForAnalysis).toFixed(3)}m</div>
            </div>
            ${totalProblemasUnica > 0 ? `
            <div style="margin-top: 15px; padding: 12px; background: #ffebee; border: 2px solid #f44336; border-radius: 6px;">
              <div style="font-weight: bold; color: #d32f2f; margin-bottom: 8px;">üö® INCLINA√á√ïES ACIMA DOS LIMITES T√âCNICOS:</div>
              ${problemasTransversais.length > 0 ? `<div style="font-size: 14px; color: #c62828; margin-bottom: 5px;"><strong>Transversais (>${LIMIT_TRANSVERSAL}%):</strong> ${problemasTransversais.join(', ')}</div>` : ''}
              ${problemasLongitudinais.length > 0 ? `<div style="font-size: 14px; color: #c62828;"><strong>Longitudinais (>${LIMIT_LONGITUDINAL}%):</strong> ${problemasLongitudinais.join(', ')}</div>` : ''}
              <div style="font-size: 12px; color: #d32f2f; margin-top: 8px; font-weight: bold;">‚ö†Ô∏è RECOMENDA-SE AN√ÅLISE ESTRUTURAL ESPEC√çFICA</div>
            </div>
            ` : `
            <div style="margin-top: 15px; padding: 12px; background: #e8f5e8; border: 2px solid #4caf50; border-radius: 6px;">
              <div style="font-weight: bold; color: #2e7d32; margin-bottom: 8px;">‚úÖ ESTRUTURA DENTRO DOS LIMITES T√âCNICOS</div>
              <div style="font-size: 14px; color: #388e3c;">Todas as inclina√ß√µes est√£o dentro dos limites recomendados</div>
              <div style="font-size: 12px; color: #2e7d32; margin-top: 5px;">Transversais: ‚â§${LIMIT_TRANSVERSAL}% | Longitudinais: ‚â§${LIMIT_LONGITUDINAL}%</div>
            </div>
            `}
          `;
          document.getElementById('executiveSummary').innerHTML = summaryHtml;
        }
        
        debugLog("Relat√≥rio de an√°lise t√©cnica gerado com sucesso");
        
        // Adicionar se√ß√£o explicativa da metodologia
        const metodologiaHtml = `
          <div style="margin-top: 25px; padding: 15px; background: linear-gradient(135deg, #f8f9fa, #e9ecef); border-radius: 8px; border: 2px solid #6c757d;">
            <h4 style="margin: 0 0 15px 0; color: #495057; text-align: center;">üìê Metodologia de An√°lise Aplicada</h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
              <div style="background: white; padding: 12px; border-radius: 6px; border: 2px solid #d32f2f;">
                <div style="font-weight: bold; color: #d32f2f; margin-bottom: 8px;">üîÑ INCLINA√á√ïES TRANSVERSAIS (‚â§5%)</div>
                <div style="font-size: 13px; color: #666; line-height: 1.4;">
                  <strong>‚úì LD_IN√çCIO ‚Üî LE_IN√çCIO</strong><br>
                  <em>Lado direito com lado esquerdo no mesmo ponto</em><br><br>
                  <strong>‚úì LD_FINAL ‚Üî LE_FINAL</strong><br>
                  <em>Lado direito com lado esquerdo no mesmo ponto</em>
                </div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 2px solid #ff9800;">
                <div style="font-weight: bold; color: #ff9800; margin-bottom: 8px;">‚ÜïÔ∏è INCLINA√á√ïES LONGITUDINAIS (‚â§2,5%)</div>
                <div style="font-size: 13px; color: #666; line-height: 1.4;">
                  <strong>‚úì LD_IN√çCIO ‚Üî LD_FINAL</strong><br>
                  <em>Mesmo lado direito entre pontos</em><br><br>
                  <strong>‚úì LE_IN√çCIO ‚Üî LE_FINAL</strong><br>
                  <em>Mesmo lado esquerdo entre pontos</em>
                </div>
              </div>
            </div>
            <div style="text-align: center; margin-top: 12px; font-size: 12px; color: #6c757d;">
              <strong>Boas Pr√°ticas da Engenharia de Pontes</strong> - Sistema automatizado de an√°lise t√©cnica de tabuleiros
            </div>
          </div>
        `;
        
        document.getElementById('executiveSummary').insertAdjacentHTML('afterend', metodologiaHtml);
        
        infoPanel.style.display = "block";
      }

      function processData() {
        debugLog("=== PROCESSANDO DADOS ===");
        const csvData1 = document.getElementById("csvData1").value;
        const csvData2 = document.getElementById("csvData2").value;
        const errorMsg = document.getElementById("errorMsg");
        
        // Limpar debug anterior
        document.getElementById('debugInfo').innerHTML = '';
        document.getElementById('debugInfo').style.display = 'none';
        
        errorMsg.innerHTML = "";

        if (!csvData1.trim()) {
          errorMsg.innerHTML = '<div class="error">‚ö†Ô∏è Por favor, cole pelo menos os dados do CSV 1!</div>';
          return;
        }

        try {
          debugLog("Processando CSV 1...");
          const data1 = parseCSV(csvData1);
          debugLog("Processando CSV 2...");
          const data2 = parseCSV(csvData2);

          debugLog("Procurando pontos no CSV 1...");
          const points1 = findPoints(data1);
          debugLog("Procurando pontos no CSV 2...");
          const points2 = findPoints(data2);
          
          currentPoints1 = points1;
          currentPoints2 = points2;

          if (Object.keys(points1).length === 0) {
            errorMsg.innerHTML = '<div class="error">‚ö†Ô∏è Nenhum ponto LD ou LE encontrado no CSV 1! Certifique-se de que existem pontos com *_OAE no nome ou c√≥digo.</div>';
            return;
          }

          debugLog("Iniciando visualiza√ß√£o...");
          drawVisualization(points1, points2);
        } catch (error) {
          console.error("Erro:", error);
          debugLog(`ERRO: ${error.message}`);
          errorMsg.innerHTML = `<div class="error">‚ùå Erro ao processar dados: ${error.message}</div>`;
        }
      }

      // Pr√©-carregar dados de exemplo
      window.onload = function () {
        console.log("üöÄ P√°gina carregada - Analisador de Inclina√ß√µes ativo");
        updateZoomDisplay();
        loadExample1();
      };
    </script>
  </body>
</html>
