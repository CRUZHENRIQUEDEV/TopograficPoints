<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Analisador de Inclina√ß√µes e Esconsidade - Tabuleiros de Ponte</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f5f5f5;
      }
      
      .container {
        background: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      }
      
      h1 {
        color: #333;
        text-align: center;
        margin-bottom: 10px;
      }
      
      .subtitle {
        text-align: center;
        color: #666;
        margin-bottom: 30px;
        font-size: 14px;
        padding: 10px;
        background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
        border-radius: 8px;
        border: 1px solid #2196f3;
      }

      /* Se√ß√£o dos diagramas de esconsidade */
      .esconsidade-diagrams {
        margin: 30px 0;
        padding: 20px;
        background: linear-gradient(135deg, #f8f9fa, #ffffff);
        border: 2px solid #007bff;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      }

      .esconsidade-diagrams h2 {
        text-align: center;
        color: #007bff;
        margin-bottom: 15px;
        font-size: 24px;
      }

      .diagrams-container {
        display: flex;
        justify-content: center;
        margin-bottom: 20px;
      }

      .diagrams-container svg {
        max-width: 100%;
        height: auto;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      }

      .diagram-explanation {
        background: #e3f2fd;
        padding: 15px;
        border-radius: 8px;
        border-left: 4px solid #2196f3;
        margin-top: 15px;
      }

      .diagram-explanation h3 {
        color: #1976d2;
        margin-top: 0;
        margin-bottom: 10px;
      }

      .diagram-explanation ul {
        margin: 0;
        padding-left: 20px;
      }

      .diagram-explanation li {
        margin-bottom: 8px;
        color: #1565c0;
      }
      
      .input-section {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 30px;
      }
      
      .csv-input {
        display: flex;
        flex-direction: column;
      }
      
      .csv-input label {
        font-weight: bold;
        margin-bottom: 10px;
        color: #333;
      }
      
      textarea {
        width: 100%;
        height: 200px;
        padding: 10px;
        border: 2px solid #ddd;
        border-radius: 5px;
        font-family: monospace;
        font-size: 12px;
        resize: vertical;
      }
      
      button {
        background: #007bff;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin: 10px 5px;
      }
      
      button:hover {
        background: #0056b3;
      }
      
      .controls {
        text-align: center;
        margin: 20px 0;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        gap: 10px;
      }
      
      .zoom-controls {
        display: flex;
        align-items: center;
        background: #f8f9fa;
        padding: 8px 15px;
        border-radius: 25px;
        border: 1px solid #dee2e6;
        margin-left: 20px;
        flex-wrap: wrap;
        gap: 5px;
      }
      
      @media (max-width: 768px) {
        .controls {
          flex-direction: column;
          gap: 15px;
        }
        
        .zoom-controls {
          margin-left: 0;
          width: 100%;
          justify-content: center;
        }

        .esconsidade-diagrams {
          margin: 20px 0;
          padding: 15px;
        }

        .esconsidade-diagrams h2 {
          font-size: 20px;
        }
      }
      
      .zoom-controls button {
        margin: 0 5px;
        padding: 6px 10px;
        font-size: 14px;
        min-width: 40px;
      }
      
      #zoomLevel {
        margin: 0 15px;
        font-weight: bold;
        color: #495057;
        font-size: 14px;
        min-width: 80px;
        text-align: center;
      }
      
      .visualization {
        border: 2px solid #ddd;
        border-radius: 10px;
        background: white;
        min-height: 500px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 20px;
      }
      
      #canvas {
        border: 1px solid #ccc;
        background: #fafafa;
      }
      
      .info-panel {
        margin-top: 20px;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 5px;
        border-left: 4px solid #007bff;
      }
      
      .distance-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 12px;
        margin-top: 15px;
      }
      
      .distance-card {
        background: white;
        padding: 12px;
        border-radius: 5px;
        border: 1px solid #ddd;
        text-align: center;
        transition: transform 0.2s;
      }
      
      .distance-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      }
      
      .section-divider {
        grid-column: 1 / -1;
        height: 1px;
        background: linear-gradient(to right, transparent, #ddd, transparent);
        margin: 15px 0;
      }
      
      .distance-value {
        font-size: 18px;
        font-weight: bold;
        color: #007bff;
      }
      
      .elevation-value {
        font-size: 16px;
        font-weight: bold;
      }
      
      .inclination-value {
        font-size: 14px;
        font-weight: bold;
      }
      
      .cross-distance-card {
        background: linear-gradient(135deg, #fff3e0, #e8f5e8);
        border: 2px solid #ff9800;
      }
      
      .cross-distance-value {
        color: #ff9800;
      }
      
      .elevation-analysis-card {
        background: linear-gradient(135deg, #e8f5e8, #f3e5f5);
        border: 2px solid #4caf50;
      }
      
      .warning-card {
        background: linear-gradient(135deg, #fff3e0, #ffebee);
        border: 2px solid #ff5722;
      }
      
      .critical-warning-card {
        background: linear-gradient(135deg, #ffebee, #fce4ec);
        border: 3px solid #d32f2f;
        animation: pulse 2s infinite;
      }
      
      @keyframes pulse {
        0% { box-shadow: 0 0 0 0 rgba(211, 47, 47, 0.4); }
        70% { box-shadow: 0 0 0 10px rgba(211, 47, 47, 0); }
        100% { box-shadow: 0 0 0 0 rgba(211, 47, 47, 0); }
      }
      
      .good-card {
        background: linear-gradient(135deg, #e8f5e8, #f1f8e9);
        border: 2px solid #4caf50;
      }
      
      .acceptable-card {
        background: linear-gradient(135deg, #fff8e1, #f3e5f5);
        border: 2px solid #ff9800;
      }
      
      .error {
        color: #dc3545;
        background: #f8d7da;
        padding: 10px;
        border-radius: 5px;
        margin-top: 10px;
      }
      
      .csv-section {
        border: 1px solid #ddd;
        border-radius: 5px;
        padding: 15px;
        background: #fafafa;
      }
      
      .section-title {
        color: #007bff;
        font-size: 18px;
        margin-bottom: 10px;
        font-weight: bold;
      }
      
      .example-buttons {
        margin-top: 10px;
      }
      
      .example-btn {
        background: #28a745;
        font-size: 14px;
        padding: 8px 16px;
      }
      
      .example-btn:hover {
        background: #218838;
      }
      
      .cross-section {
        background: linear-gradient(135deg, #fff3e0, #e8f5e8);
        border: 2px solid #ff9800;
        margin: 20px 0 10px 0;
        grid-column: 1 / -1;
        text-align: center;
      }
      
      .structure-section {
        background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
        border: 2px solid #9c27b0;
        margin: 15px 0 5px 0;
        grid-column: 1 / -1;
        text-align: center;
      }
      
      .elevation-section {
        background: linear-gradient(135deg, #e8f5e8, #f3e5f5);
        border: 2px solid #4caf50;
        margin: 15px 0 5px 0;
        grid-column: 1 / -1;
        text-align: center;
      }
      
      .legend {
        margin: 10px 0;
        padding: 10px;
        background: #f8f9fa;
        border-radius: 5px;
        font-size: 12px;
      }
      
      .legend-item {
        display: inline-block;
        margin: 0 10px;
      }
      
      .legend-color {
        display: inline-block;
        width: 15px;
        height: 15px;
        border-radius: 3px;
        margin-right: 5px;
        vertical-align: middle;
      }

      .debug-info {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 5px;
        padding: 10px;
        margin: 10px 0;
        font-family: monospace;
        font-size: 12px;
        max-height: 200px;
        overflow-y: auto;
      }
      
      .limits-info {
        background: linear-gradient(135deg, #e3f2fd, #f8f9fa);
        border: 2px solid #1976d2;
        border-radius: 8px;
        padding: 15px;
        margin: 20px 0;
        text-align: center;
      }
      
      .limits-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
        margin-top: 10px;
      }
      
      .limit-item {
        background: white;
        padding: 10px;
        border-radius: 5px;
        border: 1px solid #1976d2;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üåâ Analisador de Inclina√ß√µes e Esconsidade - Tabuleiros de Ponte</h1>
      <div class="subtitle">
        <strong>üìê Verifica√ß√£o de Conformidade T√©cnica com An√°lise de Esconsidade e Detec√ß√£o Autom√°tica SIRGAS 2000</strong><br>
        Sistema de an√°lise autom√°tica de inclina√ß√µes transversais, longitudinais e √¢ngulo de esconsidade para tabuleiros de ponte<br>
        <small style="color: #1976d2;">üó∫Ô∏è Detec√ß√£o autom√°tica da zona SIRGAS 2000 | üìê C√°lculo de largura √∫til | Suporte para m√∫ltiplos formatos CSV</small>
      </div>

      <!-- Informa√ß√µes dos Limites -->
      <div class="limits-info">
        <h3 style="margin: 0 0 10px 0; color: #1976d2;">üìè Limites T√©cnicos Recomendados para Inclina√ß√µes</h3>
        <div class="limits-grid">
          <div class="limit-item">
            <div style="font-weight: bold; color: #d32f2f;">üîÑ TRANSVERSAL (LD ‚Üî LE)</div>
            <div style="font-size: 18px; font-weight: bold; color: #d32f2f;">‚â§ 5,00%</div>
            <div style="font-size: 12px; color: #666;">Lado com lado no mesmo ponto</div>
            <div style="font-size: 11px; color: #999;">In√≠cio‚ÜîIn√≠cio | Final‚ÜîFinal</div>
          </div>
          <div class="limit-item">
            <div style="font-weight: bold; color: #ff9800;">‚ÜïÔ∏è LONGITUDINAL (In√≠cio ‚Üî Final)</div>
            <div style="font-size: 18px; font-weight: bold; color: #ff9800;">‚â§ 2,50%</div>
            <div style="font-size: 12px; color: #666;">Mesmo lado entre pontos</div>
            <div style="font-size: 11px; color: #999;">LD‚ÜîLD | LE‚ÜîLE</div>
          </div>
        </div>
        <div style="margin-top: 10px; font-size: 12px; color: #1976d2;">
          <strong>Nota:</strong> Valores baseados em boas pr√°ticas da engenharia de pontes<br>
          <strong>Regra de Verifica√ß√£o:</strong> Transversal = lado com lado no mesmo ponto | Longitudinal = mesmo lado entre pontos
        </div>
      </div>

      <!-- Se√ß√£o de Diagramas de Esconsidade -->
      <div class="esconsidade-diagrams">
        <h2>üìê Conceitos de Esconsidade em Tabuleiros de Ponte</h2>
        
        <div class="diagrams-container">
          <svg viewBox="0 0 1200 500" xmlns="http://www.w3.org/2000/svg">
            <!-- Defini√ß√µes de gradientes e filtros -->
            <defs>
              <!-- Gradiente para o rio -->
              <linearGradient id="riverGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:#64B5F6;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#1E88E5;stop-opacity:1" />
              </linearGradient>
              
              <!-- Gradiente para o tabuleiro -->
              <linearGradient id="deckGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:#F5F5F5;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#E0E0E0;stop-opacity:1" />
              </linearGradient>
              
              <!-- Gradiente para a rodovia -->
              <linearGradient id="roadGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:#616161;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#424242;stop-opacity:1" />
              </linearGradient>
              
              <!-- Sombra -->
              <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
                <feDropShadow dx="3" dy="3" stdDeviation="3" flood-opacity="0.3"/>
              </filter>
              
              <!-- Sombra suave -->
              <filter id="softShadow" x="-50%" y="-50%" width="200%" height="200%">
                <feDropShadow dx="2" dy="2" stdDeviation="2" flood-opacity="0.2"/>
              </filter>
            </defs>
            
            <!-- T√≠tulo principal -->
            <rect x="25" y="10" width="1150" height="50" fill="#FFFFFF" stroke="#E0E0E0" stroke-width="1" rx="8" filter="url(#softShadow)"/>
            <text x="600" y="35" text-anchor="middle" font-size="18" font-weight="700" fill="#2C3E50" font-family="Arial, sans-serif">
              Tipos de Esconsidade no Tabuleiro da Ponte
            </text>
            <text x="600" y="50" text-anchor="middle" font-size="12" fill="#5D6D7E" font-family="Arial, sans-serif">
              Influ√™ncia da orienta√ß√£o do rio na geometria do tabuleiro
            </text>
            
            <!-- Caso 1: SEM Esconsidade -->
            <g transform="translate(80, 80)">
              <!-- Card container -->
              <rect x="0" y="0" width="280" height="320" fill="#FFFFFF" stroke="#E8EAF0" stroke-width="2" rx="12" filter="url(#shadow)"/>
              
              <!-- Header do card -->
              <rect x="0" y="0" width="280" height="45" fill="#4CAF50" rx="12"/>
              <rect x="0" y="33" width="280" height="12" fill="#4CAF50"/>
              <text x="140" y="20" text-anchor="middle" font-size="12" font-weight="600" fill="#FFFFFF" font-family="Arial, sans-serif">
                CASO 1 - SEM ESCONSIDADE
              </text>
              <text x="140" y="35" text-anchor="middle" font-size="10" fill="#E8F5E8" font-family="Arial, sans-serif">
                Rio Norte-Sul (Perpendicular)
              </text>
              
              <!-- Conte√∫do -->
              <g transform="translate(30, 60)">
                <!-- Rio vertical (mais estreito que a ponte) -->
                <rect x="85" y="10" width="40" height="150" fill="url(#riverGradient)" stroke="#1565C0" stroke-width="2" rx="6" filter="url(#softShadow)"/>
                
                <!-- Setas do rio -->
                <polygon points="100,20 110,20 105,30" fill="#0D47A1"/>
                <polygon points="100,150 110,150 105,140" fill="#0D47A1"/>
                <text x="120" y="17" font-size="10" fill="#0D47A1" font-weight="600">N</text>
                <text x="120" y="163" font-size="10" fill="#0D47A1" font-weight="600">S</text>
                
                <!-- Rodovia -->
                <rect x="10" y="70" width="180" height="30" fill="url(#roadGradient)" stroke="#212121" stroke-width="1" rx="3" filter="url(#softShadow)"/>
                
                <!-- Tabuleiro retangular -->
                <rect x="75" y="62" width="60" height="46" fill="url(#deckGradient)" stroke="#9E9E9E" stroke-width="2" rx="3" filter="url(#softShadow)"/>
                
                <!-- Faixas de rolamento -->
                <line x1="75" y1="72" x2="135" y2="72" stroke="#FFD54F" stroke-width="2" stroke-dasharray="15,6"/>
                <line x1="75" y1="85" x2="135" y2="85" stroke="#FFFFFF" stroke-width="1"/>
                <line x1="75" y1="98" x2="135" y2="98" stroke="#FFD54F" stroke-width="2" stroke-dasharray="15,6"/>
                
                <!-- Guardas -->
                <rect x="75" y="59" width="60" height="3" fill="#757575" rx="1"/>
                <rect x="75" y="108" width="60" height="3" fill="#757575" rx="1"/>
                
                <!-- √Çngulo -->
                <path d="M 90 50 L 105 50 L 105 65" fill="none" stroke="#4CAF50" stroke-width="3"/>
                <text x="72" y="47" font-size="12" fill="#4CAF50" font-weight="700">90¬∞</text>
              </g>
              
              <!-- Info box -->
              <rect x="15" y="260" width="250" height="45" fill="#E8F5E8" stroke="#4CAF50" stroke-width="1" rx="6"/>
              <text x="25" y="275" font-size="10" fill="#2E7D32" font-weight="600">‚úì Tabuleiro Retangular</text>
              <text x="25" y="287" font-size="10" fill="#2E7D32">‚úì C√°lculo Estrutural Padr√£o</text>
              <text x="25" y="299" font-size="10" fill="#2E7D32">‚úì Execu√ß√£o Convencional</text>
            </g>
            
            <!-- Caso 2: COM Esconsidade (NO-SE) -->
            <g transform="translate(390, 80)">
              <!-- Card container -->
              <rect x="0" y="0" width="280" height="320" fill="#FFFFFF" stroke="#E8EAF0" stroke-width="2" rx="12" filter="url(#shadow)"/>
              
              <!-- Header do card -->
              <rect x="0" y="0" width="280" height="45" fill="#FF9800" rx="12"/>
              <rect x="0" y="33" width="280" height="12" fill="#FF9800"/>
              <text x="140" y="20" text-anchor="middle" font-size="12" font-weight="600" fill="#FFFFFF" font-family="Arial, sans-serif">
                CASO 2 - COM ESCONSIDADE
              </text>
              <text x="140" y="35" text-anchor="middle" font-size="10" fill="#FFF3E0" font-family="Arial, sans-serif">
                Rio Noroeste-Sudeste
              </text>
              
              <!-- Conte√∫do -->
              <g transform="translate(30, 60)">
                <!-- Rio diagonal NO-SE (mesmo √¢ngulo da esconsidade, mais estreito) -->
                <polygon points="85,15 115,15 145,125 115,125" fill="url(#riverGradient)" stroke="#1565C0" stroke-width="2" filter="url(#softShadow)"/>
                
                <!-- Setas do rio -->
                <polygon points="95,25 105,21 100,31" fill="#0D47A1"/>
                <polygon points="125,115 135,111 130,121" fill="#0D47A1"/>
                <text x="75" y="10" font-size="10" fill="#0D47A1" font-weight="600">NO</text>
                <text x="145" y="140" font-size="10" fill="#0D47A1" font-weight="600">SE</text>
                
                <!-- Rodovia -->
                <rect x="10" y="70" width="180" height="30" fill="url(#roadGradient)" stroke="#212121" stroke-width="1" rx="3" filter="url(#softShadow)"/>
                
                <!-- Tabuleiro esconso (paralelogramo) -->
                <polygon points="65,62 125,62 140,108 80,108" fill="url(#deckGradient)" stroke="#9E9E9E" stroke-width="2" filter="url(#softShadow)"/>
                
                <!-- Faixas de rolamento esconsas -->
                <line x1="70" y1="72" x2="130" y2="72" stroke="#FFD54F" stroke-width="2" stroke-dasharray="15,6"/>
                <line x1="75" y1="85" x2="135" y2="85" stroke="#FFFFFF" stroke-width="1"/>
                <line x1="80" y1="98" x2="140" y2="98" stroke="#FFD54F" stroke-width="2" stroke-dasharray="15,6"/>
                
                <!-- Guardas esconsas -->
                <polygon points="65,59 125,59 127,62 67,62" fill="#757575"/>
                <polygon points="80,108 140,108 142,111 82,111" fill="#757575"/>
                
                <!-- √Çngulo de esconsidade -->
                <path d="M 85 50 L 100 50 L 105 65" fill="none" stroke="#FF9800" stroke-width="3"/>
                <text x="70" y="47" font-size="12" fill="#FF9800" font-weight="700">Œ± ‚â† 90¬∞</text>
              </g>
              
              <!-- Info box -->
              <rect x="15" y="260" width="250" height="45" fill="#FFF3E0" stroke="#FF9800" stroke-width="1" rx="6"/>
              <text x="25" y="275" font-size="10" fill="#E65100" font-weight="600">‚ö† Tabuleiro Esconso</text>
              <text x="25" y="287" font-size="10" fill="#E65100">‚ö† C√°lculo Mais Complexo</text>
              <text x="25" y="299" font-size="10" fill="#E65100">‚ö† Formas Especiais</text>
            </g>
            
            <!-- Caso 3: COM Esconsidade (NE-SO) -->
            <g transform="translate(700, 80)">
              <!-- Card container -->
              <rect x="0" y="0" width="280" height="320" fill="#FFFFFF" stroke="#E8EAF0" stroke-width="2" rx="12" filter="url(#shadow)"/>
              
              <!-- Header do card -->
              <rect x="0" y="0" width="280" height="45" fill="#F44336" rx="12"/>
              <rect x="0" y="33" width="280" height="12" fill="#F44336"/>
              <text x="140" y="20" text-anchor="middle" font-size="12" font-weight="600" fill="#FFFFFF" font-family="Arial, sans-serif">
                CASO 3 - COM ESCONSIDADE
              </text>
              <text x="140" y="35" text-anchor="middle" font-size="10" fill="#FFEBEE" font-family="Arial, sans-serif">
                Rio Nordeste-Sudoeste
              </text>
              
              <!-- Conte√∫do -->
              <g transform="translate(30, 60)">
                <!-- Rio diagonal NE-SO (mesmo √¢ngulo da esconsidade, mais estreito) -->
                <polygon points="115,15 145,15 115,125 85,125" fill="url(#riverGradient)" stroke="#1565C0" stroke-width="2" filter="url(#softShadow)"/>
                
                <!-- Setas do rio -->
                <polygon points="135,25 125,21 130,31" fill="#0D47A1"/>
                <polygon points="105,115 95,111 100,121" fill="#0D47A1"/>
                <text x="150" y="10" font-size="10" fill="#0D47A1" font-weight="600">NE</text>
                <text x="70" y="140" font-size="10" fill="#0D47A1" font-weight="600">SO</text>
                
                <!-- Rodovia -->
                <rect x="10" y="70" width="180" height="30" fill="url(#roadGradient)" stroke="#212121" stroke-width="1" rx="3" filter="url(#softShadow)"/>
                
                <!-- Tabuleiro esconso oposto -->
                <polygon points="80,62 140,62 125,108 65,108" fill="url(#deckGradient)" stroke="#9E9E9E" stroke-width="2" filter="url(#softShadow)"/>
                
                <!-- Faixas de rolamento esconsas -->
                <line x1="85" y1="72" x2="135" y2="72" stroke="#FFD54F" stroke-width="2" stroke-dasharray="15,6"/>
                <line x1="80" y1="85" x2="130" y2="85" stroke="#FFFFFF" stroke-width="1"/>
                <line x1="75" y1="98" x2="125" y2="98" stroke="#FFD54F" stroke-width="2" stroke-dasharray="15,6"/>
                
                <!-- Guardas esconsas -->
                <polygon points="80,59 140,59 138,62 78,62" fill="#757575"/>
                <polygon points="65,108 125,108 123,111 63,111" fill="#757575"/>
                
                <!-- √Çngulo de esconsidade -->
                <path d="M 120 50 L 135 50 L 130 65" fill="none" stroke="#F44336" stroke-width="3"/>
                <text x="140" y="47" font-size="12" fill="#F44336" font-weight="700">Œ≤ ‚â† 90¬∞</text>
              </g>
              
              <!-- Info box -->
              <rect x="15" y="260" width="250" height="45" fill="#FFEBEE" stroke="#F44336" stroke-width="1" rx="6"/>
              <text x="25" y="275" font-size="10" fill="#C62828" font-weight="600">‚ö† Tabuleiro Esconso</text>
              <text x="25" y="287" font-size="10" fill="#C62828">‚ö† Geometria Complexa</text>
              <text x="25" y="299" font-size="10" fill="#C62828">‚ö† Armaduras Especiais</text>
            </g>
            
            <!-- Legenda moderna -->
            <g transform="translate(350, 430)">
              <rect x="0" y="0" width="500" height="40" fill="#F8F9FA" stroke="#DEE2E6" stroke-width="1" rx="6"/>
              
              <rect x="20" y="15" width="20" height="10" fill="url(#riverGradient)" rx="2"/>
              <text x="45" y="24" font-size="11" fill="#495057" font-weight="500">Rio</text>
              
              <rect x="100" y="15" width="20" height="10" fill="url(#deckGradient)" rx="2"/>
              <text x="125" y="24" font-size="11" fill="#495057" font-weight="500">Tabuleiro</text>
              
              <rect x="200" y="15" width="20" height="10" fill="url(#roadGradient)" rx="2"/>
              <text x="225" y="24" font-size="11" fill="#495057" font-weight="500">Rodovia</text>
              
              <line x1="300" y1="20" x2="320" y2="20" stroke="#FFD54F" stroke-width="3" stroke-dasharray="8,4"/>
              <text x="325" y="24" font-size="11" fill="#495057" font-weight="500">Faixa Central</text>
              
              <text x="420" y="24" font-size="11" fill="#495057" font-weight="500">üìê Œ±, Œ≤ = √Çngulos de esconsidade</text>
            </g>
          </svg>
        </div>

        <div class="diagram-explanation">
          <h3>üìã An√°lise dos Tipos de Esconsidade</h3>
          <ul>
            <li><strong>Caso 1 - SEM Esconsidade:</strong> Rio perpendicular √† rodovia (90¬∞). Tabuleiro retangular com c√°lculo estrutural padr√£o.</li>
            <li><strong>Caso 2 - COM Esconsidade (NO-SE):</strong> Rio diagonal noroeste-sudeste. Tabuleiro em formato de paralelogramo com geometria complexa.</li>
            <li><strong>Caso 3 - COM Esconsidade (NE-SO):</strong> Rio diagonal nordeste-sudoeste. Tabuleiro esconso oposto, exigindo formas especiais.</li>
          </ul>
        </div>
      </div>

      <div class="input-section">
        <!-- CSV 1 -->
        <div class="csv-section">
          <div class="section-title">üìç CSV 1 - Primeira Estrutura</div>
          <textarea
            id="csvData1"
            placeholder="Cole aqui os dados do primeiro CSV..."
          ></textarea>
          <div class="example-buttons">
            <button onclick="loadExample1()" class="example-btn">
              üìù Exemplo CSV 1 (Lat/Long)
            </button>
            <button onclick="loadExample1UTM()" class="example-btn">
              üìù Exemplo CSV 1 (UTM)
            </button>
          </div>
        </div>

        <!-- CSV 2 -->
        <div class="csv-section">
          <div class="section-title">üìç CSV 2 - Segunda Estrutura</div>
          <textarea
            id="csvData2"
            placeholder="Cole aqui os dados do segundo CSV (opcional)..."
          ></textarea>
          <div class="example-buttons">
            <button onclick="loadExample2()" class="example-btn">
              üìù Exemplo CSV 2 (UTM)
            </button>
          </div>
        </div>
      </div>

      <div class="controls">
        <button onclick="processData()">üîÑ Processar e Analisar</button>
        <button onclick="clearAll()" style="background: #dc3545;">
          üóëÔ∏è Limpar Tudo
        </button>
        <div class="zoom-controls">
          <button onclick="zoomOut()" style="background: #6c757d;">
            üîç-
          </button>
          <span id="zoomLevel">Zoom: 200%</span>
          <button onclick="zoomIn()" style="background: #6c757d;">
            üîç+
          </button>
          <button onclick="resetZoom()" style="background: #17a2b8; margin-left: 10px;">
            ‚Üª Reset
          </button>
          <button onclick="rotate45()" style="background: #28a745; margin-left: 15px;">
            üîÑ Rotacionar 22.5¬∞
          </button>
        </div>
      </div>

      <div class="legend">
        <strong>üé® Legenda de Cores (Eleva√ß√£o):</strong>
        <div class="legend-item">
          <span class="legend-color" style="background: #4caf50;"></span>
          <span>Eleva√ß√£o Baixa</span>
        </div>
        <div class="legend-item">
          <span class="legend-color" style="background: #ffeb3b;"></span>
          <span>Eleva√ß√£o M√©dia</span>
        </div>
        <div class="legend-item">
          <span class="legend-color" style="background: #ff9800;"></span>
          <span>Eleva√ß√£o Alta</span>
        </div>
        <div class="legend-item">
          <span class="legend-color" style="background: #f44336;"></span>
          <span>Eleva√ß√£o Muito Alta</span>
        </div>
        <br>
        <strong>üìè Informa√ß√µes dos Pontos:</strong>
        <span>Glob = Eleva√ß√£o Global | Rel = Eleva√ß√£o Relativa ao ponto mais alto (0,00m)</span>
        <br>
        <strong>üìê An√°lise de Esconsidade:</strong>
        <span>√Çngulo = Desvio da perpendicularidade | Largura √ötil = Largura √ó cos(√¢ngulo) | ŒîX/ŒîY = Componentes de dist√¢ncia</span>
        <br>
        <strong>üìã Formatos Suportados:</strong>
        <span>LAT/LONG | H_ORTHO/H_ORTO | Leste/Norte/Elev | Easting/Northing | M√∫ltiplos formatos CSV com detec√ß√£o autom√°tica de zona SIRGAS 2000</span>
      </div>

      <div class="visualization">
        <canvas id="canvas" width="1100" height="800"></canvas>
      </div>

      <div id="infoPanel" class="info-panel" style="display: none">
        <h3>üìä Relat√≥rio de An√°lise T√©cnica - Inclina√ß√µes e Esconsidade</h3>
        <div id="distanceInfo" class="distance-grid"></div>
        
        <!-- Resumo Executivo -->
        <div id="executiveSummary" style="margin-top: 20px; padding: 15px; background: linear-gradient(135deg, #f8f9fa, #e9ecef); border-radius: 8px; border-left: 4px solid #007bff;"></div>
      </div>

      <div id="errorMsg"></div>
      <div id="debugInfo" class="debug-info" style="display: none;"></div>
    </div>

    <script>
      // Vari√°veis globais para zoom, dados e rota√ß√£o
      let currentZoom = 2.0; // Zoom padr√£o 200%
      let currentPoints1 = {};
      let currentPoints2 = {};
      let currentRotation = 0; // Rota√ß√£o em graus
      
      // Limites t√©cnicos
      const LIMIT_TRANSVERSAL = 5.0; // 5%
      const LIMIT_LONGITUDINAL = 2.5; // 2.5%
      
      function debugLog(message) {
        console.log(message);
        const debugDiv = document.getElementById('debugInfo');
        if (debugDiv) {
          debugDiv.innerHTML += message + '<br>';
          debugDiv.style.display = 'block';
        }
      }
      
      // FUN√á√ÉO CORRIGIDA: Convers√£o de coordenadas geogr√°ficas para UTM
      function geographicToUTM(lat, lng) {
        const a = 6378137.0; // Semi-eixo maior WGS84
        const f = 1/298.257223563; // Achatamento WGS84
        const k0 = 0.9996; // Fator de escala UTM
        
        // Determinar zona UTM
        const zone = Math.floor((lng + 180) / 6) + 1;
        const centralMeridian = (zone - 1) * 6 - 180 + 3;
        
        // Converter para radianos
        const latRad = lat * Math.PI / 180;
        const lngRad = lng * Math.PI / 180;
        const centralMeridianRad = centralMeridian * Math.PI / 180;
        
        // C√°lculos UTM simplificados
        const deltaLng = lngRad - centralMeridianRad;
        
        const N = a / Math.sqrt(1 - (f * (2 - f) * Math.sin(latRad) * Math.sin(latRad)));
        const T = Math.tan(latRad) * Math.tan(latRad);
        const C = (f * (2 - f)) / (1 - f * (2 - f)) * Math.cos(latRad) * Math.cos(latRad);
        const A = deltaLng * Math.cos(latRad);
        
        // Coordenadas UTM
        const easting = k0 * N * (A + (1 - T + C) * A * A * A / 6) + 500000;
        
        // Para o hemisf√©rio sul (Brasil), adicionar 10.000.000m
        const M = a * ((1 - f/4 - 3*f*f/64) * latRad - 
                      (3*f/8 + 3*f*f/32) * Math.sin(2*latRad) + 
                      (15*f*f/256) * Math.sin(4*latRad));
        const northing = lat < 0 ? k0 * M + 10000000 : k0 * M;
        
        return { easting, northing, zone };
      }
      
      // Fun√ß√£o para determinar zona SIRGAS 2000
      function determineSirgas2000Zone(point) {
        let longitude = null;
        
        // Se temos coordenadas geogr√°ficas diretamente
        if (point.longitude && Math.abs(point.longitude) <= 180) {
          longitude = point.longitude;
        }
        // Se temos coordenadas UTM, fazer convers√£o aproximada
        else if (point.easting && point.northing) {
          longitude = approximateUTMToLongitude(point.easting, point.northing);
        }
        
        if (longitude !== null) {
          // F√≥rmula: Zona = PARTE_INTEIRA((Longitude + 180) / 6) + 1
          const zona = Math.floor((longitude + 180) / 6) + 1;
          return zona;
        }
        
        return null;
      }
      
      // Convers√£o aproximada de UTM para longitude (simplificada para Brasil)
      function approximateUTMToLongitude(easting, northing) {
        // Para o Brasil, estimativa baseada em coordenadas t√≠picas
        let estimatedZone = null;
        
        // Coordenada Leste baixa (~187500) indica zona com meridiano central mais a oeste
        if (easting < 300000) {
          if (northing > 8900000 && northing < 9100000) {
            // Regi√£o nordeste com Leste baixo - provavelmente Zona 24 ou 25
            estimatedZone = easting < 250000 ? 25 : 24;
          }
        } else if (easting < 500000) {
          estimatedZone = 24;
        } else if (easting < 700000) {
          estimatedZone = 23;
        }
        
        if (estimatedZone) {
          // Calcular longitude do meridiano central da zona
          const centralMeridian = (estimatedZone - 1) * 6 - 180 + 3; // +3 para o centro da zona
          
          // Convers√£o aproximada (simplificada)
          const deltaEasting = easting - 500000; // 500000 √© o false easting padr√£o
          const deltaLongitude = deltaEasting / 111320; // aprox metros por grau
          
          return centralMeridian + deltaLongitude;
        }
        
        return null;
      }
      
      function loadExample1() {
        const exampleData1 = `Name,Code,Lat,Long,H_GEO,H_ORTO,x,y
"05",JUSESQ,-9.8976347800,-36.4167136000,188.80925,197.1262098000,-36.4167136710,-9.8976347823
"06",JUSDIR,-9.8975431900,-36.4167583000,189.01495,197.3316011000,-36.4167583598,-9.8975431976
P-04,LD_FINAL_OAE,-9.8974730300,-36.4166092000,188.93670,197.2531865000,-36.4166092614,-9.8974730373
P-03,LE_FINAL_OAE,-9.8975631400,-36.4165642000,188.78735,197.1041407000,-36.4165642134,-9.8975631483
P-01,LE_INICIO_OAE,-9.8975029500,-36.4164419000,188.77963,197.0962773000,-36.4164419708,-9.8975029554
P-02,LD_INICIO_OAE,-9.8974121600,-36.4164865000,188.99719,197.3135310000,-36.4164865650,-9.8974121660
"07",MONDIR,-9.8972934700,-36.4162403000,188.86808,197.1841401000,-36.4162403921,-9.8972934728
"08",MONESQ,-9.8973829800,-36.4161912000,188.66533,196.9816940000,-36.4161912260,-9.8973829816`;

        document.getElementById('csvData1').value = exampleData1;
        processData();
      }

      function loadExample1UTM() {
        const exampleDataUTM = `Ponto,Codigo,Leste,Prec,Norte,Prec,Elev,Prec,Solucao,PDOP,Sate
P-01,LE INICIO PONTE,187514.122,0.017,8954447.811,0.017,102.288,0.047,RTX,0.9,29
P-02,LD INICIO PONTE,187512.661,0.023,8954459.014,0.023,101.795,0.051,RTX,0.9,29
P-03,LD FINAL DE PONTE,187493.840,0.022,8954456.634,0.022,101.843,0.048,RTX,0.9,30
P-04,LE FINAL DE PONTE,187495.294,0.023,8954445.442,0.023,102.310,0.049,RTX,0.9,30`;

        document.getElementById('csvData1').value = exampleDataUTM;
        processData();
      }

      function loadExample2() {
        const exampleData2 = `Ponto,Codigo,Leste,Prec,Norte,Prec,Elev,Prec,Solucao,PDOP,Sate
01,LE INICIO PONTE,187514.122,0.017,8954447.811,0.017,102.288,0.047,RTX,0.9,29
02,LD INICIO PONTE,187512.661,0.023,8954459.014,0.023,101.795,0.051,RTX,0.9,29
07,LD FINAL DE PONTE,187493.840,0.022,8954456.634,0.022,101.843,0.048,RTX,0.9,30
08,LE FINAL DE PONTE,187495.294,0.023,8954445.442,0.023,102.310,0.049,RTX,0.9,30`;

        document.getElementById('csvData2').value = exampleData2;
        processData();
      }

      // Fun√ß√µes de zoom
      function zoomIn() {
        currentZoom = Math.min(currentZoom * 1.2, 100.0); // Zoom m√°ximo 10000%
        updateZoomDisplay();
        redrawVisualization();
      }
      
      function zoomOut() {
        currentZoom = Math.max(currentZoom / 1.2, 0.1); // Zoom m√≠nimo 10%
        updateZoomDisplay();
        redrawVisualization();
      }
      
      function resetZoom() {
        currentZoom = 2.0; // Reset para zoom padr√£o 200%
        updateZoomDisplay();
        redrawVisualization();
      }
      
      function updateZoomDisplay() {
        const zoomPercent = Math.round(currentZoom * 100);
        document.getElementById('zoomLevel').textContent = `Zoom: ${zoomPercent}%`;
      }
      
      // Fun√ß√£o de rota√ß√£o
      function rotate45() {
        currentRotation = (currentRotation + 22.5) % 360;
        redrawVisualization();
      }
      
      function redrawVisualization() {
        if (Object.keys(currentPoints1).length > 0) {
          drawVisualization(currentPoints1, currentPoints2);
        }
      }

      function clearAll() {
        document.getElementById('csvData1').value = '';
        document.getElementById('csvData2').value = '';
        document.getElementById('infoPanel').style.display = 'none';
        document.getElementById('errorMsg').innerHTML = '';
        document.getElementById('debugInfo').innerHTML = '';
        document.getElementById('debugInfo').style.display = 'none';
        
        currentZoom = 2.0;
        currentRotation = 0;
        currentPoints1 = {};
        currentPoints2 = {};
        updateZoomDisplay();
        
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      function parseCSV(csvText) {
        if (!csvText.trim()) return [];
        
        debugLog("=== INICIANDO PARSE CSV ===");
        const lines = csvText.trim().split("\n");
        debugLog(`Total de linhas: ${lines.length}`);
        
        const firstLine = lines[0];
        debugLog(`Primeira linha: ${firstLine}`);
        
        let headers;
        let dataStartIndex = 0;

        // Detectar se a primeira linha cont√©m cabe√ßalhos
        const commonHeaders = ["Name", "Code", "CODE","codigo", "CODIGO", "C√≥digo",  "Lat", "LAT", "Long", "LONG", "x", "y", "H_ORTO", "H_ORTHO", "H_GEO", "Ponto", "Codigo", "Leste", "Norte", "Elev"];
        const hasHeaders = commonHeaders.some(header => firstLine.includes(header));
        
        if (hasHeaders) {
          headers = lines[0].split(",").map((h) => h.trim().replace(/"/g, ''));
          dataStartIndex = 1;
          debugLog(`Cabe√ßalhos detectados: ${headers.join(', ')}`);
        } else {
          headers = ["Name", "Code", "CODE","codigo", "CODIGO", "C√≥digo", "LAT", "LONG", "H_GEO", "OND_GEOIDAL", "H_ORTHO"];
          dataStartIndex = 0;
          debugLog("Usando cabe√ßalhos padr√£o");
        }

        const data = [];
        for (let i = dataStartIndex; i < lines.length; i++) {
          if (lines[i].trim() === "") continue;

          const values = lines[i].split(",");
          const row = {};
          headers.forEach((header, index) => {
            row[header] = values[index]?.trim().replace(/"/g, '') || "";
          });
          data.push(row);
          debugLog(`Linha ${i}: ${JSON.stringify(row)}`);
        }
        
        debugLog(`Total de linhas processadas: ${data.length}`);
        return data;
      }

      function calculateDistance(point1, point2) {
        // CORRE√á√ÉO: Se ambos os pontos s√£o geogr√°ficos, usar c√°lculo adequado
        if (point1.coordType === 'GEO' && point2.coordType === 'GEO') {
          const lat1Rad = point1.lat * Math.PI / 180;
          const lat2Rad = point2.lat * Math.PI / 180;
          const deltaLat = (point2.lat - point1.lat) * Math.PI / 180;
          const deltaLng = (point2.long - point1.long) * Math.PI / 180;

          const a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2) +
                    Math.cos(lat1Rad) * Math.cos(lat2Rad) *
                    Math.sin(deltaLng/2) * Math.sin(deltaLng/2);
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

          return 6371000 * c; // Raio da Terra em metros
        }

        // Para coordenadas UTM ou se temos coordenadas convertidas
        let x1, y1, x2, y2;
        
        if (point1.utmX && point1.utmY) {
          x1 = point1.utmX;
          y1 = point1.utmY;
        } else {
          x1 = parseFloat(point1.x);
          y1 = parseFloat(point1.y);
        }
        
        if (point2.utmX && point2.utmY) {
          x2 = point2.utmX;
          y2 = point2.utmY;
        } else {
          x2 = parseFloat(point2.x);
          y2 = parseFloat(point2.y);
        }

        const deltaX = x2 - x1;
        const deltaY = y2 - y1;

        let distance;

        if ((point1.coordType === 'UTM' && point2.coordType === 'UTM') || 
            (point1.coordType === 'PLANE' && point2.coordType === 'PLANE')) {
          distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        } 
        else if ((point1.coordType === 'GEO' && point2.coordType === 'GEO') ||
                 (Math.abs(x1) < 180 && Math.abs(y1) < 90 && Math.abs(x2) < 180 && Math.abs(y2) < 90)) {
          const lat1Rad = (y1 * Math.PI) / 180;
          const lat2Rad = (y2 * Math.PI) / 180;
          const avgLatRad = (lat1Rad + lat2Rad) / 2;

          const deltaLatM = deltaY * 111320;
          const deltaLonM = deltaX * 111320 * Math.cos(avgLatRad);

          distance = Math.sqrt(deltaLatM * deltaLatM + deltaLonM * deltaLonM);
        }
        else {
          distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        }

        return distance;
      }

      function calculateElevationDifference(point1, point2) {
        const elev1 = parseFloat(point1.elevation);
        const elev2 = parseFloat(point2.elevation);
        return elev2 - elev1;
      }

      function calculateInclination(point1, point2) {
        const distance = calculateDistance(point1, point2);
        const elevationDiff = calculateElevationDifference(point1, point2);
        
        if (distance === 0) return { percentage: 0, degrees: 0, ratio: "0:1" };
        
        const percentage = (Math.abs(elevationDiff) / distance) * 100;
        const degrees = Math.atan(Math.abs(elevationDiff) / distance) * (180 / Math.PI);
        const ratio = `1:${(distance / Math.abs(elevationDiff)).toFixed(1)}`;
        
        return { 
          percentage: percentage, 
          degrees: degrees, 
          ratio: ratio,
          direction: elevationDiff > 0 ? "‚ÜóÔ∏è Subida" : elevationDiff < 0 ? "‚ÜòÔ∏è Descida" : "‚û°Ô∏è Nivelado"
        };
      }

      // FUN√á√ÉO CORRIGIDA: Calcular esconsidade da ponte
      function calculateSkewAnalysis(struct) {
        if (!struct || !struct.ldInicio || !struct.leInicio || !struct.ldFinal || !struct.leFinal) {
          return null;
        }

        debugLog("=== C√ÅLCULO DE ESCONSIDADE CORRIGIDO ===");

        // CORRE√á√ÉO: Converter coordenadas para UTM se necess√°rio
        let points = [struct.ldInicio, struct.leInicio, struct.ldFinal, struct.leFinal];
        
        points.forEach(point => {
          if (point.coordType === 'GEO') {
            const utm = geographicToUTM(point.lat, point.long);
            point.utmX = utm.easting;
            point.utmY = utm.northing;
            point.utmZone = utm.zone;
            debugLog(`Convertido ${point.name}: LAT=${point.lat.toFixed(6)}, LONG=${point.long.toFixed(6)} -> UTM X=${utm.easting.toFixed(3)}, Y=${utm.northing.toFixed(3)}`);
          } else {
            point.utmX = parseFloat(point.x);
            point.utmY = parseFloat(point.y);
          }
        });

        // Usar coordenadas UTM para c√°lculos
        const ldInicio = { x: struct.ldInicio.utmX, y: struct.ldInicio.utmY };
        const leInicio = { x: struct.leInicio.utmX, y: struct.leInicio.utmY };
        const ldFinal = { x: struct.ldFinal.utmX, y: struct.ldFinal.utmY };
        const leFinal = { x: struct.leFinal.utmX, y: struct.leFinal.utmY };

        // Dist√¢ncias em X e Y entre LD_IN√çCIO e LE_IN√çCIO
        const deltaX_Inicio = Math.abs(leInicio.x - ldInicio.x);
        const deltaY_Inicio = Math.abs(leInicio.y - ldInicio.y);
        
        // Dist√¢ncias em X e Y entre LD_FINAL e LE_FINAL
        const deltaX_Final = Math.abs(leFinal.x - ldFinal.x);
        const deltaY_Final = Math.abs(leFinal.y - ldFinal.y);

        // Vetores dos eixos da ponte
        const vetorLD = {
          x: ldFinal.x - ldInicio.x,
          y: ldFinal.y - ldInicio.y
        };
        
        const vetorLE = {
          x: leFinal.x - leInicio.x,
          y: leFinal.y - leInicio.y
        };

        // √Çngulo do eixo longitudinal da ponte (m√©dia dos dois lados)
        const anguloLD = Math.atan2(vetorLD.y, vetorLD.x) * (180 / Math.PI);
        const anguloLE = Math.atan2(vetorLE.y, vetorLE.x) * (180 / Math.PI);
        const anguloEixo = (anguloLD + anguloLE) / 2;

        // Vetor transversal (in√≠cio da ponte)
        const vetorTransversal = {
          x: leInicio.x - ldInicio.x,
          y: leInicio.y - ldInicio.y
        };
        
        const anguloTransversal = Math.atan2(vetorTransversal.y, vetorTransversal.x) * (180 / Math.PI);

        // CORRE√á√ÉO: C√°lculo correto do √¢ngulo de esconsidade
        // O √¢ngulo de esconsidade √© a diferen√ßa entre o √¢ngulo transversal e 90¬∞ em rela√ß√£o ao eixo
        let anguloEsconsidade = Math.abs(anguloTransversal - (anguloEixo + 90));
        
        // CORRE√á√ÉO: Normalizar corretamente para o menor √¢ngulo (0¬∞ a 90¬∞)
        if (anguloEsconsidade > 90) {
          anguloEsconsidade = 180 - anguloEsconsidade;
        }
        
        // CORRE√á√ÉO: Garantir que o √¢ngulo esteja entre 0¬∞ e 90¬∞
        anguloEsconsidade = Math.abs(anguloEsconsidade);
        if (anguloEsconsidade > 90) {
          anguloEsconsidade = 180 - anguloEsconsidade;
        }

        debugLog(`√Çngulo LD: ${anguloLD.toFixed(2)}¬∞`);
        debugLog(`√Çngulo LE: ${anguloLE.toFixed(2)}¬∞`);
        debugLog(`√Çngulo Eixo: ${anguloEixo.toFixed(2)}¬∞`);
        debugLog(`√Çngulo Transversal: ${anguloTransversal.toFixed(2)}¬∞`);
        debugLog(`√Çngulo Esconsidade: ${anguloEsconsidade.toFixed(2)}¬∞`);

        // Larguras medidas usando coordenadas UTM
        const larguraInicio = Math.sqrt(Math.pow(leInicio.x - ldInicio.x, 2) + Math.pow(leInicio.y - ldInicio.y, 2));
        const larguraFinal = Math.sqrt(Math.pow(leFinal.x - ldFinal.x, 2) + Math.pow(leFinal.y - ldFinal.y, 2));
        const larguraMedia = (larguraInicio + larguraFinal) / 2;

        // Largura efetiva (√∫til para passagem de ve√≠culos)
        const larguraEfetiva = larguraMedia * Math.cos(anguloEsconsidade * Math.PI / 180);

        // Comprimentos dos lados
        const comprimentoLD = Math.sqrt(Math.pow(vetorLD.x, 2) + Math.pow(vetorLD.y, 2));
        const comprimentoLE = Math.sqrt(Math.pow(vetorLE.x, 2) + Math.pow(vetorLE.y, 2));
        
        // Diferen√ßa de comprimentos (indicador de esconsidade)
        const diferencaComprimentos = Math.abs(comprimentoLD - comprimentoLE);
        
        // An√°lise da geometria
        let tipoGeometria = "Ret√¢ngulo";
        let statusEsconsidade = "N√£o Esconsa";
        
        if (anguloEsconsidade > 5) {
          statusEsconsidade = "Esconsa";
          if (diferencaComprimentos > 0.5) {
            tipoGeometria = "Quadril√°tero Irregular";
          } else {
            tipoGeometria = "Paralelogramo";
          }
        } else if (diferencaComprimentos > 0.5) {
          statusEsconsidade = "Levemente Esconsa";
          tipoGeometria = "Trap√©zio";
        }

        return {
          deltaX_Inicio,
          deltaY_Inicio,
          deltaX_Final,
          deltaY_Final,
          anguloEsconsidade,
          anguloEixo,
          anguloTransversal,
          larguraInicio,
          larguraFinal,
          larguraMedia,
          larguraEfetiva,
          comprimentoLD,
          comprimentoLE,
          diferencaComprimentos,
          tipoGeometria,
          statusEsconsidade,
          perdaLargura: larguraMedia - larguraEfetiva,
          percentualPerda: ((larguraMedia - larguraEfetiva) / larguraMedia) * 100
        };
      }

      function getElevationColor(elevation, minElev, maxElev) {
        const normalized = (elevation - minElev) / (maxElev - minElev);
        
        if (normalized < 0.25) return "#4caf50"; // Verde - baixo
        else if (normalized < 0.5) return "#ffeb3b"; // Amarelo - m√©dio
        else if (normalized < 0.75) return "#ff9800"; // Laranja - alto
        else return "#f44336"; // Vermelho - muito alto
      }

      function findPoints(data) {
        debugLog("=== PROCURANDO PONTOS ===");
        const points = {};
        
        data.forEach((row, index) => {
          debugLog(`Processando linha ${index}: ${JSON.stringify(row)}`);
          
          const name = row.Name || row.Ponto || row.Code || row.Codigo || "";
          const code = row.Code || row.Codigo || row.Name || row.Ponto || "";

          debugLog(`Nome: ${name}, C√≥digo: ${code}`);

          // Verificar se √© um ponto de estrutura (OAE ou PONTE)
          const isStructurePoint = 
            code.includes("LD_INICIO_OAE") ||
            code.includes("LE_INICIO_OAE") ||
            code.includes("LD_FINAL_OAE") ||
            code.includes("LE_FINAL_OAE") ||
            name.includes("LD_INICIO_OAE") ||
            name.includes("LE_INICIO_OAE") ||
            name.includes("LD_FINAL_OAE") ||
            name.includes("LE_FINAL_OAE") ||
            // Novos formatos com PONTE
            code.includes("LD INICIO PONTE") ||
            code.includes("LE INICIO PONTE") ||
            code.includes("LD FINAL PONTE") ||
            code.includes("LE FINAL PONTE") ||
            code.includes("LD FINAL DE PONTE") ||
            code.includes("LE FINAL DE PONTE") ||
            name.includes("LD INICIO PONTE") ||
            name.includes("LE INICIO PONTE") ||
            name.includes("LD FINAL PONTE") ||
            name.includes("LE FINAL PONTE") ||
            name.includes("LD FINAL DE PONTE") ||
            name.includes("LE FINAL DE PONTE");

          if (isStructurePoint) {
            debugLog(`Ponto de estrutura encontrado: ${name || code}`);
            
            let xCoord, yCoord, elevation, lat, lng;

            // CORRE√á√ÉO: Detectar coordenadas geogr√°ficas primeiro
            if (row.LAT && row.LONG) {
              lat = parseFloat(row.LAT);
              lng = parseFloat(row.LONG);
              xCoord = lng;
              yCoord = lat;
            } else if (row.Lat && row.Long) {
              lat = parseFloat(row.Lat);
              lng = parseFloat(row.Long);
              xCoord = lng;
              yCoord = lat;
            } else if (row.Norte && row.Leste) {
              xCoord = parseFloat(row.Leste);
              yCoord = parseFloat(row.Norte);
            } else if (row.Northing && row.Easting) {
              xCoord = parseFloat(row.Easting);
              yCoord = parseFloat(row.Northing);
            } else if (row.x && row.y) {
              xCoord = parseFloat(row.x);
              yCoord = parseFloat(row.y);
            } else if (row.Long || row.LONG) {
              xCoord = parseFloat(row.Long || row.LONG);
              yCoord = parseFloat(row.Lat || row.LAT);
              lat = parseFloat(row.Lat || row.LAT);
              lng = parseFloat(row.Long || row.LONG);
            }

            // Eleva√ß√£o - suporte ampliado
            elevation = parseFloat(row.H_ORTHO) || 
                       parseFloat(row.H_ORTO) || 
                       parseFloat(row.Elev) || 
                       parseFloat(row.Elevation) || 
                       parseFloat(row.H_GEO) || 
                       parseFloat(row.Altura) || 
                       parseFloat(row.Z) || 0;

            debugLog(`Coordenadas: x=${xCoord}, y=${yCoord}, eleva√ß√£o=${elevation}`);

            if (!isNaN(xCoord) && !isNaN(yCoord) && !isNaN(elevation)) {
              // Normalizar nomes para compatibilidade
              let normalizedCode = code || name;
              
              // Converter formatos de PONTE para OAE para compatibilidade
              normalizedCode = normalizedCode
                .replace("LD INICIO PONTE", "LD_INICIO_OAE")
                .replace("LE INICIO PONTE", "LE_INICIO_OAE")
                .replace("LD FINAL PONTE", "LD_FINAL_OAE")
                .replace("LE FINAL PONTE", "LE_FINAL_OAE")
                .replace("LD FINAL DE PONTE", "LD_FINAL_OAE")
                .replace("LE FINAL DE PONTE", "LE_FINAL_OAE");

              const pointData = {
                x: xCoord,
                y: yCoord,
                elevation: elevation,
                lat: lat || yCoord,
                long: lng || xCoord,
                longitude: lng || null,
                easting: parseFloat(row.Leste || row.Easting) || xCoord,
                northing: parseFloat(row.Norte || row.Northing) || yCoord,
                name: normalizedCode,
                code: normalizedCode,
                originalName: name,
                originalCode: code,
                // CORRE√á√ÉO: Detec√ß√£o mais precisa do tipo de coordenada
                coordType: (lat && lng && Math.abs(lat) <= 90 && Math.abs(lng) <= 180) ? 'GEO' :
                          ((row.Norte && row.Leste) || (row.Northing && row.Easting)) ? 'UTM' : 'PLANE'
              };
              
              // Determinar zona SIRGAS
              const sirgas = determineSirgas2000Zone(pointData);
              if (sirgas) {
                pointData.sirgasZone = sirgas;
                debugLog(`Zona SIRGAS determinada: ${sirgas}S`);
              }
              
              debugLog(`Ponto criado: ${JSON.stringify(pointData)}`);
              debugLog(`Tipo de coordenada: ${pointData.coordType}`);
              
              if (normalizedCode) points[normalizedCode] = pointData;
              if (code && code !== normalizedCode) points[code] = pointData;
              if (name && name !== code && name !== normalizedCode) points[name] = pointData;
            } else {
              debugLog(`Erro: coordenadas ou eleva√ß√£o inv√°lidas`);
            }
          }
        });
        
        debugLog(`Total de pontos encontrados: ${Object.keys(points).length}`);
        debugLog(`Pontos: ${Object.keys(points).join(', ')}`);
        return points;
      }

      // Fun√ß√£o para determinar se inclina√ß√µes s√£o problem√°ticas (com novos limites)
      function getInclinationStatus(inclination, isTransversal = false) {
        const limit = isTransversal ? LIMIT_TRANSVERSAL : LIMIT_LONGITUDINAL;
        
        if (inclination.percentage > limit) {
          return { 
            class: "critical-warning-card", 
            icon: "üö®", 
            text: `ACIMA DO LIMITE (>${limit}%)`,
            color: "#d32f2f"
          };
        } else if (inclination.percentage > limit * 0.8) {
          return { 
            class: "warning-card", 
            icon: "‚ö†Ô∏è", 
            text: `Pr√≥ximo ao Limite (${(limit * 0.8).toFixed(1)}-${limit}%)`,
            color: "#ff5722"
          };
        } else if (inclination.percentage > limit * 0.5) {
          return { 
            class: "acceptable-card", 
            icon: "üî∂", 
            text: `Moderada (${(limit * 0.5).toFixed(1)}-${(limit * 0.8).toFixed(1)}%)`,
            color: "#ff9800"
          };
        } else {
          return { 
            class: "good-card", 
            icon: "‚úÖ", 
            text: `Dentro do Limite (<${(limit * 0.5).toFixed(1)}%)`,
            color: "#4caf50"
          };
        }
      }

      function drawVisualization(points1, points2 = {}) {
        debugLog("=== INICIANDO DESENHO ===");
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        let allStructurePoints = [];
        
        if (Object.keys(points1).length > 0) {
          allStructurePoints = allStructurePoints.concat(Object.values(points1));
        }
        
        if (Object.keys(points2).length > 0) {
          allStructurePoints = allStructurePoints.concat(Object.values(points2));
        }
        
        debugLog(`Total pontos para desenhar: ${allStructurePoints.length}`);
        
        if (allStructurePoints.length === 0) {
          debugLog("ERRO: Nenhum ponto para desenhar");
          return;
        }

        // CORRE√á√ÉO: Converter coordenadas geogr√°ficas para UTM para visualiza√ß√£o
        allStructurePoints.forEach(point => {
          if (point.coordType === 'GEO' && !point.utmX) {
            const utm = geographicToUTM(point.lat, point.long);
            point.utmX = utm.easting;
            point.utmY = utm.northing;
          }
        });

        // Calcular min/max para coordenadas (usar UTM se dispon√≠vel)
        const getX = (p) => p.utmX || p.x;
        const getY = (p) => p.utmY || p.y;
        
        const minX = Math.min(...allStructurePoints.map(getX));
        const maxX = Math.max(...allStructurePoints.map(getX));
        const minY = Math.min(...allStructurePoints.map(getY));
        const maxY = Math.max(...allStructurePoints.map(getY));
        
        const minElev = Math.min(...allStructurePoints.map((p) => p.elevation));
        const maxElev = Math.max(...allStructurePoints.map((p) => p.elevation));
        
        debugLog(`Coordenadas - X: ${minX} a ${maxX}, Y: ${minY} a ${maxY}`);
        debugLog(`Eleva√ß√µes - Min: ${minElev}, Max: ${maxElev}`);

        const margin = 120;
        
        const dataRangeX = maxX - minX;
        const dataRangeY = maxY - minY;
        
        const rotationRad = (currentRotation * Math.PI) / 180;
        const cosTheta = Math.abs(Math.cos(rotationRad));
        const sinTheta = Math.abs(Math.sin(rotationRad));
        
        const effectiveWidth = dataRangeX * cosTheta + dataRangeY * sinTheta;
        const effectiveHeight = dataRangeX * sinTheta + dataRangeY * cosTheta;
        
        const scaleX = (canvas.width - 2 * margin) / effectiveWidth;
        const scaleY = (canvas.height - 2 * margin) / effectiveHeight;
        const scaleFactor = Object.keys(points2).length > 0 ? 0.3 : 0.5;
        const scale = Math.min(scaleX, scaleY) * scaleFactor * currentZoom;

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        function toCanvasCoords(point) {
          const x = getX(point);
          const y = getY(point);
          
          const relX = x - (minX + maxX) / 2;
          const relY = y - (minY + maxY) / 2;
          
          const rotationRad = (currentRotation * Math.PI) / 180;
          const cosTheta = Math.cos(rotationRad);
          const sinTheta = Math.sin(rotationRad);
          
          const rotatedX = relX * cosTheta - relY * sinTheta;
          const rotatedY = relX * sinTheta + relY * cosTheta;
          
          return {
            x: centerX + rotatedX * scale,
            y: centerY - rotatedY * scale,
          };
        }

        function drawStructure(points, color, label) {
          debugLog(`Desenhando estrutura ${label}`);
          
          const ldInicio = Object.values(points).find(p => 
            p.code.includes("LD_INICIO_OAE") || 
            p.name.includes("LD_INICIO_OAE") ||
            p.originalCode.includes("LD_INICIO_OAE") ||
            p.originalName.includes("LD_INICIO_OAE")
          );
          
          const leInicio = Object.values(points).find(p => 
            p.code.includes("LE_INICIO_OAE") || 
            p.name.includes("LE_INICIO_OAE") ||
            p.originalCode.includes("LE_INICIO_OAE") ||
            p.originalName.includes("LE_INICIO_OAE")
          );
          
          const ldFinal = Object.values(points).find(p => 
            p.code.includes("LD_FINAL_OAE") || 
            p.name.includes("LD_FINAL_OAE") ||
            p.originalCode.includes("LD_FINAL_OAE") ||
            p.originalName.includes("LD_FINAL_OAE")
          );
          
          const leFinal = Object.values(points).find(p => 
            p.code.includes("LE_FINAL_OAE") || 
            p.name.includes("LE_FINAL_OAE") ||
            p.originalCode.includes("LE_FINAL_OAE") ||
            p.originalName.includes("LE_FINAL_OAE")
          );

          debugLog(`Pontos encontrados - LD In√≠cio: ${!!ldInicio}, LE In√≠cio: ${!!leInicio}, LD Final: ${!!ldFinal}, LE Final: ${!!leFinal}`);

          if (!ldInicio || !leInicio || !ldFinal || !leFinal) {
            debugLog("ERRO: Nem todos os pontos da estrutura foram encontrados");
            return null;
          }

          const ldInicioCanvas = toCanvasCoords(ldInicio);
          const leInicioCanvas = toCanvasCoords(leInicio);
          const ldFinalCanvas = toCanvasCoords(ldFinal);
          const leFinalCanvas = toCanvasCoords(leFinal);

          // Desenhar ret√¢ngulo
          ctx.strokeStyle = color;
          const rectLineWidth = Math.max(1, Math.min(4, 2 * Math.sqrt(currentZoom)));
          ctx.lineWidth = rectLineWidth;
          ctx.beginPath();
          ctx.moveTo(ldInicioCanvas.x, ldInicioCanvas.y);
          ctx.lineTo(leInicioCanvas.x, leInicioCanvas.y);
          ctx.lineTo(leFinalCanvas.x, leFinalCanvas.y);
          ctx.lineTo(ldFinalCanvas.x, ldFinalCanvas.y);
          ctx.closePath();
          ctx.stroke();

          // Preencher ret√¢ngulo com transpar√™ncia
          const alpha = color === "#007bff" ? "0.08" : "0.04";
          ctx.fillStyle = color.replace("rgb", "rgba").replace(")", `, ${alpha})`);
          if (color.startsWith("#")) {
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
          }
          ctx.fill();

          // Desenhar pontos com cores baseadas na eleva√ß√£o
          const pointData = [
            { point: ldInicio, canvas: ldInicioCanvas, baseColor: "#dc3545", label: `LD IN√çCIO ${label}` },
            { point: leInicio, canvas: leInicioCanvas, baseColor: "#28a745", label: `LE IN√çCIO ${label}` },
            { point: ldFinal, canvas: ldFinalCanvas, baseColor: "#dc3545", label: `LD FINAL ${label}` },
            { point: leFinal, canvas: leFinalCanvas, baseColor: "#28a745", label: `LE FINAL ${label}` },
          ];

          pointData.forEach(({ point, canvas, baseColor, label }) => {
            const elevationColor = getElevationColor(point.elevation, minElev, maxElev);
            
            ctx.fillStyle = baseColor;
            ctx.beginPath();
            const pointRadius = Math.max(2, Math.min(8, 4 * Math.sqrt(currentZoom)));
            ctx.arc(canvas.x, canvas.y, pointRadius, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = elevationColor;
            ctx.beginPath();
            ctx.arc(canvas.x, canvas.y, pointRadius * 0.7, 0, 2 * Math.PI);
            ctx.fill();

            const zoomFactor = Math.max(0.3, Math.min(2.0, 2.0 / Math.sqrt(currentZoom)));
            
            ctx.fillStyle = "#333";
            const fontSize = Math.max(4, 12 * zoomFactor);
            ctx.font = `${fontSize}px Arial`;
            ctx.textAlign = "center";
            const labelOffset = Math.max(4, 15 * zoomFactor);
            ctx.fillText(label, canvas.x, canvas.y - labelOffset);
            
            const relativeElev = point.elevation - maxElev;
            
            const elevFontSize = Math.max(3, 9 * zoomFactor);
            ctx.font = `${elevFontSize}px Arial`;
            
            ctx.fillStyle = "#555";
            const elevOffset1 = Math.max(2, 8 * zoomFactor);
            const elevOffset2 = Math.max(4, 16 * zoomFactor);
            ctx.fillText(`Glob: ${point.elevation.toFixed(3)}m`, canvas.x, canvas.y + labelOffset + elevOffset1);
            
            if (Math.abs(relativeElev) < 0.001) {
              ctx.fillStyle = "#ff0000";
              ctx.font = `bold ${elevFontSize}px Arial`;
            } else {
              ctx.fillStyle = "#666";
              ctx.font = `${elevFontSize}px Arial`;
            }
            
            ctx.fillText(`Rel: ${relativeElev.toFixed(3)}m`, canvas.x, canvas.y + labelOffset + elevOffset2);
          });

          return { ldInicio, leInicio, ldFinal, leFinal };
        }

        const struct1 = drawStructure(points1, "#007bff", "(1)");
        const struct2 = Object.keys(points2).length > 0 ? drawStructure(points2, "#e91e63", "(2)") : null;

        // Desenhar linha de conex√£o
        if (struct1 && struct2) {
          const leInicio1Canvas = toCanvasCoords(struct1.leInicio);
          const ldInicio2Canvas = toCanvasCoords(struct2.ldInicio);

          ctx.strokeStyle = "#ff9800";
          const lineWidth = Math.max(1, Math.min(6, 3 * Math.sqrt(currentZoom)));
          ctx.lineWidth = lineWidth;
          const dashLength = Math.max(4, Math.min(20, 12 * Math.sqrt(currentZoom)));
          ctx.setLineDash([dashLength, dashLength/2]);
          ctx.beginPath();
          ctx.moveTo(leInicio1Canvas.x, leInicio1Canvas.y);
          ctx.lineTo(ldInicio2Canvas.x, ldInicio2Canvas.y);
          ctx.stroke();
          ctx.setLineDash([]);

          const zoomFactor = Math.max(0.3, Math.min(2.0, 2.0 / Math.sqrt(currentZoom)));
          const offsetDistance = Math.max(40, Math.min(150, 80 * Math.sqrt(currentZoom)));
          
          const rotationRad = (currentRotation * Math.PI) / 180;
          const offsetX = offsetDistance * Math.cos(-rotationRad);
          const offsetY = offsetDistance * Math.sin(-rotationRad);
          
          const midX = (leInicio1Canvas.x + ldInicio2Canvas.x) / 2 + offsetX;
          const midY = (leInicio1Canvas.y + ldInicio2Canvas.y) / 2 + offsetY;
          const crossDistance = calculateDistance(struct1.leInicio, struct2.ldInicio);
          
          const textWidth = Math.max(60, 110 * zoomFactor);
          const textHeight = Math.max(20, 35 * zoomFactor);
          ctx.fillStyle = "rgba(255, 255, 255, 0.95)";
          ctx.fillRect(midX - textWidth/2, midY - textHeight/2, textWidth, textHeight);
          
          ctx.strokeStyle = "#ff9800";
          ctx.lineWidth = 1;
          ctx.strokeRect(midX - textWidth/2, midY - textHeight/2, textWidth, textHeight);
          
          ctx.fillStyle = "#ff9800";
          const crossFontSize = Math.max(6, 18 * zoomFactor);
          ctx.font = `bold ${crossFontSize}px Arial`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(`${crossDistance.toFixed(3)}m`, midX, midY);
        }

        debugLog("Desenho conclu√≠do, chamando showDistanceInfo");
        showDistanceInfo(struct1, struct2);
      }

      function showDistanceInfo(struct1, struct2) {
        debugLog("=== GERANDO RELAT√ìRIO DE CONFORMIDADE ===");
        const infoPanel = document.getElementById("infoPanel");
        const distanceInfo = document.getElementById("distanceInfo");

        if (!struct1) {
          debugLog("ERRO: struct1 √© null, n√£o √© poss√≠vel gerar relat√≥rio");
          return;
        }

        let html = '';

        // INFORMA√á√ïES DO SISTEMA DE COORDENADAS E ZONA SIRGAS
        const ldInicio1 = Object.values(struct1).find(p => 
          p && (p.code.includes("LD_INICIO_OAE") || p.name.includes("LD_INICIO_OAE"))
        );
        
        let struct2LdInicio = null;
        if (struct2) {
          struct2LdInicio = Object.values(struct2).find(p => 
            p && (p.code.includes("LD_INICIO_OAE") || p.name.includes("LD_INICIO_OAE"))
          );
        }

        if (ldInicio1) {
          html += `
            <div class="distance-card" style="background: linear-gradient(135deg, #e3f2fd, #f8f9fa); border: 3px solid #1976d2; margin-bottom: 20px; grid-column: 1 / -1;">
              <div><strong>üó∫Ô∏è SISTEMA DE COORDENADAS DETECTADO</strong></div>
              <div style="margin-top: 10px;">
                <div style="font-size: 16px; font-weight: bold; color: #1976d2;">
                  ${ldInicio1.sirgasZone ? `SIRGAS 2000 / UTM Zone ${ldInicio1.sirgasZone}S` : 'Sistema n√£o identificado automaticamente'}
                </div>
                ${ldInicio1.sirgasZone ? `
                <div style="font-size: 14px; color: #1565c0; margin-top: 5px;">
                  üìç C√≥digo EPSG: ${31984 + ldInicio1.sirgasZone - 17} (Zona ${ldInicio1.sirgasZone}S)
                </div>
                <div style="font-size: 12px; color: #666; margin-top: 8px;">
                  <strong>Estrutura 1:</strong> Tipo: ${ldInicio1.coordType} | ${ldInicio1.coordType === 'GEO' ? `LAT: ${ldInicio1.lat.toFixed(6)}, LONG: ${ldInicio1.long.toFixed(6)}` : `E: ${ldInicio1.easting?.toFixed(3)}m, N: ${ldInicio1.northing?.toFixed(3)}m`}
                  ${struct2LdInicio && struct2LdInicio.sirgasZone ? `<br><strong>Estrutura 2:</strong> Zona ${struct2LdInicio.sirgasZone}S detectada` : ''}
                </div>
                ` : `
                <div style="font-size: 12px; color: #ff9800; margin-top: 5px;">
                  ‚ö†Ô∏è Para determina√ß√£o autom√°tica da zona SIRGAS, utilize coordenadas geogr√°ficas ou UTM
                </div>
                `}
              </div>
            </div>
          `;
        }

        // C√°lculos estrutura 1
        const dist1Inicio = calculateDistance(struct1.ldInicio, struct1.leInicio);
        const dist1Final = calculateDistance(struct1.ldFinal, struct1.leFinal);
        const dist1LD = calculateDistance(struct1.ldInicio, struct1.ldFinal);
        const dist1LE = calculateDistance(struct1.leInicio, struct1.leFinal);
        const media1Largura = (dist1Inicio + dist1Final) / 2;
        const media1Comprimento = (dist1LD + dist1LE) / 2;

        // AN√ÅLISES DE ELEVA√á√ÉO ESTRUTURA 1
        const elev1_LD_LE_Inicio = calculateElevationDifference(struct1.ldInicio, struct1.leInicio);
        const elev1_LD_LE_Final = calculateElevationDifference(struct1.ldFinal, struct1.leFinal);
        const elev1_Inicio_Final_LD = calculateElevationDifference(struct1.ldInicio, struct1.ldFinal);
        const elev1_Inicio_Final_LE = calculateElevationDifference(struct1.leInicio, struct1.leFinal);

        // AN√ÅLISE DE ESCONSIDADE ESTRUTURA 1
        const skew1 = calculateSkewAnalysis(struct1);

        // INCLINA√á√ïES ESTRUTURA 1
        const incl1_LD_LE_Inicio = calculateInclination(struct1.ldInicio, struct1.leInicio);
        const incl1_LD_LE_Final = calculateInclination(struct1.ldFinal, struct1.leFinal);
        const incl1_Inicio_Final_LD = calculateInclination(struct1.ldInicio, struct1.ldFinal);
        const incl1_Inicio_Final_LE = calculateInclination(struct1.leInicio, struct1.leFinal);

        // AN√ÅLISE COMPARATIVA PRIMEIRO se tiver 2 estruturas
        if (struct2) {
          const dist2Inicio = calculateDistance(struct2.ldInicio, struct2.leInicio);
          const dist2Final = calculateDistance(struct2.ldFinal, struct2.leFinal);
          const dist2LD = calculateDistance(struct2.ldInicio, struct2.ldFinal);
          const dist2LE = calculateDistance(struct2.leInicio, struct2.leFinal);
          const media2Largura = (dist2Inicio + dist2Final) / 2;
          const media2Comprimento = (dist2LD + dist2LE) / 2;

          // AN√ÅLISES ENTRE ESTRUTURAS
          const crossDistance = calculateDistance(struct1.leInicio, struct2.ldInicio);
          const crossElevation = calculateElevationDifference(struct1.leInicio, struct2.ldInicio);
          const crossInclination = calculateInclination(struct1.leInicio, struct2.ldInicio);
          
          // An√°lises comparativas
          const diferencaLargura = Math.abs(media1Largura - media2Largura);
          const diferencaComprimento = Math.abs(media1Comprimento - media2Comprimento);
          
          // M√©dias gerais entre as duas estruturas
          const mediaGeralLargura = (media1Largura + media2Largura) / 2;
          const mediaGeralComprimento = (media1Comprimento + media2Comprimento) / 2;

          // C√°lculos estrutura 2 para eleva√ß√£o
          const elev2_LD_LE_Inicio = calculateElevationDifference(struct2.ldInicio, struct2.leInicio);
          const elev2_LD_LE_Final = calculateElevationDifference(struct2.ldFinal, struct2.leFinal);
          const elev2_Inicio_Final_LD = calculateElevationDifference(struct2.ldInicio, struct2.ldFinal);
          const elev2_Inicio_Final_LE = calculateElevationDifference(struct2.leInicio, struct2.leFinal);

          const incl2_LD_LE_Inicio = calculateInclination(struct2.ldInicio, struct2.leInicio);
          const incl2_LD_LE_Final = calculateInclination(struct2.ldFinal, struct2.leFinal);
          const incl2_Inicio_Final_LD = calculateInclination(struct2.ldInicio, struct2.ldFinal);
          const incl2_Inicio_Final_LE = calculateInclination(struct2.leInicio, struct2.leFinal);

          // AN√ÅLISE DE ESCONSIDADE ESTRUTURA 2
          const skew2 = calculateSkewAnalysis(struct2);

          // Calcular dist√¢ncias X e Y
          let deltaX = 0;
          let deltaY = 0;
          
          if (struct1.leInicio && struct2.ldInicio) {
            const x1 = parseFloat(struct1.leInicio.x);
            const y1 = parseFloat(struct1.leInicio.y);
            const x2 = parseFloat(struct2.ldInicio.x);
            const y2 = parseFloat(struct2.ldInicio.y);
            
            if (!isNaN(x1) && !isNaN(y1) && !isNaN(x2) && !isNaN(y2)) {
              deltaX = Math.abs(x2 - x1);
              deltaY = Math.abs(y2 - y1);
              
              if ((struct1.leInicio.coordType === 'UTM' && struct2.ldInicio.coordType === 'UTM') || 
                  (struct1.leInicio.coordType === 'PLANE' && struct2.ldInicio.coordType === 'PLANE')) {
                // deltaX e deltaY j√° est√£o em metros
              }
              else if ((struct1.leInicio.coordType === 'GEO' && struct2.ldInicio.coordType === 'GEO') ||
                       (Math.abs(x1) < 180 && Math.abs(y1) < 90 && Math.abs(x2) < 180 && Math.abs(y2) < 90)) {
                const avgLatRad = ((y1 + y2) / 2 * Math.PI) / 180;
                deltaX = deltaX * 111320 * Math.cos(avgLatRad);
                deltaY = deltaY * 111320;
              }
            }
          }
          
          // Status da inclina√ß√£o entre estruturas (considerar como longitudinal)
          const crossStatus = getInclinationStatus(crossInclination, false);
          
          html += `
            <div class="distance-card cross-section">
              <div><strong>üîç AN√ÅLISE COMPARATIVA ENTRE ESTRUTURAS</strong></div>
            </div>
            <div class="distance-card cross-distance-card">
              <div><strong>üåâ Dist√¢ncia Entre Estruturas</strong></div>
              <div class="distance-value cross-distance-value">${crossDistance.toFixed(3)} m</div>
              <small>LE_IN√çCIO (1) ‚Üî LD_IN√çCIO (2)</small>
            </div>
            <div class="distance-card elevation-analysis-card">
              <div><strong>üìè Diferen√ßa de Eleva√ß√£o</strong></div>
              <div class="elevation-value" style="color: ${crossElevation >= 0 ? '#4caf50' : '#f44336'};">${crossElevation >= 0 ? '+' : ''}${crossElevation.toFixed(3)} m</div>
              <small>Entre estruturas (LE1‚ÜíLD2)</small>
            </div>
            <div class="distance-card ${crossStatus.class}">
              <div><strong>${crossStatus.icon} Inclina√ß√£o Entre Estruturas</strong></div>
              <div class="inclination-value" style="color: ${crossStatus.color};">${crossInclination.percentage.toFixed(2)}% (${crossInclination.degrees.toFixed(1)}¬∞)</div>
              <small>${crossInclination.direction} - ${crossStatus.text}</small>
              <div style="font-size: 11px; margin-top: 5px; color: #666;">Limite longitudinal: ‚â§${LIMIT_LONGITUDINAL}%</div>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #f8f9fa, #e9ecef); border: 2px solid #6c757d;">
              <div><strong>üìê Dist√¢ncia em X</strong></div>
              <div class="distance-value" style="color: #6c757d;">${deltaX.toFixed(3)} m</div>
              <small>Diferen√ßa horizontal</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #f8f9fa, #e9ecef); border: 2px solid #6c757d;">
              <div><strong>üìê Dist√¢ncia em Y</strong></div>
              <div class="distance-value" style="color: #6c757d;">${deltaY.toFixed(3)} m</div>
              <small>Diferen√ßa vertical</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #e3f2fd, #f3e5f5); border: 2px solid #9c27b0;">
              <div><strong>üìè M√©dia Geral Largura</strong></div>
              <div class="distance-value" style="color: #9c27b0;">${mediaGeralLargura.toFixed(3)} m</div>
              <small>(Est.1 + Est.2) √∑ 2</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #e8f5e8, #fff3e0); border: 2px solid #ff9800;">
              <div><strong>üìê M√©dia Geral Comprimento</strong></div>
              <div class="distance-value" style="color: #ff9800;">${mediaGeralComprimento.toFixed(3)} m</div>
              <small>(Est.1 + Est.2) √∑ 2</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #ffebee, #f3e5f5); border: 2px solid #e91e63;">
              <div><strong>Diferen√ßa de Larguras</strong></div>
              <div class="distance-value" style="color: #e91e63;">${diferencaLargura.toFixed(3)} m</div>
              <small>|Estrutura 1 - Estrutura 2|</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #e8f5e8, #e0f2f1); border: 2px solid #4caf50;">
              <div><strong>Diferen√ßa de Comprimentos</strong></div>
              <div class="distance-value" style="color: #4caf50;">${diferencaComprimento.toFixed(3)} m</div>
              <small>|Estrutura 1 - Estrutura 2|</small>
            </div>
          `;
        }

        // ESTRUTURA 1 - DIST√ÇNCIAS E ELEVA√á√ïES
        html += `
          <div class="section-divider"></div>
          <div class="distance-card structure-section">
            <div><strong>üèóÔ∏è ESTRUTURA 1 (AZUL) - Dimens√µes</strong></div>
          </div>
          <div class="distance-card">
            <div><strong>Largura In√≠cio</strong></div>
            <div class="distance-value">${dist1Inicio.toFixed(3)} m</div>
            <small>LD_IN√çCIO ‚Üî LE_IN√çCIO</small>
          </div>
          <div class="distance-card">
            <div><strong>Largura Final</strong></div>
            <div class="distance-value">${dist1Final.toFixed(3)} m</div>
            <small>LD_FINAL ‚Üî LE_FINAL</small>
          </div>
          <div class="distance-card" style="background: linear-gradient(135deg, #e3f2fd, #f3e5f5); border: 2px solid #9c27b0;">
            <div><strong>üìè M√©dia Largura</strong></div>
            <div class="distance-value" style="color: #9c27b0;">${media1Largura.toFixed(3)} m</div>
            <small>Estrutura 1</small>
          </div>
          <div class="distance-card">
            <div><strong>Comprimento LD</strong></div>
            <div class="distance-value">${dist1LD.toFixed(3)} m</div>
            <small>LD_IN√çCIO ‚Üî LD_FINAL</small>
          </div>
          <div class="distance-card">
            <div><strong>Comprimento LE</strong></div>
            <div class="distance-value">${dist1LE.toFixed(3)} m</div>
            <small>LE_IN√çCIO ‚Üî LE_FINAL</small>
          </div>
          <div class="distance-card" style="background: linear-gradient(135deg, #e8f5e8, #fff3e0); border: 2px solid #ff9800;">
            <div><strong>üìê M√©dia Comprimento</strong></div>
            <div class="distance-value" style="color: #ff9800;">${media1Comprimento.toFixed(3)} m</div>
            <small>Estrutura 1</small>
          </div>
          
          <div class="distance-card structure-section">
            <div><strong>üìê ESTRUTURA 1 (AZUL) - An√°lise de Esconsidade</strong></div>
          </div>
          <div class="distance-card" style="background: linear-gradient(135deg, #fff3e0, #e8f5e8); border: 2px solid #ff9800;">
            <div><strong>üìè √Çngulo de Esconsidade</strong></div>
            <div class="distance-value" style="color: #ff9800;">${skew1.anguloEsconsidade.toFixed(2)}¬∞</div>
            <small>${skew1.statusEsconsidade} - ${skew1.tipoGeometria}</small>
          </div>
          <div class="distance-card" style="background: linear-gradient(135deg, #e3f2fd, #f3e5f5); border: 2px solid #2196f3;">
            <div><strong>üìê Largura √ötil (Efetiva)</strong></div>
            <div class="distance-value" style="color: #2196f3;">${skew1.larguraEfetiva.toFixed(3)} m</div>
            <small>Largura real para passagem de ve√≠culos</small>
          </div>
          <div class="distance-card" style="background: linear-gradient(135deg, #ffebee, #fff3e0); border: 2px solid #f44336;">
            <div><strong>üìâ Perda de Largura</strong></div>
            <div class="distance-value" style="color: #f44336;">${skew1.perdaLargura.toFixed(3)} m (${skew1.percentualPerda.toFixed(1)}%)</div>
            <small>Redu√ß√£o devido √† esconsidade</small>
          </div>
          <div class="distance-card" style="background: linear-gradient(135deg, #f8f9fa, #e9ecef); border: 2px solid #6c757d;">
            <div><strong>üìè Dist√¢ncia em X (LD‚ÜîLE In√≠cio)</strong></div>
            <div class="distance-value" style="color: #6c757d;">${skew1.deltaX_Inicio.toFixed(3)} m</div>
            <small>Componente horizontal</small>
          </div>
          <div class="distance-card" style="background: linear-gradient(135deg, #f8f9fa, #e9ecef); border: 2px solid #6c757d;">
            <div><strong>üìê Dist√¢ncia em Y (LD‚ÜîLE In√≠cio)</strong></div>
            <div class="distance-value" style="color: #6c757d;">${skew1.deltaY_Inicio.toFixed(3)} m</div>
            <small>Componente vertical</small>
          </div>
          <div class="distance-card" style="background: linear-gradient(135deg, #e8f5e8, #fff3e0); border: 2px solid #4caf50;">
            <div><strong>‚öñÔ∏è Diferen√ßa de Comprimentos</strong></div>
            <div class="distance-value" style="color: #4caf50;">${skew1.diferencaComprimentos.toFixed(3)} m</div>
            <small>|Comprimento LD - Comprimento LE|</small>
          </div>
          
          <div class="distance-card elevation-section">
            <div><strong>üìè ESTRUTURA 1 - An√°lise de Eleva√ß√£o</strong></div>
          </div>
          <div class="distance-card elevation-analysis-card">
            <div><strong>Diferen√ßa LD‚ÜîLE (In√≠cio com In√≠cio)</strong></div>
            <div class="elevation-value" style="color: ${elev1_LD_LE_Inicio >= 0 ? '#4caf50' : '#f44336'};">${elev1_LD_LE_Inicio >= 0 ? '+' : ''}${elev1_LD_LE_Inicio.toFixed(3)} m</div>
            <small>Inclina√ß√£o transversal - mesmo ponto</small>
          </div>
          <div class="distance-card elevation-analysis-card">
            <div><strong>Diferen√ßa LD‚ÜîLE (Final com Final)</strong></div>
            <div class="elevation-value" style="color: ${elev1_LD_LE_Final >= 0 ? '#4caf50' : '#f44336'};">${elev1_LD_LE_Final >= 0 ? '+' : ''}${elev1_LD_LE_Final.toFixed(3)} m</div>
            <small>Inclina√ß√£o transversal - mesmo ponto</small>
          </div>
          <div class="distance-card elevation-analysis-card">
            <div><strong>Diferen√ßa LD: In√≠cio‚ÜîFinal (Direito com Direito)</strong></div>
            <div class="elevation-value" style="color: ${elev1_Inicio_Final_LD >= 0 ? '#4caf50' : '#f44336'};">${elev1_Inicio_Final_LD >= 0 ? '+' : ''}${elev1_Inicio_Final_LD.toFixed(3)} m</div>
            <small>Inclina√ß√£o longitudinal - mesmo lado</small>
          </div>
          <div class="distance-card elevation-analysis-card">
            <div><strong>Diferen√ßa LE: In√≠cio‚ÜîFinal (Esquerdo com Esquerdo)</strong></div>
            <div class="elevation-value" style="color: ${elev1_Inicio_Final_LE >= 0 ? '#4caf50' : '#f44336'};">${elev1_Inicio_Final_LE >= 0 ? '+' : ''}${elev1_Inicio_Final_LE.toFixed(3)} m</div>
            <small>Inclina√ß√£o longitudinal - mesmo lado</small>
          </div>
          
          <div class="distance-card elevation-section">
            <div><strong>üìê ESTRUTURA 1 - Verifica√ß√£o de Conformidade</strong></div>
          </div>
        `;

        // Verifica√ß√£o de conformidade para estrutura 1
        const status1_LD_LE_Inicio = getInclinationStatus(incl1_LD_LE_Inicio, true);
        const status1_LD_LE_Final = getInclinationStatus(incl1_LD_LE_Final, true);
        const status1_Inicio_Final_LD = getInclinationStatus(incl1_Inicio_Final_LD, false);
        const status1_Inicio_Final_LE = getInclinationStatus(incl1_Inicio_Final_LE, false);

        html += `
          <div class="distance-card ${status1_LD_LE_Inicio.class}">
            <div><strong>${status1_LD_LE_Inicio.icon} Transversal: LD‚ÜîLE (In√≠cio com In√≠cio)</strong></div>
            <div class="inclination-value" style="color: ${status1_LD_LE_Inicio.color};">${incl1_LD_LE_Inicio.percentage.toFixed(2)}% (${incl1_LD_LE_Inicio.degrees.toFixed(1)}¬∞)</div>
            <small>${incl1_LD_LE_Inicio.direction} - ${status1_LD_LE_Inicio.text}</small>
            <div style="font-size: 11px; margin-top: 5px; color: #666;">
              üìè Dist√¢ncia: ${dist1Inicio.toFixed(3)}m | Desn√≠vel: ${Math.abs(elev1_LD_LE_Inicio).toFixed(3)}m<br>
              üìê C√°lculo: ${Math.abs(elev1_LD_LE_Inicio).toFixed(3)}m √∑ ${dist1Inicio.toFixed(3)}m √ó 100 = ${incl1_LD_LE_Inicio.percentage.toFixed(2)}%<br>
              Limite transversal: ‚â§${LIMIT_TRANSVERSAL}%
            </div>
          </div>
          <div class="distance-card ${status1_LD_LE_Final.class}">
            <div><strong>${status1_LD_LE_Final.icon} Transversal: LD‚ÜîLE (Final com Final)</strong></div>
            <div class="inclination-value" style="color: ${status1_LD_LE_Final.color};">${incl1_LD_LE_Final.percentage.toFixed(2)}% (${incl1_LD_LE_Final.degrees.toFixed(1)}¬∞)</div>
            <small>${incl1_LD_LE_Final.direction} - ${status1_LD_LE_Final.text}</small>
            <div style="font-size: 11px; margin-top: 5px; color: #666;">
              üìè Dist√¢ncia: ${dist1Final.toFixed(3)}m | Desn√≠vel: ${Math.abs(elev1_LD_LE_Final).toFixed(3)}m<br>
              üìê C√°lculo: ${Math.abs(elev1_LD_LE_Final).toFixed(3)}m √∑ ${dist1Final.toFixed(3)}m √ó 100 = ${incl1_LD_LE_Final.percentage.toFixed(2)}%<br>
              Limite transversal: ‚â§${LIMIT_TRANSVERSAL}%
            </div>
          </div>
          <div class="distance-card ${status1_Inicio_Final_LD.class}">
            <div><strong>${status1_Inicio_Final_LD.icon} Longitudinal: LD (Direito com Direito)</strong></div>
            <div class="inclination-value" style="color: ${status1_Inicio_Final_LD.color};">${incl1_Inicio_Final_LD.percentage.toFixed(2)}% (${incl1_Inicio_Final_LD.degrees.toFixed(1)}¬∞)</div>
            <small>${incl1_Inicio_Final_LD.direction} - ${status1_Inicio_Final_LD.text}</small>
            <div style="font-size: 11px; margin-top: 5px; color: #666;">
              üìè Dist√¢ncia: ${dist1LD.toFixed(3)}m | Desn√≠vel: ${Math.abs(elev1_Inicio_Final_LD).toFixed(3)}m<br>
              üìê C√°lculo: ${Math.abs(elev1_Inicio_Final_LD).toFixed(3)}m √∑ ${dist1LD.toFixed(3)}m √ó 100 = ${incl1_Inicio_Final_LD.percentage.toFixed(2)}%<br>
              Limite longitudinal: ‚â§${LIMIT_LONGITUDINAL}%
            </div>
          </div>
          <div class="distance-card ${status1_Inicio_Final_LE.class}">
            <div><strong>${status1_Inicio_Final_LE.icon} Longitudinal: LE (Esquerdo com Esquerdo)</strong></div>
            <div class="inclination-value" style="color: ${status1_Inicio_Final_LE.color};">${incl1_Inicio_Final_LE.percentage.toFixed(2)}% (${incl1_Inicio_Final_LE.degrees.toFixed(1)}¬∞)</div>
            <small>${incl1_Inicio_Final_LE.direction} - ${status1_Inicio_Final_LE.text}</small>
            <div style="font-size: 11px; margin-top: 5px; color: #666;">
              üìè Dist√¢ncia: ${dist1LE.toFixed(3)}m | Desn√≠vel: ${Math.abs(elev1_Inicio_Final_LE).toFixed(3)}m<br>
              üìê C√°lculo: ${Math.abs(elev1_Inicio_Final_LE).toFixed(3)}m √∑ ${dist1LE.toFixed(3)}m √ó 100 = ${incl1_Inicio_Final_LE.percentage.toFixed(2)}%<br>
              Limite longitudinal: ‚â§${LIMIT_LONGITUDINAL}%
            </div>
          </div>
        `;

        // ESTRUTURA 2 (se existir)
        if (struct2) {
          const dist2Inicio = calculateDistance(struct2.ldInicio, struct2.leInicio);
          const dist2Final = calculateDistance(struct2.ldFinal, struct2.leFinal);
          const dist2LD = calculateDistance(struct2.ldInicio, struct2.ldFinal);
          const dist2LE = calculateDistance(struct2.leInicio, struct2.leFinal);
          const media2Largura = (dist2Inicio + dist2Final) / 2;
          const media2Comprimento = (dist2LD + dist2LE) / 2;

          const elev2_LD_LE_Inicio = calculateElevationDifference(struct2.ldInicio, struct2.leInicio);
          const elev2_LD_LE_Final = calculateElevationDifference(struct2.ldFinal, struct2.leFinal);
          const elev2_Inicio_Final_LD = calculateElevationDifference(struct2.ldInicio, struct2.ldFinal);
          const elev2_Inicio_Final_LE = calculateElevationDifference(struct2.leInicio, struct2.leFinal);

          const incl2_LD_LE_Inicio = calculateInclination(struct2.ldInicio, struct2.leInicio);
          const incl2_LD_LE_Final = calculateInclination(struct2.ldFinal, struct2.leFinal);
          const incl2_Inicio_Final_LD = calculateInclination(struct2.ldInicio, struct2.ldFinal);
          const incl2_Inicio_Final_LE = calculateInclination(struct2.leInicio, struct2.leFinal);

          // AN√ÅLISE DE ESCONSIDADE ESTRUTURA 2
          const skew2 = calculateSkewAnalysis(struct2);

          html += `
            <div class="section-divider"></div>
            <div class="distance-card structure-section">
              <div><strong>üèóÔ∏è ESTRUTURA 2 (ROSA) - Dimens√µes</strong></div>
            </div>
            <div class="distance-card">
              <div><strong>Largura In√≠cio</strong></div>
              <div class="distance-value">${dist2Inicio.toFixed(3)} m</div>
              <small>LD_IN√çCIO ‚Üî LE_IN√çCIO</small>
            </div>
            <div class="distance-card">
              <div><strong>Largura Final</strong></div>
              <div class="distance-value">${dist2Final.toFixed(3)} m</div>
              <small>LD_FINAL ‚Üî LE_FINAL</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #e3f2fd, #f3e5f5); border: 2px solid #9c27b0;">
              <div><strong>üìè M√©dia Largura</strong></div>
              <div class="distance-value" style="color: #9c27b0;">${media2Largura.toFixed(3)} m</div>
              <small>Estrutura 2</small>
            </div>
            <div class="distance-card">
              <div><strong>Comprimento LD</strong></div>
              <div class="distance-value">${dist2LD.toFixed(3)} m</div>
              <small>LD_IN√çCIO ‚Üî LD_FINAL</small>
            </div>
            <div class="distance-card">
              <div><strong>Comprimento LE</strong></div>
              <div class="distance-value">${dist2LE.toFixed(3)} m</div>
              <small>LE_IN√çCIO ‚Üî LE_FINAL</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #e8f5e8, #fff3e0); border: 2px solid #ff9800;">
              <div><strong>üìê M√©dia Comprimento</strong></div>
              <div class="distance-value" style="color: #ff9800;">${media2Comprimento.toFixed(3)} m</div>
              <small>Estrutura 2</small>
            </div>
            
            <div class="distance-card structure-section">
              <div><strong>üìê ESTRUTURA 2 (ROSA) - An√°lise de Esconsidade</strong></div>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #fff3e0, #e8f5e8); border: 2px solid #ff9800;">
              <div><strong>üìè √Çngulo de Esconsidade</strong></div>
              <div class="distance-value" style="color: #ff9800;">${skew2.anguloEsconsidade.toFixed(2)}¬∞</div>
              <small>${skew2.statusEsconsidade} - ${skew2.tipoGeometria}</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #e3f2fd, #f3e5f5); border: 2px solid #2196f3;">
              <div><strong>üìê Largura √ötil (Efetiva)</strong></div>
              <div class="distance-value" style="color: #2196f3;">${skew2.larguraEfetiva.toFixed(3)} m</div>
              <small>Largura real para passagem de ve√≠culos</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #ffebee, #fff3e0); border: 2px solid #f44336;">
              <div><strong>üìâ Perda de Largura</strong></div>
              <div class="distance-value" style="color: #f44336;">${skew2.perdaLargura.toFixed(3)} m (${skew2.percentualPerda.toFixed(1)}%)</div>
              <small>Redu√ß√£o devido √† esconsidade</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #f8f9fa, #e9ecef); border: 2px solid #6c757d;">
              <div><strong>üìè Dist√¢ncia em X (LD‚ÜîLE In√≠cio)</strong></div>
              <div class="distance-value" style="color: #6c757d;">${skew2.deltaX_Inicio.toFixed(3)} m</div>
              <small>Componente horizontal</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #f8f9fa, #e9ecef); border: 2px solid #6c757d;">
              <div><strong>üìê Dist√¢ncia em Y (LD‚ÜîLE In√≠cio)</strong></div>
              <div class="distance-value" style="color: #6c757d;">${skew2.deltaY_Inicio.toFixed(3)} m</div>
              <small>Componente vertical</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #e8f5e8, #fff3e0); border: 2px solid #4caf50;">
              <div><strong>‚öñÔ∏è Diferen√ßa de Comprimentos</strong></div>
              <div class="distance-value" style="color: #4caf50;">${skew2.diferencaComprimentos.toFixed(3)} m</div>
              <small>|Comprimento LD - Comprimento LE|</small>
            </div>
            
            <div class="distance-card elevation-section">
              <div><strong>üìè ESTRUTURA 2 - An√°lise de Eleva√ß√£o</strong></div>
            </div>
            <div class="distance-card elevation-analysis-card">
              <div><strong>Diferen√ßa LD‚ÜîLE (In√≠cio)</strong></div>
              <div class="elevation-value" style="color: ${elev2_LD_LE_Inicio >= 0 ? '#4caf50' : '#f44336'};">${elev2_LD_LE_Inicio >= 0 ? '+' : ''}${elev2_LD_LE_Inicio.toFixed(3)} m</div>
              <small>Inclina√ß√£o transversal in√≠cio</small>
            </div>
            <div class="distance-card elevation-analysis-card">
              <div><strong>Diferen√ßa LD‚ÜîLE (Final)</strong></div>
              <div class="elevation-value" style="color: ${elev2_LD_LE_Final >= 0 ? '#4caf50' : '#f44336'};">${elev2_LD_LE_Final >= 0 ? '+' : ''}${elev2_LD_LE_Final.toFixed(3)} m</div>
              <small>Inclina√ß√£o transversal final</small>
            </div>
            <div class="distance-card elevation-analysis-card">
              <div><strong>Diferen√ßa In√≠cio‚ÜîFinal (LD)</strong></div>
              <div class="elevation-value" style="color: ${elev2_Inicio_Final_LD >= 0 ? '#4caf50' : '#f44336'};">${elev2_Inicio_Final_LD >= 0 ? '+' : ''}${elev2_Inicio_Final_LD.toFixed(3)} m</div>
              <small>Inclina√ß√£o longitudinal LD</small>
            </div>
            <div class="distance-card elevation-analysis-card">
              <div><strong>Diferen√ßa In√≠cio‚ÜîFinal (LE)</strong></div>
              <div class="elevation-value" style="color: ${elev2_Inicio_Final_LE >= 0 ? '#4caf50' : '#f44336'};">${elev2_Inicio_Final_LE >= 0 ? '+' : ''}${elev2_Inicio_Final_LE.toFixed(3)} m</div>
              <small>Inclina√ß√£o longitudinal LE</small>
            </div>
            
            <div class="distance-card elevation-section">
              <div><strong>üìê ESTRUTURA 2 - Verifica√ß√£o de Conformidade</strong></div>
            </div>
          `;

          // Verifica√ß√£o de conformidade para estrutura 2
          const status2_LD_LE_Inicio = getInclinationStatus(incl2_LD_LE_Inicio, true);
          const status2_LD_LE_Final = getInclinationStatus(incl2_LD_LE_Final, true);
          const status2_Inicio_Final_LD = getInclinationStatus(incl2_Inicio_Final_LD, false);
          const status2_Inicio_Final_LE = getInclinationStatus(incl2_Inicio_Final_LE, false);

          html += `
            <div class="distance-card ${status2_LD_LE_Inicio.class}">
              <div><strong>${status2_LD_LE_Inicio.icon} Transversal: LD‚ÜîLE (In√≠cio com In√≠cio)</strong></div>
              <div class="inclination-value" style="color: ${status2_LD_LE_Inicio.color};">${incl2_LD_LE_Inicio.percentage.toFixed(2)}% (${incl2_LD_LE_Inicio.degrees.toFixed(1)}¬∞)</div>
              <small>${incl2_LD_LE_Inicio.direction} - ${status2_LD_LE_Inicio.text}</small>
              <div style="font-size: 11px; margin-top: 5px; color: #666;">Limite transversal: ‚â§${LIMIT_TRANSVERSAL}%</div>
            </div>
            <div class="distance-card ${status2_LD_LE_Final.class}">
              <div><strong>${status2_LD_LE_Final.icon} Transversal: LD‚ÜîLE (Final com Final)</strong></div>
              <div class="inclination-value" style="color: ${status2_LD_LE_Final.color};">${incl2_LD_LE_Final.percentage.toFixed(2)}% (${incl2_LD_LE_Final.degrees.toFixed(1)}¬∞)</div>
              <small>${incl2_LD_LE_Final.direction} - ${status2_LD_LE_Final.text}</small>
              <div style="font-size: 11px; margin-top: 5px; color: #666;">Limite transversal: ‚â§${LIMIT_TRANSVERSAL}%</div>
            </div>
            <div class="distance-card ${status2_Inicio_Final_LD.class}">
              <div><strong>${status2_Inicio_Final_LD.icon} Longitudinal: LD (Direito com Direito)</strong></div>
              <div class="inclination-value" style="color: ${status2_Inicio_Final_LD.color};">${incl2_Inicio_Final_LD.percentage.toFixed(2)}% (${incl2_Inicio_Final_LD.degrees.toFixed(1)}¬∞)</div>
              <small>${incl2_Inicio_Final_LD.direction} - ${status2_Inicio_Final_LD.text}</small>
              <div style="font-size: 11px; margin-top: 5px; color: #666;">Limite longitudinal: ‚â§${LIMIT_LONGITUDINAL}%</div>
            </div>
            <div class="distance-card ${status2_Inicio_Final_LE.class}">
              <div><strong>${status2_Inicio_Final_LE.icon} Longitudinal: LE (Esquerdo com Esquerdo)</strong></div>
              <div class="inclination-value" style="color: ${status2_Inicio_Final_LE.color};">${incl2_Inicio_Final_LE.percentage.toFixed(2)}% (${incl2_Inicio_Final_LE.degrees.toFixed(1)}¬∞)</div>
              <small>${incl2_Inicio_Final_LE.direction} - ${status2_Inicio_Final_LE.text}</small>
              <div style="font-size: 11px; margin-top: 5px; color: #666;">Limite longitudinal: ‚â§${LIMIT_LONGITUDINAL}%</div>
            </div>
          `;

          // Verificar problemas de inclina√ß√£o com novos limites
          const problemasTransversais = [];
          const problemasLongitudinais = [];
          
          if (incl1_LD_LE_Inicio.percentage > LIMIT_TRANSVERSAL) problemasTransversais.push("Est.1 Transversal In√≠cio (LD‚ÜîLE)");
          if (incl1_LD_LE_Final.percentage > LIMIT_TRANSVERSAL) problemasTransversais.push("Est.1 Transversal Final (LD‚ÜîLE)");
          if (incl2_LD_LE_Inicio.percentage > LIMIT_TRANSVERSAL) problemasTransversais.push("Est.2 Transversal In√≠cio (LD‚ÜîLE)");
          if (incl2_LD_LE_Final.percentage > LIMIT_TRANSVERSAL) problemasTransversais.push("Est.2 Transversal Final (LD‚ÜîLE)");
          
          if (incl1_Inicio_Final_LD.percentage > LIMIT_LONGITUDINAL) problemasLongitudinais.push("Est.1 Longitudinal LD (Direito)");
          if (incl1_Inicio_Final_LE.percentage > LIMIT_LONGITUDINAL) problemasLongitudinais.push("Est.1 Longitudinal LE (Esquerdo)");
          if (incl2_Inicio_Final_LD.percentage > LIMIT_LONGITUDINAL) problemasLongitudinais.push("Est.2 Longitudinal LD (Direito)");
          if (incl2_Inicio_Final_LE.percentage > LIMIT_LONGITUDINAL) problemasLongitudinais.push("Est.2 Longitudinal LE (Esquerdo)");
          const crossInclination = calculateInclination(struct1.leInicio, struct2.ldInicio);
          if (crossInclination.percentage > LIMIT_LONGITUDINAL) problemasLongitudinais.push("Entre estruturas (Longitudinal)");
          
          const totalProblemas = problemasTransversais.length + problemasLongitudinais.length;
          
          const summaryHtml = `
            <h4 style="margin-bottom: 15px; color: #495057;">üìã Resumo Executivo - An√°lise T√©cnica</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; text-align: center;">
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: #007bff;">üåâ Dist√¢ncia Total</div>
                <div style="font-size: 16px; font-weight: bold; color: #007bff; margin: 5px 0;">${crossDistance.toFixed(3)}m</div>
                <div style="font-size: 12px; color: #6c757d;">LE(1) ‚Üî LD(2)</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: ${crossElevation >= 0 ? '#4caf50' : '#f44336'};">üìè Diferen√ßa Eleva√ß√£o</div>
                <div style="font-size: 16px; font-weight: bold; color: ${crossElevation >= 0 ? '#4caf50' : '#f44336'}; margin: 5px 0;">${crossElevation >= 0 ? '+' : ''}${crossElevation.toFixed(3)}m</div>
                <div style="font-size: 12px; color: #6c757d;">Entre estruturas</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: ${crossInclination.percentage > LIMIT_LONGITUDINAL ? '#f44336' : crossInclination.percentage > LIMIT_LONGITUDINAL * 0.8 ? '#ff9800' : '#4caf50'};">üìê Inclina√ß√£o Entre Estru.</div>
                <div style="font-size: 16px; font-weight: bold; color: ${crossInclination.percentage > LIMIT_LONGITUDINAL ? '#f44336' : crossInclination.percentage > LIMIT_LONGITUDINAL * 0.8 ? '#ff9800' : '#4caf50'}; margin: 5px 0;">${crossInclination.percentage.toFixed(2)}%</div>
                <div style="font-size: 12px; color: #6c757d;">Limite: ‚â§${LIMIT_LONGITUDINAL}%</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: #9c27b0;">üìè Largura M√©dia</div>
                <div style="font-size: 16px; font-weight: bold; color: #9c27b0; margin: 5px 0;">${mediaGeralLargura.toFixed(3)}m</div>
                <div style="font-size: 12px; color: #6c757d;">Geral (Est.1+2)</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: #ff9800;">üìê Comprimento M√©dio</div>
                <div style="font-size: 16px; font-weight: bold; color: #ff9800; margin: 5px 0;">${mediaGeralComprimento.toFixed(3)}m</div>
                <div style="font-size: 12px; color: #6c757d;">Geral (Est.1+2)</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: #ff9800;">üìê Esconsidade Geral</div>
                <div style="font-size: 16px; font-weight: bold; color: #ff9800; margin: 5px 0;">${((skew1.anguloEsconsidade + skew2.anguloEsconsidade) / 2).toFixed(1)}¬∞</div>
                <div style="font-size: 12px; color: #6c757d;">M√©dia das estruturas</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: #2196f3;">üìê Largura √ötil M√©dia</div>
                <div style="font-size: 16px; font-weight: bold; color: #2196f3; margin: 5px 0;">${((skew1.larguraEfetiva + skew2.larguraEfetiva) / 2).toFixed(3)}m</div>
                <div style="font-size: 12px; color: #6c757d;">Efetiva para ve√≠culos</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid ${totalProblemas > 0 ? '#f44336' : '#4caf50'};">
                <div style="font-weight: bold; color: ${totalProblemas > 0 ? '#f44336' : '#4caf50'};">${totalProblemas > 0 ? 'üö®' : '‚úÖ'} Status Conformidade</div>
                <div style="font-size: 16px; font-weight: bold; color: ${totalProblemas > 0 ? '#f44336' : '#4caf50'}; margin: 5px 0;">${totalProblemas > 0 ? `${totalProblemas} N√£o Conformidades` : 'CONFORME'}</div>
                <div style="font-size: 12px; color: #6c757d;">${totalProblemas > 0 ? 'Revisar inclina√ß√µes' : 'Todas inclina√ß√µes OK'}</div>
              </div>
            </div>
            <div style="margin-top: 15px; padding: 12px; background: #e3f2fd; border: 2px solid #2196f3; border-radius: 6px;">
              <div style="font-weight: bold; color: #1976d2; margin-bottom: 8px;">üìê An√°lise de Esconsidade:</div>
              <div style="font-size: 14px; color: #1565c0;">
                üî∫ Estrutura 1: ${skew1.anguloEsconsidade.toFixed(2)}¬∞ (${skew1.statusEsconsidade}) | Largura √ötil: ${skew1.larguraEfetiva.toFixed(3)}m (Perda: ${skew1.perdaLargura.toFixed(3)}m)
                <br>üî∫ Estrutura 2: ${skew2.anguloEsconsidade.toFixed(2)}¬∞ (${skew2.statusEsconsidade}) | Largura √ötil: ${skew2.larguraEfetiva.toFixed(3)}m (Perda: ${skew2.perdaLargura.toFixed(3)}m)
              </div>
              <div style="font-size: 12px; color: #1976d2; margin-top: 5px;">
                Esconsidade m√©dia: ${((skew1.anguloEsconsidade + skew2.anguloEsconsidade) / 2).toFixed(1)}¬∞ | Largura √∫til m√©dia: ${((skew1.larguraEfetiva + skew2.larguraEfetiva) / 2).toFixed(3)}m
              </div>
            </div>
            ${totalProblemas > 0 ? `
            <div style="margin-top: 15px; padding: 12px; background: #ffebee; border: 2px solid #f44336; border-radius: 6px;">
              <div style="font-weight: bold; color: #d32f2f; margin-bottom: 8px;">üö® INCLINA√á√ïES ACIMA DOS LIMITES T√âCNICOS:</div>
              ${problemasTransversais.length > 0 ? `<div style="font-size: 14px; color: #c62828; margin-bottom: 5px;"><strong>Transversais (>${LIMIT_TRANSVERSAL}%):</strong> ${problemasTransversais.join(', ')}</div>` : ''}
              ${problemasLongitudinais.length > 0 ? `<div style="font-size: 14px; color: #c62828;"><strong>Longitudinais (>${LIMIT_LONGITUDINAL}%):</strong> ${problemasLongitudinais.join(', ')}</div>` : ''}
              <div style="font-size: 12px; color: #d32f2f; margin-top: 8px; font-weight: bold;">‚ö†Ô∏è RECOMENDA-SE AN√ÅLISE ESTRUTURAL ESPEC√çFICA</div>
            </div>
            ` : `
            <div style="margin-top: 15px; padding: 12px; background: #e8f5e8; border: 2px solid #4caf50; border-radius: 6px;">
              <div style="font-weight: bold; color: #2e7d32; margin-bottom: 8px;">‚úÖ ESTRUTURAS DENTRO DOS LIMITES T√âCNICOS</div>
              <div style="font-size: 14px; color: #388e3c;">Todas as inclina√ß√µes est√£o dentro dos limites recomendados</div>
              <div style="font-size: 12px; color: #2e7d32; margin-top: 5px;">Transversais: ‚â§${LIMIT_TRANSVERSAL}% | Longitudinais: ‚â§${LIMIT_LONGITUDINAL}%</div>
            </div>
            `}
          `;
          document.getElementById('executiveSummary').innerHTML = summaryHtml;
        } else {
          // Para estrutura √∫nica
          const allPointsForAnalysis = [struct1.ldInicio, struct1.leInicio, struct1.ldFinal, struct1.leFinal];
          const maxElevForAnalysis = Math.max(...allPointsForAnalysis.map(p => p.elevation));
          const minElevForAnalysis = Math.min(...allPointsForAnalysis.map(p => p.elevation));
          
          // An√°lise de esconsidade para estrutura √∫nica
          const skew1 = calculateSkewAnalysis(struct1);
          
          // Adicionar se√ß√£o de esconsidade para estrutura √∫nica
          html += `
            <div class="section-divider"></div>
            <div class="distance-card structure-section">
              <div><strong>üìê ESTRUTURA √öNICA - An√°lise de Esconsidade</strong></div>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #fff3e0, #e8f5e8); border: 2px solid #ff9800;">
              <div><strong>üìè √Çngulo de Esconsidade</strong></div>
              <div class="distance-value" style="color: #ff9800;">${skew1.anguloEsconsidade.toFixed(2)}¬∞</div>
              <small>${skew1.statusEsconsidade} - ${skew1.tipoGeometria}</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #e3f2fd, #f3e5f5); border: 2px solid #2196f3;">
              <div><strong>üìê Largura √ötil (Efetiva)</strong></div>
              <div class="distance-value" style="color: #2196f3;">${skew1.larguraEfetiva.toFixed(3)} m</div>
              <small>Largura real para passagem de ve√≠culos</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #ffebee, #fff3e0); border: 2px solid #f44336;">
              <div><strong>üìâ Perda de Largura</strong></div>
              <div class="distance-value" style="color: #f44336;">${skew1.perdaLargura.toFixed(3)} m (${skew1.percentualPerda.toFixed(1)}%)</div>
              <small>Redu√ß√£o devido √† esconsidade</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #f8f9fa, #e9ecef); border: 2px solid #6c757d;">
              <div><strong>üìè Dist√¢ncia em X (LD‚ÜîLE In√≠cio)</strong></div>
              <div class="distance-value" style="color: #6c757d;">${skew1.deltaX_Inicio.toFixed(3)} m</div>
              <small>Componente horizontal</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #f8f9fa, #e9ecef); border: 2px solid #6c757d;">
              <div><strong>üìê Dist√¢ncia em Y (LD‚ÜîLE In√≠cio)</strong></div>
              <div class="distance-value" style="color: #6c757d;">${skew1.deltaY_Inicio.toFixed(3)} m</div>
              <small>Componente vertical</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #e8f5e8, #fff3e0); border: 2px solid #4caf50;">
              <div><strong>‚öñÔ∏è Diferen√ßa de Comprimentos</strong></div>
              <div class="distance-value" style="color: #4caf50;">${skew1.diferencaComprimentos.toFixed(3)} m</div>
              <small>|Comprimento LD - Comprimento LE|</small>
            </div>
          `;
          
          // Verificar problemas de inclina√ß√£o para estrutura √∫nica
          const problemasTransversais = [];
          const problemasLongitudinais = [];
          
          if (incl1_LD_LE_Inicio.percentage > LIMIT_TRANSVERSAL) problemasTransversais.push("Transversal In√≠cio (LD‚ÜîLE)");
          if (incl1_LD_LE_Final.percentage > LIMIT_TRANSVERSAL) problemasTransversais.push("Transversal Final (LD‚ÜîLE)");
          
          if (incl1_Inicio_Final_LD.percentage > LIMIT_LONGITUDINAL) problemasLongitudinais.push("Longitudinal LD (Direito)");
          if (incl1_Inicio_Final_LE.percentage > LIMIT_LONGITUDINAL) problemasLongitudinais.push("Longitudinal LE (Esquerdo)");
          
          const totalProblemasUnica = problemasTransversais.length + problemasLongitudinais.length;
          
          const summaryHtml = `
            <h4 style="margin-bottom: 15px; color: #495057;">üìã Resumo Executivo - An√°lise T√©cnica (Estrutura √önica)</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 15px; text-align: center;">
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: #9c27b0;">üìè Largura M√©dia</div>
                <div style="font-size: 18px; font-weight: bold; color: #9c27b0; margin: 5px 0;">${media1Largura.toFixed(3)} m</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: #ff9800;">üìê Comprimento M√©dio</div>
                <div style="font-size: 18px; font-weight: bold; color: #ff9800; margin: 5px 0;">${media1Comprimento.toFixed(3)} m</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: #ff9800;">üìê √Çngulo Esconsidade</div>
                <div style="font-size: 18px; font-weight: bold; color: #ff9800; margin: 5px 0;">${skew1.anguloEsconsidade.toFixed(1)}¬∞</div>
                <small>${skew1.statusEsconsidade}</small>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: #2196f3;">üìê Largura √ötil</div>
                <div style="font-size: 18px; font-weight: bold; color: #2196f3; margin: 5px 0;">${skew1.larguraEfetiva.toFixed(3)} m</div>
                <small>Efetiva para ve√≠culos</small>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: ${incl1_Inicio_Final_LD.percentage > LIMIT_LONGITUDINAL || incl1_Inicio_Final_LE.percentage > LIMIT_LONGITUDINAL ? '#f44336' : '#4caf50'};">‚ÜïÔ∏è Status Longitudinal</div>
                <div style="font-size: 14px; font-weight: bold; color: ${incl1_Inicio_Final_LD.percentage > LIMIT_LONGITUDINAL || incl1_Inicio_Final_LE.percentage > LIMIT_LONGITUDINAL ? '#f44336' : '#4caf50'}; margin: 5px 0;">${incl1_Inicio_Final_LD.percentage > LIMIT_LONGITUDINAL || incl1_Inicio_Final_LE.percentage > LIMIT_LONGITUDINAL ? 'ACIMA DO LIMITE' : 'DENTRO DO LIMITE'}</div>
                <div style="font-size: 12px; color: #6c757d;">Limite: ‚â§${LIMIT_LONGITUDINAL}%</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: ${incl1_LD_LE_Inicio.percentage > LIMIT_TRANSVERSAL || incl1_LD_LE_Final.percentage > LIMIT_TRANSVERSAL ? '#f44336' : '#4caf50'};">üîÑ Status Transversal</div>
                <div style="font-size: 14px; font-weight: bold; color: ${incl1_LD_LE_Inicio.percentage > LIMIT_TRANSVERSAL || incl1_LD_LE_Final.percentage > LIMIT_TRANSVERSAL ? '#f44336' : '#4caf50'}; margin: 5px 0;">${incl1_LD_LE_Inicio.percentage > LIMIT_TRANSVERSAL || incl1_LD_LE_Final.percentage > LIMIT_TRANSVERSAL ? 'ACIMA DO LIMITE' : 'DENTRO DO LIMITE'}</div>
                <div style="font-size: 12px; color: #6c757d;">Limite: ‚â§${LIMIT_TRANSVERSAL}%</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid ${totalProblemasUnica > 0 ? '#f44336' : '#4caf50'};">
                <div style="font-weight: bold; color: ${totalProblemasUnica > 0 ? '#f44336' : '#4caf50'};">${totalProblemasUnica > 0 ? 'üö®' : '‚úÖ'} Status Geral</div>
                <div style="font-size: 16px; font-weight: bold; color: ${totalProblemasUnica > 0 ? '#f44336' : '#4caf50'}; margin: 5px 0;">${totalProblemasUnica > 0 ? `${totalProblemasUnica} Acima dos Limites` : 'DENTRO DOS LIMITES'}</div>
                <div style="font-size: 12px; color: #6c757d;">${totalProblemasUnica > 0 ? 'Revisar inclina√ß√µes' : 'Todas inclina√ß√µes OK'}</div>
              </div>
            </div>
            <div style="margin-top: 15px; padding: 12px; background: #e3f2fd; border: 2px solid #2196f3; border-radius: 6px;">
              <div style="font-weight: bold; color: #1976d2; margin-bottom: 8px;">üìê An√°lise de Esconsidade:</div>
              <div style="font-size: 14px; color: #1565c0;">
                üî∫ Estrutura 1: ${skew1.anguloEsconsidade.toFixed(2)}¬∞ (${skew1.statusEsconsidade}) | Largura √ötil: ${skew1.larguraEfetiva.toFixed(3)}m (Perda: ${skew1.perdaLargura.toFixed(3)}m)
              </div>
              <div style="font-size: 12px; color: #1976d2; margin-top: 5px;">
                Geometria: ${skew1.tipoGeometria} | Diferen√ßa de comprimentos: ${skew1.diferencaComprimentos.toFixed(3)}m
              </div>
            </div>
            <div style="margin-top: 15px; padding: 12px; background: #e8f5e8; border: 2px solid #4caf50; border-radius: 6px;">
              <div style="font-weight: bold; color: #2e7d32; margin-bottom: 8px;">üìè An√°lise de Eleva√ß√µes Relativas:</div>
              <div style="font-size: 14px; color: #388e3c;">
                üî∫ Ponto mais alto: ${maxElevForAnalysis.toFixed(3)}m (refer√™ncia 0,00m) | 
                üîª Ponto mais baixo: ${minElevForAnalysis.toFixed(3)}m (${(minElevForAnalysis - maxElevForAnalysis).toFixed(3)}m relativo)
              </div>
              <div style="font-size: 12px; color: #2e7d32; margin-top: 5px;">Amplitude total: ${(maxElevForAnalysis - minElevForAnalysis).toFixed(3)}m</div>
            </div>
            ${totalProblemasUnica > 0 ? `
            <div style="margin-top: 15px; padding: 12px; background: #ffebee; border: 2px solid #f44336; border-radius: 6px;">
              <div style="font-weight: bold; color: #d32f2f; margin-bottom: 8px;">üö® INCLINA√á√ïES ACIMA DOS LIMITES T√âCNICOS:</div>
              ${problemasTransversais.length > 0 ? `<div style="font-size: 14px; color: #c62828; margin-bottom: 5px;"><strong>Transversais (>${LIMIT_TRANSVERSAL}%):</strong> ${problemasTransversais.join(', ')}</div>` : ''}
              ${problemasLongitudinais.length > 0 ? `<div style="font-size: 14px; color: #c62828;"><strong>Longitudinais (>${LIMIT_LONGITUDINAL}%):</strong> ${problemasLongitudinais.join(', ')}</div>` : ''}
              <div style="font-size: 12px; color: #d32f2f; margin-top: 8px; font-weight: bold;">‚ö†Ô∏è RECOMENDA-SE AN√ÅLISE ESTRUTURAL ESPEC√çFICA</div>
            </div>
            ` : `
            <div style="margin-top: 15px; padding: 12px; background: #e8f5e8; border: 2px solid #4caf50; border-radius: 6px;">
              <div style="font-weight: bold; color: #2e7d32; margin-bottom: 8px;">‚úÖ ESTRUTURA DENTRO DOS LIMITES T√âCNICOS</div>
              <div style="font-size: 14px; color: #388e3c;">Todas as inclina√ß√µes est√£o dentro dos limites recomendados</div>
              <div style="font-size: 12px; color: #2e7d32; margin-top: 5px;">Transversais: ‚â§${LIMIT_TRANSVERSAL}% | Longitudinais: ‚â§${LIMIT_LONGITUDINAL}%</div>
            </div>
            `}
          `;
          document.getElementById('executiveSummary').innerHTML = summaryHtml;
        }

        distanceInfo.innerHTML = html;
        
        debugLog("Relat√≥rio de an√°lise t√©cnica gerado com sucesso");
        
        // Adicionar se√ß√£o explicativa da metodologia
        const metodologiaHtml = `
          <div style="margin-top: 25px; padding: 15px; background: linear-gradient(135deg, #f8f9fa, #e9ecef); border-radius: 8px; border: 2px solid #6c757d;">
            <h4 style="margin: 0 0 15px 0; color: #495057; text-align: center;">üìê Metodologia de An√°lise Aplicada</h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;">
              <div style="background: white; padding: 12px; border-radius: 6px; border: 2px solid #d32f2f;">
                <div style="font-weight: bold; color: #d32f2f; margin-bottom: 8px;">üîÑ INCLINA√á√ïES TRANSVERSAIS (‚â§5%)</div>
                <div style="font-size: 13px; color: #666; line-height: 1.4;">
                  <strong>‚úì LD_IN√çCIO ‚Üî LE_IN√çCIO</strong><br>
                  <em>Lado direito com lado esquerdo no mesmo ponto</em><br><br>
                  <strong>‚úì LD_FINAL ‚Üî LE_FINAL</strong><br>
                  <em>Lado direito com lado esquerdo no mesmo ponto</em>
                </div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 2px solid #ff9800;">
                <div style="font-weight: bold; color: #ff9800; margin-bottom: 8px;">‚ÜïÔ∏è INCLINA√á√ïES LONGITUDINAIS (‚â§2,5%)</div>
                <div style="font-size: 13px; color: #666; line-height: 1.4;">
                  <strong>‚úì LD_IN√çCIO ‚Üî LD_FINAL</strong><br>
                  <em>Mesmo lado direito entre pontos</em><br><br>
                  <strong>‚úì LE_IN√çCIO ‚Üî LE_FINAL</strong><br>
                  <em>Mesmo lado esquerdo entre pontos</em>
                </div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 2px solid #2196f3;">
                <div style="font-weight: bold; color: #2196f3; margin-bottom: 8px;">üìê AN√ÅLISE DE ESCONSIDADE</div>
                <div style="font-size: 13px; color: #666; line-height: 1.4;">
                  <strong>‚úì √Çngulo de Esconsidade</strong><br>
                  <em>Desvio da perpendicularidade</em><br><br>
                  <strong>‚úì Largura √ötil = Largura √ó cos(Œ∏)</strong><br>
                  <em>Largura efetiva para ve√≠culos</em>
                </div>
              </div>
            </div>
            <div style="text-align: center; margin-top: 12px; font-size: 12px; color: #6c757d;">
              <strong>Boas Pr√°ticas da Engenharia de Pontes</strong> - Sistema automatizado de an√°lise t√©cnica de tabuleiros com detec√ß√£o de esconsidade
            </div>
          </div>
        `;
        
        document.getElementById('executiveSummary').insertAdjacentHTML('afterend', metodologiaHtml);
        
        infoPanel.style.display = "block";
      }

      function processData() {
        debugLog("=== PROCESSANDO DADOS ===");
        const csvData1 = document.getElementById("csvData1").value;
        const csvData2 = document.getElementById("csvData2").value;
        const errorMsg = document.getElementById("errorMsg");
        
        // Limpar debug anterior
        document.getElementById('debugInfo').innerHTML = '';
        document.getElementById('debugInfo').style.display = 'none';
        
        errorMsg.innerHTML = "";

        if (!csvData1.trim()) {
          errorMsg.innerHTML = '<div class="error">‚ö†Ô∏è Por favor, cole pelo menos os dados do CSV 1!</div>';
          return;
        }

        try {
          debugLog("Processando CSV 1...");
          const data1 = parseCSV(csvData1);
          debugLog("Processando CSV 2...");
          const data2 = parseCSV(csvData2);

          debugLog("Procurando pontos no CSV 1...");
          const points1 = findPoints(data1);
          debugLog("Procurando pontos no CSV 2...");
          const points2 = findPoints(data2);
          
          currentPoints1 = points1;
          currentPoints2 = points2;

          if (Object.keys(points1).length === 0) {
            errorMsg.innerHTML = '<div class="error">‚ö†Ô∏è Nenhum ponto LD ou LE encontrado no CSV 1! Certifique-se de que existem pontos com *_OAE ou *PONTE no nome ou c√≥digo.</div>';
            return;
          }

          debugLog("Iniciando visualiza√ß√£o...");
          drawVisualization(points1, points2);
        } catch (error) {
          console.error("Erro:", error);
          debugLog(`ERRO: ${error.message}`);
          errorMsg.innerHTML = `<div class="error">‚ùå Erro ao processar dados: ${error.message}</div>`;
        }
      }

      // Pr√©-carregar dados de exemplo
      window.onload = function () {
        console.log("üöÄ P√°gina carregada - Analisador de Inclina√ß√µes e Esconsidade ativo");
        updateZoomDisplay();
        loadExample1UTM();
      };
    </script>
  </body>
</html>