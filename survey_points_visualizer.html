<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Visualizador Duplo de Pontos Topogr√°ficos</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f5f5f5;
      }
      
      .container {
        background: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      }
      
      h1 {
        color: #333;
        text-align: center;
        margin-bottom: 30px;
      }
      
      .input-section {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 30px;
      }
      
      .csv-input {
        display: flex;
        flex-direction: column;
      }
      
      .csv-input label {
        font-weight: bold;
        margin-bottom: 10px;
        color: #333;
      }
      
      textarea {
        width: 100%;
        height: 200px;
        padding: 10px;
        border: 2px solid #ddd;
        border-radius: 5px;
        font-family: monospace;
        font-size: 12px;
        resize: vertical;
      }
      
      button {
        background: #007bff;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        margin: 10px 5px;
      }
      
      button:hover {
        background: #0056b3;
      }
      
      .controls {
        text-align: center;
        margin: 20px 0;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        gap: 10px;
      }
      
      .zoom-controls {
        display: flex;
        align-items: center;
        background: #f8f9fa;
        padding: 8px 15px;
        border-radius: 25px;
        border: 1px solid #dee2e6;
        margin-left: 20px;
      }
      
      @media (max-width: 768px) {
        .controls {
          flex-direction: column;
          gap: 15px;
        }
        
        .zoom-controls {
          margin-left: 0;
          width: 100%;
          justify-content: center;
        }
      }
      
      .zoom-controls button {
        margin: 0 5px;
        padding: 6px 10px;
        font-size: 14px;
        min-width: 40px;
      }
      
      #zoomLevel {
        margin: 0 15px;
        font-weight: bold;
        color: #495057;
        font-size: 14px;
        min-width: 80px;
        text-align: center;
      }
      
      .visualization {
        border: 2px solid #ddd;
        border-radius: 10px;
        background: white;
        min-height: 500px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 20px;
      }
      
      #canvas {
        border: 1px solid #ccc;
        background: #fafafa;
      }
      
      .info-panel {
        margin-top: 20px;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 5px;
        border-left: 4px solid #007bff;
      }
      
      .distance-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 12px;
        margin-top: 15px;
      }
      
      .distance-card {
        background: white;
        padding: 12px;
        border-radius: 5px;
        border: 1px solid #ddd;
        text-align: center;
        transition: transform 0.2s;
      }
      
      .distance-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      }
      
      .section-divider {
        grid-column: 1 / -1;
        height: 1px;
        background: linear-gradient(to right, transparent, #ddd, transparent);
        margin: 15px 0;
      }
      
      .distance-value {
        font-size: 18px;
        font-weight: bold;
        color: #007bff;
      }
      
      .cross-distance-card {
        background: linear-gradient(135deg, #fff3e0, #e8f5e8);
        border: 2px solid #ff9800;
      }
      
      .cross-distance-value {
        color: #ff9800;
      }
      
      .error {
        color: #dc3545;
        background: #f8d7da;
        padding: 10px;
        border-radius: 5px;
        margin-top: 10px;
      }
      
      .csv-section {
        border: 1px solid #ddd;
        border-radius: 5px;
        padding: 15px;
        background: #fafafa;
      }
      
      .section-title {
        color: #007bff;
        font-size: 18px;
        margin-bottom: 10px;
        font-weight: bold;
      }
      
      .example-buttons {
        margin-top: 10px;
      }
      
      .example-btn {
        background: #28a745;
        font-size: 14px;
        padding: 8px 16px;
      }
      
      .example-btn:hover {
        background: #218838;
      }
      
      .cross-section {
        background: linear-gradient(135deg, #fff3e0, #e8f5e8);
        border: 2px solid #ff9800;
        margin: 20px 0 10px 0;
        grid-column: 1 / -1;
        text-align: center;
      }
      
      .structure-section {
        background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
        border: 2px solid #9c27b0;
        margin: 15px 0 5px 0;
        grid-column: 1 / -1;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üìê Visualizador Duplo de Pontos Topogr√°ficos</h1>

      <div class="input-section">
        <!-- CSV 1 -->
        <div class="csv-section">
          <div class="section-title">üìç CSV 1 - Primeira Estrutura</div>
          <textarea
            id="csvData1"
            placeholder="Cole aqui os dados do primeiro CSV..."
          ></textarea>
          <div class="example-buttons">
            <button onclick="loadExample1()" class="example-btn">
              üìù Exemplo CSV 1
            </button>
          </div>
        </div>

        <!-- CSV 2 -->
        <div class="csv-section">
          <div class="section-title">üìç CSV 2 - Segunda Estrutura</div>
          <textarea
            id="csvData2"
            placeholder="Cole aqui os dados do segundo CSV (opcional)..."
          ></textarea>
          <div class="example-buttons">
            <button onclick="loadExample2()" class="example-btn">
              üìù Exemplo CSV 2
            </button>
          </div>
        </div>
      </div>

      <div class="controls">
        <button onclick="processData()">üîÑ Processar e Visualizar</button>
        <button onclick="clearAll()" style="background: #dc3545;">
          üóëÔ∏è Limpar Tudo
        </button>
        <div class="zoom-controls">
          <button onclick="zoomOut()" style="background: #6c757d;">
            üîç-
          </button>
          <span id="zoomLevel">Zoom: 150%</span>
          <button onclick="zoomIn()" style="background: #6c757d;">
            üîç+
          </button>
          <button onclick="resetZoom()" style="background: #17a2b8; margin-left: 10px;">
            ‚Üª Reset
          </button>
        </div>
      </div>

      <div class="visualization">
        <canvas id="canvas" width="1100" height="800"></canvas>
      </div>

      <div id="infoPanel" class="info-panel" style="display: none">
        <h3>üìä Medidas e An√°lises das Estruturas</h3>
        <div id="distanceInfo" class="distance-grid"></div>
        
        <!-- Resumo Executivo -->
        <div id="executiveSummary" style="margin-top: 20px; padding: 15px; background: linear-gradient(135deg, #f8f9fa, #e9ecef); border-radius: 8px; border-left: 4px solid #007bff;"></div>
      </div>

      <div id="errorMsg"></div>
    </div>

    <script>
      // Vari√°veis globais para zoom e dados
      let currentZoom = 1.0;
      let currentPoints1 = {};
      let currentPoints2 = {};
      
      function loadExample1() {
        const exampleData1 = `Name,Code,Lat,Long,H_GEO,H_ORTO,x,y
"05",JUSESQ,-9.8976347800,-36.4167136000,188.80925,197.1262098000,-36.4167136710,-9.8976347823
"06",JUSDIR,-9.8975431900,-36.4167583000,189.01495,197.3316011000,-36.4167583598,-9.8975431976
P-04,LD_FINAL_OAE,-9.8974730300,-36.4166092000,188.93670,197.2531865000,-36.4166092614,-9.8974730373
P-03,LE_FINAL_OAE,-9.8975631400,-36.4165642000,188.78735,197.1041407000,-36.4165642134,-9.8975631483
P-01,LE_INICIO_OAE,-9.8975029500,-36.4164419000,188.77963,197.0962773000,-36.4164419708,-9.8975029554
P-02,LD_INICIO_OAE,-9.8974121600,-36.4164865000,188.99719,197.3135310000,-36.4164865650,-9.8974121660
"07",MONDIR,-9.8972934700,-36.4162403000,188.86808,197.1841401000,-36.4162403921,-9.8972934728
"08",MONESQ,-9.8973829800,-36.4161912000,188.66533,196.9816940000,-36.4161912260,-9.8973829816`;

        document.getElementById('csvData1').value = exampleData1;
        processData();
      }

      function loadExample2() {
        const exampleData2 = `Name,Code,Lat,Long,H_GEO,H_ORTO,x,y
"09",JUSESQ,-9.8970347800,-36.4160136000,188.80925,197.1262098000,-36.4160136710,-9.8970347823
"10",JUSDIR,-9.8969431900,-36.4160583000,189.01495,197.3316011000,-36.4160583598,-9.8969431976
P-08,LD_FINAL_OAE,-9.8968730300,-36.4159092000,188.93670,197.2531865000,-36.4159092614,-9.8968730373
P-07,LE_FINAL_OAE,-9.8969631400,-36.4158642000,188.78735,197.1041407000,-36.4158642134,-9.8969631483
P-05,LE_INICIO_OAE,-9.8969029500,-36.4157419000,188.77963,197.0962773000,-36.4157419708,-9.8969029554
P-06,LD_INICIO_OAE,-9.8968121600,-36.4157865000,188.99719,197.3135310000,-36.4157865650,-9.8968121660
"11",MONDIR,-9.8966934700,-36.4155403000,188.86808,197.1841401000,-36.4155403921,-9.8966934728
"12",MONESQ,-9.8967829800,-36.4154912000,188.66533,196.9816940000,-36.4154912260,-9.8967829816`;

        document.getElementById('csvData2').value = exampleData2;
        processData();
      }

      // Fun√ß√µes de zoom
      function zoomIn() {
        currentZoom = Math.min(currentZoom * 1.2, 3.0); // M√°ximo 300%
        updateZoomDisplay();
        redrawVisualization();
      }
      
      function zoomOut() {
        currentZoom = Math.max(currentZoom / 1.2, 0.3); // M√≠nimo 30%
        updateZoomDisplay();
        redrawVisualization();
      }
      
      function resetZoom() {
        currentZoom = 1.0;
        updateZoomDisplay();
        redrawVisualization();
      }
      
      function updateZoomDisplay() {
        const zoomPercent = Math.round(currentZoom * 100);
        document.getElementById('zoomLevel').textContent = `Zoom: ${zoomPercent}%`;
      }
      
      function redrawVisualization() {
        if (Object.keys(currentPoints1).length > 0) {
          drawVisualization(currentPoints1, currentPoints2);
        }
      }

      function clearAll() {
        document.getElementById('csvData1').value = '';
        document.getElementById('csvData2').value = '';
        document.getElementById('infoPanel').style.display = 'none';
        document.getElementById('errorMsg').innerHTML = '';
        
        // Limpar dados de zoom
        currentZoom = 1.0;
        currentPoints1 = {};
        currentPoints2 = {};
        updateZoomDisplay();
        
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      function parseCSV(csvText) {
        if (!csvText.trim()) return [];
        
        const lines = csvText.trim().split("\n");
        const firstLine = lines[0];
        let headers;
        let dataStartIndex = 0;

        // Detectar se primeira linha s√£o headers ou dados
        if (
          firstLine.includes("Name") ||
          firstLine.includes("Code") ||
          firstLine.includes("Lat") ||
          firstLine.includes("Long") ||
          firstLine.includes("x") ||
          firstLine.includes("y")
        ) {
          // Primeira linha s√£o headers
          headers = lines[0].split(",").map((h) => h.trim().replace(/"/g, ''));
          dataStartIndex = 1;
        } else {
          // Assumir formato sem headers: [√≠ndice, y, x, altura, nome]
          headers = ["0", "1", "2", "3", "4"];
          dataStartIndex = 0;
        }

        console.log("Headers detectados:", headers);

        const data = [];
        for (let i = dataStartIndex; i < lines.length; i++) {
          if (lines[i].trim() === "") continue; // pular linhas vazias

          const values = lines[i].split(",");
          const row = {};
          headers.forEach((header, index) => {
            row[header] = values[index]?.trim().replace(/"/g, '') || "";
          });
          data.push(row);
        }
        return data;
      }

      function calculateDistance(point1, point2) {
        const x1 = parseFloat(point1.x);
        const y1 = parseFloat(point1.y);
        const x2 = parseFloat(point2.x);
        const y2 = parseFloat(point2.y);

        console.log(
          `Calculando dist√¢ncia entre:`,
          `P1(${x1}, ${y1}) e P2(${x2}, ${y2})`
        );

        const deltaX = x2 - x1;
        const deltaY = y2 - y1;

        // Detectar se coordenadas est√£o em graus (lat/long) ou metros (UTM)
        const isGeographic =
          Math.abs(x1) < 180 &&
          Math.abs(y1) < 90 &&
          Math.abs(x2) < 180 &&
          Math.abs(y2) < 90;

        let distance;

        if (isGeographic) {
          console.log(
            "Coordenadas geogr√°ficas detectadas - convertendo para metros"
          );
          // Converter coordenadas geogr√°ficas para metros
          const lat1Rad = (y1 * Math.PI) / 180;
          const lat2Rad = (y2 * Math.PI) / 180;
          const avgLatRad = (lat1Rad + lat2Rad) / 2;

          // Convers√£o para metros
          const deltaLatM = deltaY * 111320; // metros por grau de latitude
          const deltaLonM = deltaX * 111320 * Math.cos(avgLatRad); // metros por grau de longitude

          distance = Math.sqrt(deltaLatM * deltaLatM + deltaLonM * deltaLonM);
          console.log(
            `Diferen√ßas: dx=${deltaX}¬∞ (${deltaLonM.toFixed(
              3
            )}m), dy=${deltaY}¬∞ (${deltaLatM.toFixed(
              3
            )}m), dist√¢ncia=${distance.toFixed(3)}m`
          );
        } else {
          console.log(
            "Coordenadas planas/UTM detectadas - c√°lculo direto em metros"
          );
          // Coordenadas j√° est√£o em metros (UTM ou sistema local)
          distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
          console.log(
            `Diferen√ßas: dx=${deltaX.toFixed(3)}m, dy=${deltaY.toFixed(
              3
            )}m, dist√¢ncia=${distance.toFixed(3)}m`
          );
        }

        return distance;
      }

      function findPoints(data) {
        const points = {};
        data.forEach((row, index) => {
          const name = row.Name || row.Code || row["4"] || "";
          const code = row.Code || row.Name || row["4"] || "";

          console.log(`Linha ${index}: Name="${name}", Code="${code}"`);

          // Procurar pelos c√≥digos espec√≠ficos nos dados
          if (
            code.includes("LD_INICIO_OAE") ||
            code.includes("LE_INICIO_OAE") ||
            code.includes("LD_FINAL_OAE") ||
            code.includes("LE_FINAL_OAE") ||
            name.includes("LD_INICIO_OAE") ||
            name.includes("LE_INICIO_OAE") ||
            name.includes("LD_FINAL_OAE") ||
            name.includes("LE_FINAL_OAE")
          ) {
            // Detectar formato dos dados
            let xCoord, yCoord;

            if (row.x && row.y) {
              // Formato original com headers x,y
              xCoord = parseFloat(row.x);
              yCoord = parseFloat(row.y);
            } else if (row.Long && row.Lat) {
              // Usar Lat/Long se x,y n√£o estiverem dispon√≠veis
              xCoord = parseFloat(row.Long);
              yCoord = parseFloat(row.Lat);
            }

            const pointData = {
              x: xCoord,
              y: yCoord,
              lat: parseFloat(row.Lat) || yCoord,
              long: parseFloat(row.Long) || xCoord,
              name: name || code,
              code: code || name,
              originalName: name,
              originalCode: code,
            };

            console.log(`Ponto encontrado: ${code || name}`, pointData);
            
            // Usar tanto code quanto name como chave para garantir que encontremos
            if (code) points[code] = pointData;
            if (name && name !== code) points[name] = pointData;
          }
        });
        
        console.log("Todos os pontos encontrados:", Object.keys(points));
        return points;
      }

      function drawVisualization(points1, points2 = {}) {
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");

        // Limpar canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Combinar todos os pontos para calcular escala
        const allPoints = {...points1, ...points2};
        const coords = Object.values(allPoints);
        if (coords.length === 0) return;

        const minX = Math.min(...coords.map((p) => p.x));
        const maxX = Math.max(...coords.map((p) => p.x));
        const minY = Math.min(...coords.map((p) => p.y));
        const maxY = Math.max(...coords.map((p) => p.y));

        // Margens muito maiores para garantir que nunca corte
        const margin = 120;
        const scaleX = (canvas.width - 2 * margin) / (maxX - minX);
        const scaleY = (canvas.height - 2 * margin) / (maxY - minY);
        // Reduzir escala drasticamente e aplicar zoom atual
        const scaleFactor = Object.keys(points2).length > 0 ? 0.15 : 0.25;
        const scale = Math.min(scaleX, scaleY) * scaleFactor * currentZoom;

        // Centralizar
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const dataWidth = (maxX - minX) * scale;
        const dataHeight = (maxY - minY) * scale;

        function toCanvasCoords(point) {
          return {
            x: centerX - dataWidth / 2 + (point.x - minX) * scale,
            y: centerY + dataHeight / 2 - (point.y - minY) * scale,
          };
        }

        // Fun√ß√£o para desenhar uma estrutura
        function drawStructure(points, color, label) {
          console.log(`Desenhando estrutura ${label}, pontos dispon√≠veis:`, Object.keys(points));
          
          // Busca mais robusta para os pontos
          const ldInicio = Object.values(points).find(p => 
            p.code.includes("LD_INICIO_OAE") || 
            p.name.includes("LD_INICIO_OAE") ||
            p.originalCode.includes("LD_INICIO_OAE") ||
            p.originalName.includes("LD_INICIO_OAE")
          );
          
          const leInicio = Object.values(points).find(p => 
            p.code.includes("LE_INICIO_OAE") || 
            p.name.includes("LE_INICIO_OAE") ||
            p.originalCode.includes("LE_INICIO_OAE") ||
            p.originalName.includes("LE_INICIO_OAE")
          );
          
          const ldFinal = Object.values(points).find(p => 
            p.code.includes("LD_FINAL_OAE") || 
            p.name.includes("LD_FINAL_OAE") ||
            p.originalCode.includes("LD_FINAL_OAE") ||
            p.originalName.includes("LD_FINAL_OAE")
          );
          
          const leFinal = Object.values(points).find(p => 
            p.code.includes("LE_FINAL_OAE") || 
            p.name.includes("LE_FINAL_OAE") ||
            p.originalCode.includes("LE_FINAL_OAE") ||
            p.originalName.includes("LE_FINAL_OAE")
          );

          console.log(`Estrutura ${label} - Pontos encontrados:`);
          console.log("LD_INICIO_OAE:", ldInicio);
          console.log("LE_INICIO_OAE:", leInicio);
          console.log("LD_FINAL_OAE:", ldFinal);
          console.log("LE_FINAL_OAE:", leFinal);

          if (!ldInicio || !leInicio || !ldFinal || !leFinal) {
            console.log(`Estrutura ${label} incompleta, pontos faltando`);
            return null;
          }

          // Converter para coordenadas do canvas
          const ldInicioCanvas = toCanvasCoords(ldInicio);
          const leInicioCanvas = toCanvasCoords(leInicio);
          const ldFinalCanvas = toCanvasCoords(ldFinal);
          const leFinalCanvas = toCanvasCoords(leFinal);

          // Desenhar ret√¢ngulo
          ctx.strokeStyle = color;
          const rectLineWidth = Math.max(1, 1.5 * currentZoom);
          ctx.lineWidth = rectLineWidth;
          ctx.beginPath();
          ctx.moveTo(ldInicioCanvas.x, ldInicioCanvas.y);
          ctx.lineTo(leInicioCanvas.x, leInicioCanvas.y);
          ctx.lineTo(leFinalCanvas.x, leFinalCanvas.y);
          ctx.lineTo(ldFinalCanvas.x, ldFinalCanvas.y);
          ctx.closePath();
          ctx.stroke();

          // Preencher ret√¢ngulo com transpar√™ncia
          const alpha = color === "#007bff" ? "0.08" : "0.04";
          ctx.fillStyle = color.replace("rgb", "rgba").replace(")", `, ${alpha})`);
          if (color.startsWith("#")) {
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
          }
          ctx.fill();

          // Desenhar pontos
          const pointData = [
            { canvas: ldInicioCanvas, color: "#dc3545", label: `LD_INICIO_OAE ${label}` },
            { canvas: leInicioCanvas, color: "#28a745", label: `LE_INICIO_OAE${label}` },
            { canvas: ldFinalCanvas, color: "#dc3545", label: `LD_FINAL_OAE ${label}` },
            { canvas: leFinalCanvas, color: "#28a745", label: `LE_FINAL_OAE ${label}` },
          ];

          pointData.forEach(({ canvas, color, label }) => {
            ctx.fillStyle = color;
            ctx.beginPath();
            // Tamanho do ponto ajustado pelo zoom
            const pointRadius = Math.max(2, 3 * currentZoom);
            ctx.arc(canvas.x, canvas.y, pointRadius, 0, 2 * Math.PI);
            ctx.fill();

            // Label do ponto com tamanho ajustado pelo zoom
            ctx.fillStyle = "#333";
            const fontSize = Math.max(6, 8 * currentZoom);
            ctx.font = `${fontSize}px Arial`;
            ctx.textAlign = "center";
            const labelOffset = Math.max(8, 10 * currentZoom);
            ctx.fillText(label, canvas.x, canvas.y - labelOffset);
          });

          return { ldInicio, leInicio, ldFinal, leFinal };
        }

        // Desenhar primeira estrutura
        const struct1 = drawStructure(points1, "#007bff", "(1)");
        
        // Desenhar segunda estrutura se existir
        const struct2 = Object.keys(points2).length > 0 ? drawStructure(points2, "#e91e63", "(2)") : null;

        // Desenhar linha de conex√£o AP√ìS ambas as estruturas
        if (struct1 && struct2) {
          console.log("=== DESENHANDO LINHA DE CONEX√ÉO ===");
          console.log("Struct1 LE_INICIO:", struct1.leInicio);
          console.log("Struct2 LD_INICIO:", struct2.ldInicio);
          
          const leInicio1Canvas = toCanvasCoords(struct1.leInicio);
          const ldInicio2Canvas = toCanvasCoords(struct2.ldInicio);
          
          console.log("Canvas coords - LE(1):", leInicio1Canvas);
          console.log("Canvas coords - LD(2):", ldInicio2Canvas);

          // Linha pontilhada conectando as estruturas
          ctx.strokeStyle = "#ff9800";
          const lineWidth = Math.max(2, 3 * currentZoom);
          ctx.lineWidth = lineWidth;
          const dashLength = Math.max(8, 12 * currentZoom);
          ctx.setLineDash([dashLength, dashLength/2]);
          ctx.beginPath();
          ctx.moveTo(leInicio1Canvas.x, leInicio1Canvas.y);
          ctx.lineTo(ldInicio2Canvas.x, ldInicio2Canvas.y);
          ctx.stroke();
          ctx.setLineDash([]);

          console.log("Linha desenhada de:", leInicio1Canvas, "para:", ldInicio2Canvas);

          // Label da dist√¢ncia na linha
          const midX = (leInicio1Canvas.x + ldInicio2Canvas.x) / 2;
          const midY = (leInicio1Canvas.y + ldInicio2Canvas.y) / 2;
          const crossDistance = calculateDistance(struct1.leInicio, struct2.ldInicio);
          
          // Fundo branco para o texto ficar mais vis√≠vel
          const textWidth = 60;
          const textHeight = 20;
          ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
          ctx.fillRect(midX - textWidth/2, midY - textHeight/2, textWidth, textHeight);
          
          // Borda do fundo
          ctx.strokeStyle = "#ff9800";
          ctx.lineWidth = 1;
          ctx.strokeRect(midX - textWidth/2, midY - textHeight/2, textWidth, textHeight);
          
          // Texto da dist√¢ncia
          ctx.fillStyle = "#ff9800";
          const crossFontSize = Math.max(10, 12 * currentZoom);
          ctx.font = `bold ${crossFontSize}px Arial`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(`${crossDistance.toFixed(3)}m`, midX, midY);
          
          console.log(`=== LINHA CONCLU√çDA: ${crossDistance.toFixed(3)}m ===`);
        } else {
          console.log("Linha n√£o desenhada - estruturas:", !!struct1, !!struct2);
        }

        // Calcular e mostrar informa√ß√µes
        showDistanceInfo(struct1, struct2);
      }

      function showDistanceInfo(struct1, struct2) {
        const infoPanel = document.getElementById("infoPanel");
        const distanceInfo = document.getElementById("distanceInfo");

        if (!struct1) return;

        let html = '';

        // Informa√ß√µes da primeira estrutura
        const dist1Inicio = calculateDistance(struct1.ldInicio, struct1.leInicio);
        const dist1Final = calculateDistance(struct1.ldFinal, struct1.leFinal);
        const dist1LD = calculateDistance(struct1.ldInicio, struct1.ldFinal);
        const dist1LE = calculateDistance(struct1.leInicio, struct1.leFinal);
        const media1Largura = (dist1Inicio + dist1Final) / 2;
        const media1Comprimento = (dist1LD + dist1LE) / 2;

        // AN√ÅLISE COMPARATIVA PRIMEIRO
        if (struct2) {
          const dist2Inicio = calculateDistance(struct2.ldInicio, struct2.leInicio);
          const dist2Final = calculateDistance(struct2.ldFinal, struct2.leFinal);
          const dist2LD = calculateDistance(struct2.ldInicio, struct2.ldFinal);
          const dist2LE = calculateDistance(struct2.leInicio, struct2.leFinal);
          const media2Largura = (dist2Inicio + dist2Final) / 2;
          const media2Comprimento = (dist2LD + dist2LE) / 2;

          // An√°lises comparativas
          const crossDistance = calculateDistance(struct1.leInicio, struct2.ldInicio);
          const diferencaLargura = Math.abs(media1Largura - media2Largura);
          const diferencaComprimento = Math.abs(media1Comprimento - media2Comprimento);
          
          // M√©dias gerais entre as duas estruturas
          const mediaGeralLargura = (media1Largura + media2Largura) / 2;
          const mediaGeralComprimento = (media1Comprimento + media2Comprimento) / 2;
          
          // Calcular dist√¢ncias X e Y
          let deltaX = 0;
          let deltaY = 0;
          
          console.log("Calculando dist√¢ncias X e Y:");
          console.log("struct1.leInicio:", struct1.leInicio);
          console.log("struct2.ldInicio:", struct2.ldInicio);
          
          if (struct1.leInicio && struct2.ldInicio) {
            const x1 = parseFloat(struct1.leInicio.x);
            const y1 = parseFloat(struct1.leInicio.y);
            const x2 = parseFloat(struct2.ldInicio.x);
            const y2 = parseFloat(struct2.ldInicio.y);
            
            console.log(`Coordenadas: P1(${x1}, ${y1}) -> P2(${x2}, ${y2})`);
            
            if (!isNaN(x1) && !isNaN(y1) && !isNaN(x2) && !isNaN(y2)) {
              deltaX = Math.abs(x2 - x1);
              deltaY = Math.abs(y2 - y1);
              
              console.log(`Deltas antes da convers√£o: X=${deltaX}, Y=${deltaY}`);
              
              const isGeographic = Math.abs(x1) < 180 && Math.abs(y1) < 90 && Math.abs(x2) < 180 && Math.abs(y2) < 90;
              
              if (isGeographic) {
                console.log("Convertendo coordenadas geogr√°ficas para metros");
                const avgLatRad = ((y1 + y2) / 2 * Math.PI) / 180;
                deltaX = deltaX * 111320 * Math.cos(avgLatRad);
                deltaY = deltaY * 111320;
              }
              
              console.log(`Dist√¢ncias finais: X=${deltaX.toFixed(3)}m, Y=${deltaY.toFixed(3)}m`);
            } else {
              console.error("Coordenadas cont√™m valores NaN");
            }
          } else {
            console.error("Pontos struct1.leInicio ou struct2.ldInicio n√£o encontrados");
          }
          
          html += `
            <div class="distance-card cross-section">
              <div><strong>üîç AN√ÅLISE COMPARATIVA</strong></div>
            </div>
            <div class="distance-card cross-distance-card">
              <div><strong>Dist√¢ncia Entre Estruturas</strong></div>
              <div class="distance-value cross-distance-value">${crossDistance.toFixed(3)} m</div>
              <small>LE_INICIO_OAE (1) ‚Üî LD_INICIO_OAE (2)</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #f8f9fa, #e9ecef); border: 2px solid #6c757d;">
              <div><strong>üìê Dist√¢ncia em X</strong></div>
              <div class="distance-value" style="color: ${deltaX >= 0 ? '#6c757d' : '#dc3545'};">${deltaX >= 0 ? deltaX.toFixed(3) : 'N/A'} m</div>
              <small>${deltaX >= 0 ? 'Diferen√ßa horizontal' : 'Erro no c√°lculo'}</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #f8f9fa, #e9ecef); border: 2px solid #6c757d;">
              <div><strong>üìê Dist√¢ncia em Y</strong></div>
              <div class="distance-value" style="color: ${deltaY >= 0 ? '#6c757d' : '#dc3545'};">${deltaY >= 0 ? deltaY.toFixed(3) : 'N/A'} m</div>
              <small>${deltaY >= 0 ? 'Diferen√ßa vertical' : 'Erro no c√°lculo'}</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #e3f2fd, #f3e5f5); border: 2px solid #9c27b0;">
              <div><strong>üìè M√©dia Geral Largura</strong></div>
              <div class="distance-value" style="color: #9c27b0;">${mediaGeralLargura.toFixed(3)} m</div>
              <small>(Est.1 + Est.2) √∑ 2</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #e8f5e8, #fff3e0); border: 2px solid #ff9800;">
              <div><strong>üìê M√©dia Geral Comprimento</strong></div>
              <div class="distance-value" style="color: #ff9800;">${mediaGeralComprimento.toFixed(3)} m</div>
              <small>(Est.1 + Est.2) √∑ 2</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #ffebee, #f3e5f5); border: 2px solid #e91e63;">
              <div><strong>Diferen√ßa de Larguras</strong></div>
              <div class="distance-value" style="color: #e91e63;">${diferencaLargura.toFixed(3)} m</div>
              <small>|Estrutura 1 - Estrutura 2|</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #e8f5e8, #e0f2f1); border: 2px solid #4caf50;">
              <div><strong>Diferen√ßa de Comprimentos</strong></div>
              <div class="distance-value" style="color: #4caf50;">${diferencaComprimento.toFixed(3)} m</div>
              <small>|Estrutura 1 - Estrutura 2|</small>
            </div>
          `;
        }

        // ESTRUTURA 1
        html += `
          <div class="section-divider"></div>
          <div class="distance-card structure-section">
            <div><strong>üèóÔ∏è ESTRUTURA 1 (AZUL)</strong></div>
          </div>
          <div class="distance-card">
            <div><strong>Largura INICIO_OAE</strong></div>
            <div class="distance-value">${dist1Inicio.toFixed(3)} m</div>
            <small>LD_INICIO_OAE ‚Üî LE_INICIO_OAE</small>
          </div>
          <div class="distance-card">
            <div><strong>Largura Final</strong></div>
            <div class="distance-value">${dist1Final.toFixed(3)} m</div>
            <small>LD_FINAL_OAE ‚Üî LE_FINAL_OAE</small>
          </div>
          <div class="distance-card" style="background: linear-gradient(135deg, #e3f2fd, #f3e5f5); border: 2px solid #9c27b0;">
            <div><strong>üìè M√©dia Largura</strong></div>
            <div class="distance-value" style="color: #9c27b0;">${media1Largura.toFixed(3)} m</div>
            <small>Estrutura 1</small>
          </div>
          <div class="distance-card">
            <div><strong>Comprimento LD</strong></div>
            <div class="distance-value">${dist1LD.toFixed(3)} m</div>
            <small>LD_INICIO_OAE ‚Üî LD_FINAL_OAE</small>
          </div>
          <div class="distance-card">
            <div><strong>Comprimento LE</strong></div>
            <div class="distance-value">${dist1LE.toFixed(3)} m</div>
            <small>LE_INICIO_OAE ‚Üî LE_FINAL</small>
          </div>
          <div class="distance-card" style="background: linear-gradient(135deg, #e8f5e8, #fff3e0); border: 2px solid #ff9800;">
            <div><strong>üìê M√©dia Comprimento</strong></div>
            <div class="distance-value" style="color: #ff9800;">${media1Comprimento.toFixed(3)} m</div>
            <small>Estrutura 1</small>
          </div>
        `;

        // ESTRUTURA 2 (se existir)
        if (struct2) {
          const dist2Inicio = calculateDistance(struct2.ldInicio, struct2.leInicio);
          const dist2Final = calculateDistance(struct2.ldFinal, struct2.leFinal);
          const dist2LD = calculateDistance(struct2.ldInicio, struct2.ldFinal);
          const dist2LE = calculateDistance(struct2.leInicio, struct2.leFinal);
          const media2Largura = (dist2Inicio + dist2Final) / 2;
          const media2Comprimento = (dist2LD + dist2LE) / 2;

          html += `
            <div class="section-divider"></div>
            <div class="distance-card structure-section">
              <div><strong>üèóÔ∏è ESTRUTURA 2 (ROSA)</strong></div>
            </div>
            <div class="distance-card">
              <div><strong>Largura INICIO_OAE</strong></div>
              <div class="distance-value">${dist2Inicio.toFixed(3)} m</div>
              <small>LD_INICIO_OAE ‚Üî LE_INICIO_OAE</small>
            </div>
            <div class="distance-card">
              <div><strong>Largura Final</strong></div>
              <div class="distance-value">${dist2Final.toFixed(3)} m</div>
              <small>LD_FINAL_OAE ‚Üî LE_FINAL_OAE</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #e3f2fd, #f3e5f5); border: 2px solid #9c27b0;">
              <div><strong>üìè M√©dia Largura</strong></div>
              <div class="distance-value" style="color: #9c27b0;">${media2Largura.toFixed(3)} m</div>
              <small>Estrutura 2</small>
            </div>
            <div class="distance-card">
              <div><strong>Comprimento LD</strong></div>
              <div class="distance-value">${dist2LD.toFixed(3)} m</div>
              <small>LD_INICIO_OAE ‚Üî LD_FINAL_OAE</small>
            </div>
            <div class="distance-card">
              <div><strong>Comprimento LE</strong></div>
              <div class="distance-value">${dist2LE.toFixed(3)} m</div>
              <small>LE_INICIO_OAE ‚Üî LE_FINAL_OAE</small>
            </div>
            <div class="distance-card" style="background: linear-gradient(135deg, #e8f5e8, #fff3e0); border: 2px solid #ff9800;">
              <div><strong>üìê M√©dia Comprimento</strong></div>
              <div class="distance-value" style="color: #ff9800;">${media2Comprimento.toFixed(3)} m</div>
              <small>Estrutura 2</small>
            </div>
          `;
        }

        distanceInfo.innerHTML = html;
        
        // Adicionar resumo executivo
        if (struct2) {
          const dist2Inicio = calculateDistance(struct2.ldInicio, struct2.leInicio);
          const dist2Final = calculateDistance(struct2.ldFinal, struct2.leFinal);
          const dist2LD = calculateDistance(struct2.ldInicio, struct2.ldFinal);
          const dist2LE = calculateDistance(struct2.leInicio, struct2.leFinal);
          const crossDistance = calculateDistance(struct1.leInicio, struct2.ldInicio);
          const mediaGeralLargura = (media1Largura + media2Largura) / 2;
          const mediaGeralComprimento = (media1Comprimento + media2Comprimento) / 2;
          
          const summaryHtml = `
            <h4 style="margin-bottom: 15px; color: #495057;">üìã Resumo Executivo - An√°lise Geral</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; text-align: center;">
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: #9c27b0;">üìè Largura M√©dia</div>
                <div style="font-size: 16px; font-weight: bold; color: #9c27b0; margin: 5px 0;">${mediaGeralLargura.toFixed(3)}m</div>
                <div style="font-size: 12px; color: #6c757d;">Entre estruturas</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: #ff9800;">üìê Comprimento M√©dio</div>
                <div style="font-size: 16px; font-weight: bold; color: #ff9800; margin: 5px 0;">${mediaGeralComprimento.toFixed(3)}m</div>
                <div style="font-size: 12px; color: #6c757d;">Entre estruturas</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: #007bff;">üåâ Dist√¢ncia Total</div>
                <div style="font-size: 16px; font-weight: bold; color: #007bff; margin: 5px 0;">${crossDistance.toFixed(3)}m</div>
                <div style="font-size: 12px; color: #6c757d;">LE(1) ‚Üî LD(2)</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: #6c757d;">üìê Dist√¢ncia X</div>
                <div style="font-size: 16px; font-weight: bold; color: ${deltaX >= 0 ? '#6c757d' : '#dc3545'}; margin: 5px 0;">${deltaX >= 0 ? deltaX.toFixed(3) + 'm' : 'N/A'}</div>
                <div style="font-size: 12px; color: #6c757d;">Horizontal</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: #6c757d;">üìê Dist√¢ncia Y</div>
                <div style="font-size: 16px; font-weight: bold; color: ${deltaY >= 0 ? '#6c757d' : '#dc3545'}; margin: 5px 0;">${deltaY >= 0 ? deltaY.toFixed(3) + 'm' : 'N/A'}</div>
                <div style="font-size: 12px; color: #6c757d;">Vertical</div>
              </div>
            </div>
          `;
          document.getElementById('executiveSummary').innerHTML = summaryHtml;
        } else {
          const summaryHtml = `
            <h4 style="margin-bottom: 15px; color: #495057;">üìã Resumo Executivo</h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; text-align: center;">
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: #9c27b0;">üìè Largura M√©dia</div>
                <div style="font-size: 18px; font-weight: bold; color: #9c27b0; margin: 5px 0;">${media1Largura.toFixed(3)} m</div>
              </div>
              <div style="background: white; padding: 12px; border-radius: 6px; border: 1px solid #dee2e6;">
                <div style="font-weight: bold; color: #ff9800;">üìê Comprimento M√©dio</div>
                <div style="font-size: 18px; font-weight: bold; color: #ff9800; margin: 5px 0;">${media1Comprimento.toFixed(3)} m</div>
              </div>
            </div>
          `;
          document.getElementById('executiveSummary').innerHTML = summaryHtml;
        }
        
        infoPanel.style.display = "block";
      }

      function processData() {
        const csvData1 = document.getElementById("csvData1").value;
        const csvData2 = document.getElementById("csvData2").value;
        const errorMsg = document.getElementById("errorMsg");
        errorMsg.innerHTML = "";

        if (!csvData1.trim()) {
          errorMsg.innerHTML = '<div class="error">‚ö†Ô∏è Por favor, cole pelo menos os dados do CSV 1!</div>';
          return;
        }

        try {
          const data1 = parseCSV(csvData1);
          const data2 = parseCSV(csvData2);
          
          console.log("Dados CSV 1 parseados:", data1);
          console.log("Dados CSV 2 parseados:", data2);

          const points1 = findPoints(data1);
          const points2 = findPoints(data2);
          
          // Armazenar pontos globalmente para zoom
          currentPoints1 = points1;
          currentPoints2 = points2;
          
          console.log("Pontos encontrados CSV 1:", points1);
          console.log("Pontos encontrados CSV 2:", points2);

          if (Object.keys(points1).length === 0) {
            errorMsg.innerHTML = '<div class="error">‚ö†Ô∏è Nenhum ponto LD ou LE encontrado no CSV 1!</div>';
            return;
          }

          drawVisualization(points1, points2);
        } catch (error) {
        }
      }

      // Pr√©-carregar dados de exemplo
      window.onload = function () {
        loadExample1();
      };
    </script>
  </body>
</html>
