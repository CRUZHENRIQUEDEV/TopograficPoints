<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
      Conversor de Imagens Georreferenciadas para GeoJSON - OAE Support
    </title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exif-js/2.3.0/exif.min.js"></script>

    <!-- Leaflet CSS e JS -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(
          135deg,
          #2c3e50 0%,
          #34495e 50%,
          #2c3e50 100%
        );
        min-height: 100vh;
        color: #ffffff;
        overflow-x: hidden;
      }

      .main-container {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
      }

      .map-container {
        width: 100vw;
        margin-left: calc(-50vw + 50%);
        padding: 0;
        background: rgba(255, 255, 255, 0.05);
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .map-header {
        max-width: 800px;
        margin: 0 auto;
        padding: 2rem 2rem 1rem 2rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 1rem;
      }

      .map-controls {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .map-controls select {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        color: white;
        padding: 8px 12px;
        font-size: 14px;
        backdrop-filter: blur(5px);
      }

      .map-controls select option {
        background: #2c3e50;
        color: white;
      }

      h1,
      h2 {
        color: #ffffff;
        font-weight: 700;
        margin-bottom: 1rem;
        background: linear-gradient(45deg, #ffffff, #e3f2fd);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      }

      h1 {
        font-size: 2.2rem;
        text-align: center;
        margin-bottom: 2rem;
      }

      h2 {
        font-size: 1.5rem;
      }

      .container {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 20px;
        padding: 2rem;
        margin-bottom: 2rem;
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
      }

      .container::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.1),
          transparent
        );
        transition: left 0.5s ease;
      }

      .container:hover::before {
        left: 100%;
      }

      .container:hover {
        transform: translateY(-5px);
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        border-color: rgba(255, 255, 255, 0.4);
      }

      #dropZone {
        border: 2px dashed #3498db;
        border-radius: 15px;
        padding: 30px;
        text-align: center;
        margin: 20px 0;
        cursor: pointer;
        background: rgba(52, 152, 219, 0.1);
        transition: all 0.3s ease;
        backdrop-filter: blur(5px);
      }

      #dropZone:hover {
        background: rgba(52, 152, 219, 0.2);
        border-color: #64b5f6;
        transform: translateY(-2px);
      }

      #dropZone h3 {
        color: #64b5f6;
        margin-bottom: 1rem;
      }

      button {
        background: linear-gradient(45deg, #3498db, #2ecc71);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 15px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 600;
        margin: 10px 5px;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        background: linear-gradient(45deg, #2980b9, #27ae60);
      }

      button:disabled {
        background: linear-gradient(45deg, #95a5a6, #7f8c8d);
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        overflow: hidden;
        backdrop-filter: blur(5px);
      }

      th,
      td {
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: 12px;
        text-align: left;
      }

      th {
        background: rgba(52, 152, 219, 0.3);
        font-weight: 600;
        color: #ffffff;
      }

      td {
        background: rgba(255, 255, 255, 0.05);
      }

      tbody tr:hover td {
        background: rgba(255, 255, 255, 0.1);
      }

      #map {
        height: 70vh;
        min-height: 500px;
        width: 100%;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(5px);
        z-index: 1;
      }

      .progress-bar {
        width: 100%;
        background: rgba(255, 255, 255, 0.2);
        padding: 3px;
        border-radius: 15px;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
        margin: 20px 0;
        backdrop-filter: blur(5px);
      }

      .progress {
        background: linear-gradient(45deg, #3498db, #2ecc71);
        height: 20px;
        border-radius: 12px;
        transition: width 0.3s ease;
        text-align: center;
        line-height: 20px;
        color: white;
        font-weight: 600;
      }

      .note {
        background: rgba(255, 235, 59, 0.2);
        padding: 15px;
        border-left: 4px solid #ffd600;
        margin: 15px 0;
        border-radius: 10px;
        backdrop-filter: blur(5px);
      }

      #stats {
        background: rgba(255, 255, 255, 0.1);
        padding: 15px;
        border-radius: 15px;
        margin: 20px 0;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      #stats p {
        margin: 5px 0;
        font-weight: 500;
      }

      #stats span {
        color: #64b5f6;
        font-weight: 700;
      }

      .footer {
        text-align: center;
        padding: 2rem 0;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        margin-top: 3rem;
        background: rgba(44, 62, 80, 0.3);
        border-radius: 15px 15px 0 0;
      }

      .footer p {
        opacity: 0.9;
        font-size: 0.95rem;
        margin-bottom: 0.5rem;
      }

      .zenith-brand {
        font-weight: 600;
        background: linear-gradient(45deg, #3498db, #2ecc71);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        font-size: 1.1rem;
      }

      /* Customiza√ß√£o do popup do Leaflet */
      .leaflet-popup-content {
        color: #333;
        font-size: 14px;
        width: 280px !important;
      }

      .leaflet-popup-content h4 {
        margin: 0 0 10px 0;
        color: #2c3e50;
      }

      /* Estilos para os campos de renomea√ß√£o no popup */
      .rename-section {
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px solid #ddd;
      }

      .rename-input {
        width: 100%;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 5px;
        font-size: 14px;
        margin-bottom: 10px;
        font-family: inherit;
      }

      .rename-input:focus {
        outline: none;
        border-color: #3498db;
        box-shadow: 0 0 5px rgba(52, 152, 219, 0.3);
      }

      .popup-buttons {
        display: flex;
        gap: 5px;
        flex-wrap: wrap;
      }

      .popup-btn {
        background: #3498db;
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 12px;
        font-weight: 500;
        transition: background 0.3s ease;
        flex: 1;
        min-width: 80px;
      }

      .popup-btn:hover {
        background: #2980b9;
        transform: none;
        box-shadow: none;
      }

      .popup-btn.success {
        background: #2ecc71;
      }

      .popup-btn.success:hover {
        background: #27ae60;
      }

      .popup-btn.danger {
        background: #e74c3c;
      }

      .popup-btn.danger:hover {
        background: #c0392b;
      }

      /* Bot√£o especial para baixar ZIP */
      .btn-zip {
        background: linear-gradient(45deg, #9b59b6, #8e44ad);
      }

      .btn-zip:hover {
        background: linear-gradient(45deg, #8e44ad, #7d3c98);
      }

      /* Estilos para o preview de imagem */
      .image-preview {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10000;
        background: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
        border: 2px solid rgba(255, 255, 255, 0.2);
        max-width: 90vw;
        max-height: 90vh;
        display: none;
        opacity: 0;
        transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        pointer-events: none;
      }

      .image-preview.show {
        display: block;
        opacity: 1;
        pointer-events: all;
        transform: translate(-50%, -50%) scale(1);
      }

      .image-preview.loading {
        display: block;
        opacity: 1;
        pointer-events: none;
      }

      .preview-header {
        color: white;
        margin-bottom: 15px;
        text-align: center;
        font-size: 18px;
        font-weight: 600;
        background: linear-gradient(45deg, #3498db, #2ecc71);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .preview-image {
        max-width: 100%;
        max-height: 60vh;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        display: block;
        margin: 0 auto;
      }

      .preview-info {
        color: rgba(255, 255, 255, 0.9);
        margin-top: 15px;
        text-align: center;
        font-size: 14px;
        line-height: 1.6;
      }

      .preview-coords {
        background: rgba(255, 255, 255, 0.1);
        padding: 10px;
        border-radius: 10px;
        margin-top: 10px;
        font-family: 'Courier New', monospace;
        font-size: 13px;
      }

      .preview-close {
        position: absolute;
        top: 15px;
        right: 20px;
        background: rgba(255, 255, 255, 0.2);
        border: none;
        border-radius: 50%;
        width: 35px;
        height: 35px;
        color: white;
        cursor: pointer;
        font-size: 18px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        backdrop-filter: blur(5px);
      }

      .preview-close:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: scale(1.1);
      }

      .preview-loading {
        text-align: center;
        color: white;
        padding: 40px;
        font-size: 16px;
      }

      .loading-spinner {
        display: inline-block;
        width: 30px;
        height: 30px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top: 3px solid #3498db;
        animation: spin 1s linear infinite;
        margin-bottom: 15px;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      /* Indicadores visuais nos marcadores */
      .leaflet-marker-icon {
        transition: all 0.3s ease;
      }

      .leaflet-marker-icon:hover {
        filter: brightness(1.2) drop-shadow(0 0 10px rgba(52, 152, 219, 0.6));
      }

      @media (max-width: 768px) {
        .main-container {
          padding: 1rem;
        }

        h1 {
          font-size: 1.8rem;
        }

        .container {
          padding: 1.5rem;
        }

        .map-header {
          padding: 1rem;
          flex-direction: column;
          align-items: stretch;
        }

        .map-controls {
          justify-content: center;
        }

        #dropZone {
          padding: 20px;
        }

        table {
          font-size: 14px;
        }

        th,
        td {
          padding: 8px;
        }

        #map {
          height: 50vh;
          min-height: 300px;
        }

        .leaflet-popup-content {
          width: 250px !important;
        }

        .image-preview {
          padding: 15px;
          max-width: 95vw;
          max-height: 95vh;
        }

        .preview-image {
          max-height: 50vh;
        }

        .preview-header {
          font-size: 16px;
        }
      }

      /* Anima√ß√µes */
      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(30px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .container:nth-child(1) {
        animation-delay: 0.1s;
      }
      .container:nth-child(2) {
        animation-delay: 0.2s;
      }
      .container:nth-child(3) {
        animation-delay: 0.3s;
      }

      /* Indicador de arquivo renomeado */
      .renamed-indicator {
        color: #2ecc71;
        font-weight: bold;
      }

      .original-name {
        color: #7f8c8d;
        font-style: italic;
        text-decoration: line-through;
      }
    </style>
  </head>
  <body>
    <!-- Preview de imagem -->
    <div id="imagePreview" class="image-preview">
      <button class="preview-close" onclick="closePreview()">&times;</button>
      <div class="preview-content">
        <div class="preview-loading">
          <div class="loading-spinner"></div>
          <div>Carregando imagem...</div>
        </div>
        <div class="preview-loaded" style="display: none;">
          <div class="preview-header" id="previewTitle"></div>
          <img class="preview-image" id="previewImg" alt="Preview da imagem">
          <div class="preview-info">
            <div id="previewInfo"></div>
            <div class="preview-coords" id="previewCoords"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="main-container">
      <div class="container">
        <h1>üì∑ Conversor de Imagens Georreferenciadas para GeoJSON</h1>

        <div class="note">
          <p>
            <strong>Nota:</strong> Este sistema extrai coordenadas GPS de fotos e
            gera um arquivo GeoJSON que pode ser importado no QGIS. Al√©m disso, voc√™ pode renomear as fotos diretamente no mapa e baixar um ZIP com os arquivos renomeados.
            <br><strong>‚ú® Novidade:</strong> Passe o mouse sobre os marcadores no mapa por 3 segundos para ver um preview da imagem!
          </p>
        </div>

        <div id="dropZone">
          <h3>üìÅ Arraste e solte imagens aqui</h3>
          <p>ou</p>
          <input
            type="file"
            id="fileInput"
            multiple
            accept="image/*"
            style="display: none"
          />
          <button onclick="document.getElementById('fileInput').click()">
            üìÇ Selecionar Imagens
          </button>
        </div>

        <div class="progress-bar" style="display: none">
          <div class="progress" style="width: 0%">0%</div>
        </div>

        <h2>üìç Pontos Extra√≠dos</h2>
        <div id="stats">
          <p>üìä Total de imagens: <span id="totalImages">0</span></p>
          <p>üó∫Ô∏è Imagens com geolocaliza√ß√£o: <span id="geoImages">0</span></p>
          <p>‚úèÔ∏è Imagens renomeadas: <span id="renamedImages">0</span></p>
        </div>

        <table id="resultsTable">
          <thead>
            <tr>
              <th>Nome do Arquivo</th>
              <th>Latitude</th>
              <th>Longitude</th>
              <th>Data/Hora</th>
            </tr>
          </thead>
          <tbody id="resultsBody">
            <!-- Resultados ser√£o adicionados aqui -->
          </tbody>
        </table>

        <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
          <button id="downloadBtn" disabled>üíæ Baixar GeoJSON</button>
          <button id="downloadCsvBtn" disabled>üìä Baixar CSV</button>
          <button id="downloadZipBtn" class="btn-zip" disabled>üì¶ Baixar ZIP com Fotos</button>
        </div>
      </div>
    </div>

    <div class="map-container">
      <div class="map-header">
        <h2>üó∫Ô∏è Mapa de Pontos</h2>
        <div class="map-controls">
          <select id="layerSelector">
            <option value="osm">OpenStreetMap</option>
            <option value="satellite">Sat√©lite (Esri)</option>
            <option value="topo">Topogr√°fico</option>
            <option value="dark">Modo Escuro</option>
          </select>
          <button id="maxZoomBtn">üîç Zoom M√°ximo</button>
        </div>
      </div>
      <div id="map"></div>
    </div>

    <div class="main-container">
      <footer class="footer">
        <p><span class="zenith-brand">ZenithSolutions</span> - OAE Support</p>
        <p>&copy; 2025 Ferramentas Topogr√°ficas Profissionais</p>
      </footer>
    </div>

    <script>
      // Vers√£o: 2.0
      
      // Vari√°veis globais
      let imagePoints = [];
      let originalFiles = new Map(); // Para armazenar os arquivos originais
      let imageDataMap = new Map(); // Para armazenar os dados das imagens (base64)
      let renamedFiles = new Map(); // Para armazenar os novos nomes
      let processedImages = 0;
      let imagesWithGeo = 0;
      let totalImages = 0;
      let map; // Vari√°vel para o mapa
      let markersLayer; // Camada para os marcadores
      let currentTileLayer; // Camada de tiles atual
      let previewTimeout; // Timeout para o preview
      let isPreviewOpen = false; // Controle do preview

      // Elementos DOM
      const dropZone = document.getElementById("dropZone");
      const fileInput = document.getElementById("fileInput");
      const resultsBody = document.getElementById("resultsBody");
      const downloadBtn = document.getElementById("downloadBtn");
      const downloadCsvBtn = document.getElementById("downloadCsvBtn");
      const downloadZipBtn = document.getElementById("downloadZipBtn");
      const progressBar = document.querySelector(".progress-bar");
      const progress = document.querySelector(".progress");
      const layerSelector = document.getElementById("layerSelector");
      const maxZoomBtn = document.getElementById("maxZoomBtn");
      const imagePreview = document.getElementById("imagePreview");

      // Definir diferentes camadas de tile com zoom m√°ximo aprimorado
      const tileLayers = {
        osm: {
          url: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
          options: {
            attribution: "¬© OpenStreetMap contributors",
            maxZoom: 19
          }
        },
        satellite: {
          url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
          options: {
            attribution: "¬© Esri, Maxar, GeoEye, Earthstar Geographics",
            maxZoom: 23
          }
        },
        topo: {
          url: "https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png",
          options: {
            attribution: "¬© OpenTopoMap (CC-BY-SA)",
            maxZoom: 17
          }
        },
        dark: {
          url: "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png",
          options: {
            attribution: "¬© CARTO, ¬© OpenStreetMap contributors",
            maxZoom: 20
          }
        }
      };

      // Inicializar o mapa
      function initMap() {
        // Criar o mapa centrado no Brasil com configura√ß√µes aprimoradas
        map = L.map("map", {
          maxZoom: 25, // Zoom m√°ximo global
          minZoom: 2,
          zoomControl: true,
          worldCopyJump: true
        }).setView([-15.7942, -47.8825], 4);

        // Adicionar camada inicial (OpenStreetMap)
        switchTileLayer('osm');

        // Criar camada para os marcadores
        markersLayer = L.layerGroup().addTo(map);

        // Event listener para mudan√ßa de camada
        layerSelector.addEventListener('change', function() {
          switchTileLayer(this.value);
        });

        // Event listener para zoom m√°ximo
        maxZoomBtn.addEventListener('click', function() {
          if (imagePoints.length > 0) {
            // Encontrar o centro dos pontos
            let latSum = 0, lngSum = 0;
            imagePoints.forEach(point => {
              latSum += point.latitude;
              lngSum += point.longitude;
            });
            const centerLat = latSum / imagePoints.length;
            const centerLng = lngSum / imagePoints.length;
            
            // Ir para o zoom m√°ximo no centro dos pontos
            map.setView([centerLat, centerLng], map.getMaxZoom());
          } else {
            // Se n√£o h√° pontos, fazer zoom m√°ximo na posi√ß√£o atual
            map.setZoom(map.getMaxZoom());
          }
        });

        // Se j√° temos pontos, plot√°-los
        if (imagePoints.length > 0) {
          plotPointsOnMap();
        }
      }

      // Trocar camada de tile
      function switchTileLayer(layerType) {
        // Remover camada atual se existir
        if (currentTileLayer) {
          map.removeLayer(currentTileLayer);
        }

        // Adicionar nova camada
        const layer = tileLayers[layerType];
        currentTileLayer = L.tileLayer(layer.url, layer.options).addTo(map);

        // Atualizar o zoom m√°ximo do mapa
        map.options.maxZoom = layer.options.maxZoom;
      }

      // Plotar pontos no mapa
      function plotPointsOnMap() {
        if (!map || !markersLayer) return;

        // Limpar marcadores existentes
        markersLayer.clearLayers();

        if (imagePoints.length === 0) return;

        // Adicionar marcadores para cada ponto
        let bounds = L.latLngBounds();

        imagePoints.forEach((point, index) => {
          const currentName = renamedFiles.get(point.filename) || point.filename;
          const isRenamed = renamedFiles.has(point.filename);
          
          const marker = L.marker([point.latitude, point.longitude]).bindPopup(
            createPopupContent(point, index, currentName, isRenamed)
          );

          // Adicionar eventos de preview da imagem
          marker.on('mouseover', function(e) {
            if (!isPreviewOpen) {
              previewTimeout = setTimeout(() => {
                showImagePreview(point, currentName, isRenamed);
              }, 3000); // 3 segundos
            }
          });

          marker.on('mouseout', function(e) {
            if (previewTimeout) {
              clearTimeout(previewTimeout);
              previewTimeout = null;
            }
          });

          markersLayer.addLayer(marker);
          bounds.extend([point.latitude, point.longitude]);
        });

        // Ajustar o zoom para mostrar todos os pontos
        if (imagePoints.length > 0) {
          map.fitBounds(bounds, { padding: [20, 20] });
        }
      }

      // Mostrar preview da imagem
      function showImagePreview(point, currentName, isRenamed) {
        if (isPreviewOpen) return;

        isPreviewOpen = true;
        
        // Mostrar o preview com loading
        imagePreview.classList.add('loading');
        imagePreview.style.display = 'block';
        
        // Resetar conte√∫do
        document.querySelector('.preview-loading').style.display = 'block';
        document.querySelector('.preview-loaded').style.display = 'none';

        // Carregar dados da imagem
        const imageData = imageDataMap.get(point.filename);
        if (imageData) {
          // Carregar imagem
          const img = document.getElementById('previewImg');
          img.onload = function() {
            // Atualizar informa√ß√µes
            document.getElementById('previewTitle').innerHTML = 
              `üì∑ ${isRenamed ? '<span class="renamed-indicator">‚úèÔ∏è ' + currentName + '</span>' : currentName}`;
            
            document.getElementById('previewInfo').innerHTML = 
              `${isRenamed ? `<div style="color: #7f8c8d; font-style: italic;">Original: ${point.filename}</div>` : ''}
               <div><strong>Data/Hora:</strong> ${point.datetime || "N/A"}</div>`;
            
            document.getElementById('previewCoords').innerHTML = 
              `<strong>Coordenadas:</strong><br>
               Latitude: ${point.latitude.toFixed(8)}<br>
               Longitude: ${point.longitude.toFixed(8)}`;

            // Mostrar conte√∫do carregado
            document.querySelector('.preview-loading').style.display = 'none';
            document.querySelector('.preview-loaded').style.display = 'block';
            
            // Remover classe loading e adicionar show
            imagePreview.classList.remove('loading');
            imagePreview.classList.add('show');
          };
          
          img.onerror = function() {
            closePreview();
          };
          
          img.src = imageData;
        } else {
          closePreview();
        }
      }

      // Fechar preview
      function closePreview() {
        if (previewTimeout) {
          clearTimeout(previewTimeout);
          previewTimeout = null;
        }
        
        isPreviewOpen = false;
        imagePreview.classList.remove('show', 'loading');
        
        // Esconder ap√≥s a anima√ß√£o
        setTimeout(() => {
          if (!imagePreview.classList.contains('show')) {
            imagePreview.style.display = 'none';
          }
        }, 400);
      }

      // Event listeners para fechar preview
      imagePreview.addEventListener('click', function(e) {
        if (e.target === this) {
          closePreview();
        }
      });

      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && isPreviewOpen) {
          closePreview();
        }
      });

      // Criar conte√∫do do popup com op√ß√£o de renomear
      function createPopupContent(point, index, currentName, isRenamed) {
        const fileNameWithoutExt = currentName.substring(0, currentName.lastIndexOf('.')) || currentName;
        const fileExt = currentName.substring(currentName.lastIndexOf('.')) || '';
        
        return `
          <h4>üì∑ ${isRenamed ? '<span class="renamed-indicator">‚úèÔ∏è ' + currentName + '</span>' : currentName}</h4>
          ${isRenamed ? `<p class="original-name">Original: ${point.filename}</p>` : ''}
          <p><strong>Coordenadas:</strong><br>
          Lat: ${point.latitude.toFixed(8)}<br>
          Lng: ${point.longitude.toFixed(8)}</p>
          <p><strong>Data/Hora:</strong><br>
          ${point.datetime || "N/A"}</p>
          
          <div class="rename-section">
            <p><strong>Renomear arquivo:</strong></p>
            <input type="text" id="newName_${index}" class="rename-input" 
                   value="${fileNameWithoutExt}" placeholder="Novo nome do arquivo">
            <div class="popup-buttons">
              <button class="popup-btn success" onclick="renameFile(${index}, '${point.filename}', '${fileExt}')">
                ‚úì Renomear
              </button>
              <button class="popup-btn" onclick="map.setView([${point.latitude}, ${point.longitude}], map.getMaxZoom())">
                üîç Zoom Max
              </button>
              ${isRenamed ? `<button class="popup-btn danger" onclick="resetFileName('${point.filename}', ${index})">‚Ü∂ Desfazer</button>` : ''}
            </div>
          </div>
        `;
      }

      // Fun√ß√£o para renomear arquivo
      function renameFile(index, originalFilename, fileExt) {
        const newNameInput = document.getElementById(`newName_${index}`);
        const newName = newNameInput.value.trim();
        
        if (!newName) {
          alert('Por favor, insira um nome v√°lido.');
          return;
        }
        
        const fullNewName = newName + fileExt;
        
        // Verificar se o nome j√° est√° sendo usado
        const existingNames = Array.from(renamedFiles.values());
        const originalNames = imagePoints.map(p => p.filename);
        
        if (existingNames.includes(fullNewName) || originalNames.includes(fullNewName)) {
          if (renamedFiles.get(originalFilename) !== fullNewName) {
            alert('Este nome j√° est√° sendo usado por outro arquivo.');
            return;
          }
        }
        
        // Salvar o novo nome
        renamedFiles.set(originalFilename, fullNewName);
        
        // Atualizar a tabela
        updateResultsTable();
        
        // Atualizar estat√≠sticas
        updateStats();
        
        // Replotar os pontos no mapa para atualizar os popups
        plotPointsOnMap();
        
        // Habilitar bot√£o de download ZIP
        downloadZipBtn.disabled = false;
        
        // Fechar o popup
        map.closePopup();
      }

      // Fun√ß√£o para resetar nome do arquivo
      function resetFileName(originalFilename, index) {
        renamedFiles.delete(originalFilename);
        
        // Atualizar a tabela
        updateResultsTable();
        
        // Atualizar estat√≠sticas
        updateStats();
        
        // Replotar os pontos no mapa
        plotPointsOnMap();
        
        // Desabilitar bot√£o ZIP se n√£o h√° arquivos renomeados
        if (renamedFiles.size === 0) {
          downloadZipBtn.disabled = true;
        }
        
        // Fechar o popup
        map.closePopup();
      }

      // Atualizar tabela de resultados
      function updateResultsTable() {
        resultsBody.innerHTML = "";
        
        imagePoints.forEach((point) => {
          const currentName = renamedFiles.get(point.filename) || point.filename;
          const isRenamed = renamedFiles.has(point.filename);
          
          const row = resultsBody.insertRow();
          
          const nameCell = row.insertCell(0);
          if (isRenamed) {
            nameCell.innerHTML = `<span class="renamed-indicator">${currentName}</span><br><small class="original-name">${point.filename}</small>`;
          } else {
            nameCell.textContent = currentName;
          }
          
          row.insertCell(1).textContent = point.latitude.toFixed(8);
          row.insertCell(2).textContent = point.longitude.toFixed(8);
          row.insertCell(3).textContent = point.datetime || "N/A";
        });
      }

      // Atualizar estat√≠sticas
      function updateStats() {
        document.getElementById("renamedImages").textContent = renamedFiles.size;
      }

      // Setup de eventos
      dropZone.addEventListener("dragover", (e) => {
        e.preventDefault();
        dropZone.style.backgroundColor = "rgba(52, 152, 219, 0.2)";
      });

      dropZone.addEventListener("dragleave", (e) => {
        e.preventDefault();
        dropZone.style.backgroundColor = "rgba(52, 152, 219, 0.1)";
      });

      dropZone.addEventListener("drop", (e) => {
        e.preventDefault();
        dropZone.style.backgroundColor = "rgba(52, 152, 219, 0.1)";
        handleFiles(e.dataTransfer.files);
      });

      fileInput.addEventListener("change", (e) => {
        handleFiles(e.target.files);
      });

      // Fun√ß√£o principal para processar os arquivos
      function handleFiles(files) {
        if (!files || files.length === 0) return;

        // Reset
        imagePoints = [];
        originalFiles.clear();
        imageDataMap.clear();
        renamedFiles.clear();
        processedImages = 0;
        imagesWithGeo = 0;
        totalImages = files.length;
        resultsBody.innerHTML = "";

        document.getElementById("totalImages").textContent = totalImages;
        document.getElementById("geoImages").textContent = "0";
        document.getElementById("renamedImages").textContent = "0";

        // Mostrar barra de progresso
        progressBar.style.display = "block";
        progress.style.width = "0%";
        progress.textContent = "0%";

        // Desabilitar bot√µes
        downloadBtn.disabled = true;
        downloadCsvBtn.disabled = true;
        downloadZipBtn.disabled = true;

        // Limpar o mapa
        if (markersLayer) {
          markersLayer.clearLayers();
        }

        // Fechar preview se estiver aberto
        closePreview();

        // Processar cada arquivo
        Array.from(files).forEach((file, index) => {
          if (!file.type.startsWith("image/")) {
            updateProgress();
            return;
          }

          // Armazenar o arquivo original
          originalFiles.set(file.name, file);

          const reader = new FileReader();
          reader.onload = function (e) {
            processImage(file, e.target.result);
          };
          reader.readAsDataURL(file);
        });
      }

      // Processa uma imagem individual
      function processImage(file, dataUrl) {
        const img = new Image();
        img.onload = function () {
          EXIF.getData(img, function () {
            let lat = null;
            let lng = null;
            let datetime = null;

            // Tentar obter coordenadas GPS
            if (EXIF.getTag(this, "GPSLatitude")) {
              lat = convertDMSToDD(
                EXIF.getTag(this, "GPSLatitude"),
                EXIF.getTag(this, "GPSLatitudeRef")
              );

              lng = convertDMSToDD(
                EXIF.getTag(this, "GPSLongitude"),
                EXIF.getTag(this, "GPSLongitudeRef")
              );

              // Tentar obter data/hora
              if (EXIF.getTag(this, "DateTimeOriginal")) {
                datetime = EXIF.getTag(this, "DateTimeOriginal");
              }

              // Se tivermos coordenadas v√°lidas, adicionar aos resultados
              if (isValidCoordinate(lat, lng)) {
                imagesWithGeo++;
                document.getElementById("geoImages").textContent = imagesWithGeo;

                // Armazenar dados da imagem (redimensionada para melhor performance)
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Calcular dimens√µes para redimensionar (m√°ximo 800px na maior dimens√£o)
                const maxSize = 800;
                let { width, height } = img;
                
                if (width > height && width > maxSize) {
                  height = (height * maxSize) / width;
                  width = maxSize;
                } else if (height > maxSize) {
                  width = (width * maxSize) / height;
                  height = maxSize;
                }
                
                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(img, 0, 0, width, height);
                
                // Armazenar a imagem redimensionada
                imageDataMap.set(file.name, canvas.toDataURL('image/jpeg', 0.85));

                // Adicionar ao array de pontos
                imagePoints.push({
                  filename: file.name,
                  latitude: lat,
                  longitude: lng,
                  datetime: datetime,
                });

                // Adicionar √† tabela
                const row = resultsBody.insertRow();
                row.insertCell(0).textContent = file.name;
                row.insertCell(1).textContent = lat.toFixed(8);
                row.insertCell(2).textContent = lng.toFixed(8);
                row.insertCell(3).textContent = datetime || "N/A";
              }
            }

            updateProgress();
          });
        };
        img.src = dataUrl;
      }

      // Atualiza o progresso
      function updateProgress() {
        processedImages++;
        const percentage = Math.round((processedImages / totalImages) * 100);
        progress.style.width = percentage + "%";
        progress.textContent = percentage + "%";

        // Verificar se terminou
        if (processedImages === totalImages) {
          if (imagePoints.length > 0) {
            downloadBtn.disabled = false;
            downloadCsvBtn.disabled = false;
            // Plotar pontos no mapa
            plotPointsOnMap();
          }
        }
      }

      // Converter coordenadas DMS para Decimal Degrees com m√°xima precis√£o
      function convertDMSToDD(dms, ref) {
        if (!dms || dms.length !== 3) return null;

        // Usar c√°lculos de alta precis√£o para convers√£o
        let dd = Number(dms[0]) + Number(dms[1]) / 60 + Number(dms[2]) / 3600;

        // Se ref for sul ou oeste, a coordenada √© negativa
        if (ref === "S" || ref === "W") {
          dd = -dd;
        }

        return dd;
      }

      // Verifica se as coordenadas s√£o v√°lidas
      function isValidCoordinate(lat, lng) {
        return (
          lat !== null &&
          lng !== null &&
          !isNaN(lat) &&
          !isNaN(lng) &&
          lat >= -90 &&
          lat <= 90 &&
          lng >= -180 &&
          lng <= 180
        );
      }

      // Gera e faz download do GeoJSON
      downloadBtn.addEventListener("click", () => {
        if (imagePoints.length === 0) return;

        const geojson = {
          type: "FeatureCollection",
          features: imagePoints.map((point) => ({
            type: "Feature",
            properties: {
              filename: renamedFiles.get(point.filename) || point.filename,
              original_filename: point.filename,
              datetime: point.datetime,
              renamed: renamedFiles.has(point.filename)
            },
            geometry: {
              type: "Point",
              coordinates: [point.longitude, point.latitude],
            },
          })),
        };

        const dataStr =
          "data:text/json;charset=utf-8," +
          encodeURIComponent(JSON.stringify(geojson));
        const downloadAnchor = document.createElement("a");
        downloadAnchor.setAttribute("href", dataStr);
        downloadAnchor.setAttribute("download", "pontos_fotos.geojson");
        document.body.appendChild(downloadAnchor);
        downloadAnchor.click();
        downloadAnchor.remove();
      });

      // Gera e faz download do CSV
      downloadCsvBtn.addEventListener("click", () => {
        if (imagePoints.length === 0) return;

        let csvContent = "Nome do Arquivo,Nome Original,Latitude,Longitude,Data/Hora,Renomeado\n";

        imagePoints.forEach((point) => {
          const currentName = renamedFiles.get(point.filename) || point.filename;
          const isRenamed = renamedFiles.has(point.filename);
          
          csvContent += `"${currentName}","${point.filename}",${String(point.latitude)},${String(
            point.longitude
          )},"${point.datetime || ""}","${isRenamed ? 'Sim' : 'N√£o'}"\n`;
        });

        const dataStr =
          "data:text/csv;charset=utf-8," + encodeURIComponent(csvContent);
        const downloadAnchor = document.createElement("a");
        downloadAnchor.setAttribute("href", dataStr);
        downloadAnchor.setAttribute("download", "pontos_fotos.csv");
        document.body.appendChild(downloadAnchor);
        downloadAnchor.click();
        downloadAnchor.remove();
      });

      // Fun√ß√£o para carregar JSZip dinamicamente
      function loadJSZip(callback) {
        // Verificar se JSZip j√° est√° carregado
        if (window.JSZip) {
          callback();
          return;
        }

        // Criar script para carregar JSZip
        const script = document.createElement("script");
        script.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
        script.onload = callback;
        script.onerror = () => {
          alert("Erro ao carregar JSZip. Verifique sua conex√£o com a internet.");
        };

        // Adicionar o script √† p√°gina
        document.head.appendChild(script);
      }

      // Gera e faz download do ZIP com fotos renomeadas
      downloadZipBtn.addEventListener("click", () => {
        if (imagePoints.length === 0) return;

        loadJSZip(() => {
          const zip = new JSZip();
          let promises = [];

          imagePoints.forEach((point) => {
            const originalFile = originalFiles.get(point.filename);
            if (originalFile) {
              const currentName = renamedFiles.get(point.filename) || point.filename;
              
              const promise = new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                  zip.file(currentName, e.target.result);
                  resolve();
                };
                reader.onerror = reject;
                reader.readAsArrayBuffer(originalFile);
              });
              
              promises.push(promise);
            }
          });

          Promise.all(promises)
            .then(() => {
              return zip.generateAsync({ type: "blob" });
            })
            .then((blob) => {
              const link = document.createElement("a");
              link.href = URL.createObjectURL(blob);
              link.download = "fotos_georreferenciadas.zip";
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
            })
            .catch((error) => {
              alert("Erro ao criar o ZIP: " + error.message);
            });
        });
      });

      // Inicializar o mapa quando a p√°gina carregar
      document.addEventListener("DOMContentLoaded", function () {
        initMap();
      });
    </script>
  </body>
</html>