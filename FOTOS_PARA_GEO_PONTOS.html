<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <!-- Vers√£o: 4.3 -->
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
      Conversor de Imagens Georreferenciadas para KML/KMZ - OAE Support
    </title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exif-js/2.3.0/exif.min.js"></script>

    <!-- Leaflet CSS e JS -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #2c3e50 0%, #34495e 50%, #2c3e50 100%);
        min-height: 100vh;
        color: #ffffff;
        overflow-x: hidden;
      }

      .main-container {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
      }

      .map-container {
        width: 100vw;
        margin-left: calc(-50vw + 50%);
        padding: 0;
        background: rgba(255, 255, 255, 0.05);
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .map-header {
        max-width: 800px;
        margin: 0 auto;
        padding: 2rem 2rem 1rem 2rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 1rem;
      }

      .map-controls {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }

      .map-controls select {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        color: white;
        padding: 8px 12px;
        font-size: 14px;
        backdrop-filter: blur(5px);
      }

      .map-controls select option {
        background: #2c3e50;
        color: white;
      }

      h1, h2 {
        color: #ffffff;
        font-weight: 700;
        margin-bottom: 1rem;
        background: linear-gradient(45deg, #ffffff, #e3f2fd);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      }

      h1 {
        font-size: 2.2rem;
        text-align: center;
        margin-bottom: 2rem;
      }

      h2 {
        font-size: 1.5rem;
      }

      .container {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 20px;
        padding: 2rem;
        margin-bottom: 2rem;
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
      }

      .container:hover {
        transform: translateY(-5px);
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        border-color: rgba(255, 255, 255, 0.4);
      }

      #dropZone {
        border: 2px dashed #3498db;
        border-radius: 15px;
        padding: 30px;
        text-align: center;
        margin: 20px 0;
        cursor: pointer;
        background: rgba(52, 152, 219, 0.1);
        transition: all 0.3s ease;
        backdrop-filter: blur(5px);
      }

      #dropZone:hover {
        background: rgba(52, 152, 219, 0.2);
        border-color: #64b5f6;
        transform: translateY(-2px);
      }

      #dropZone h3 {
        color: #64b5f6;
        margin-bottom: 1rem;
      }

      button {
        background: linear-gradient(45deg, #3498db, #2ecc71);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 15px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 600;
        margin: 10px 5px;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        background: linear-gradient(45deg, #2980b9, #27ae60);
      }

      button:disabled {
        background: linear-gradient(45deg, #95a5a6, #7f8c8d);
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      .btn-kmz {
        background: linear-gradient(45deg, #e74c3c, #c0392b);
      }

      .btn-kmz:hover {
        background: linear-gradient(45deg, #c0392b, #a93226);
      }

      .btn-zip {
        background: linear-gradient(45deg, #9b59b6, #8e44ad);
      }

      .btn-zip:hover {
        background: linear-gradient(45deg, #8e44ad, #7d3c98);
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        overflow: hidden;
        backdrop-filter: blur(5px);
      }

      th, td {
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: 12px;
        text-align: left;
      }

      th {
        background: rgba(52, 152, 219, 0.3);
        font-weight: 600;
        color: #ffffff;
      }

      td {
        background: rgba(255, 255, 255, 0.05);
      }

      tbody tr:hover td {
        background: rgba(255, 255, 255, 0.1);
      }

      #map {
        height: 70vh;
        min-height: 500px;
        width: 100%;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(5px);
        z-index: 1;
        position: relative;
      }

      .progress-bar {
        width: 100%;
        background: rgba(255, 255, 255, 0.2);
        padding: 3px;
        border-radius: 15px;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
        margin: 20px 0;
        backdrop-filter: blur(5px);
      }

      .progress {
        background: linear-gradient(45deg, #3498db, #2ecc71);
        height: 20px;
        border-radius: 12px;
        transition: width 0.3s ease;
        text-align: center;
        line-height: 20px;
        color: white;
        font-weight: 600;
      }

      .note {
        background: rgba(255, 235, 59, 0.2);
        padding: 15px;
        border-left: 4px solid #ffd600;
        margin: 15px 0;
        border-radius: 10px;
        backdrop-filter: blur(5px);
      }

      #stats {
        background: rgba(255, 255, 255, 0.1);
        padding: 15px;
        border-radius: 15px;
        margin: 20px 0;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      #stats p {
        margin: 5px 0;
        font-weight: 500;
      }

      #stats span {
        color: #64b5f6;
        font-weight: 700;
      }

      .footer {
        text-align: center;
        padding: 2rem 0;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        margin-top: 3rem;
        background: rgba(44, 62, 80, 0.3);
        border-radius: 15px 15px 0 0;
      }

      .footer p {
        opacity: 0.9;
        font-size: 0.95rem;
        margin-bottom: 0.5rem;
      }

      .zenith-brand {
        font-weight: 600;
        background: linear-gradient(45deg, #3498db, #2ecc71);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        font-size: 1.1rem;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      /* Indicador de arquivo renomeado */
      .renamed-indicator {
        color: #2ecc71;
        font-weight: bold;
      }

      .original-name {
        color: #7f8c8d;
        font-style: italic;
        text-decoration: line-through;
      }

      .drone-toggle {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        padding: 8px 12px;
        color: white;
        cursor: pointer;
        font-size: 14px;
        backdrop-filter: blur(5px);
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .drone-toggle:hover {
        background: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.5);
      }

      .drone-toggle.active {
        background: linear-gradient(45deg, #e74c3c, #c0392b);
        border-color: #e74c3c;
        box-shadow: 0 0 10px rgba(231, 76, 60, 0.3);
      }

      .drone-icon {
        font-size: 16px;
      }

      /* Legenda das zonas de drone */
      .drone-legend {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 10px;
        padding: 15px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        z-index: 1000;
        min-width: 200px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        display: none;
      }

      .drone-legend.active {
        display: block;
      }

      .drone-legend h4 {
        color: #2c3e50;
        margin-bottom: 10px;
        font-size: 14px;
        font-weight: 600;
      }

      .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
        font-size: 12px;
        color: #333;
      }

      .legend-color {
        width: 20px;
        height: 15px;
        border-radius: 3px;
        margin-right: 8px;
        border: 1px solid rgba(0, 0, 0, 0.2);
      }

      .legend-color.prohibited {
        background: rgba(231, 76, 60, 0.7);
      }

      .legend-color.restricted {
        background: rgba(241, 196, 15, 0.7);
      }

      .legend-color.permitted {
        background: rgba(46, 204, 113, 0.7);
      }

      .legend-color.airport {
        background: rgba(155, 89, 182, 0.7);
      }

      /* Loading para zonas de drone */
      .drone-loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 20px;
        border-radius: 10px;
        z-index: 10000;
        text-align: center;
        backdrop-filter: blur(5px);
        display: none;
      }

      .drone-loading.active {
        display: block;
      }

      /* Estilos para o preview de imagem */
      .image-preview {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10000;
        background: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
        border: 2px solid rgba(255, 255, 255, 0.2);
        max-width: 90vw;
        max-height: 90vh;
        display: none;
        opacity: 0;
        transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        pointer-events: none;
      }

      .image-preview.show {
        display: block;
        opacity: 1;
        pointer-events: all;
        transform: translate(-50%, -50%) scale(1);
      }

      .image-preview.loading {
        display: block;
        opacity: 1;
        pointer-events: none;
      }

      .preview-header {
        color: white;
        margin-bottom: 15px;
        text-align: center;
        font-size: 18px;
        font-weight: 600;
        background: linear-gradient(45deg, #3498db, #2ecc71);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .preview-image {
        max-width: 100%;
        max-height: 60vh;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        display: block;
        margin: 0 auto;
      }

      .preview-info {
        color: rgba(255, 255, 255, 0.9);
        margin-top: 15px;
        text-align: center;
        font-size: 14px;
        line-height: 1.6;
      }

      .preview-coords {
        background: rgba(255, 255, 255, 0.1);
        padding: 10px;
        border-radius: 10px;
        margin-top: 10px;
        font-family: 'Courier New', monospace;
        font-size: 13px;
      }

      .preview-close {
        position: absolute;
        top: 15px;
        right: 20px;
        background: rgba(255, 255, 255, 0.2);
        border: none;
        border-radius: 50%;
        width: 35px;
        height: 35px;
        color: white;
        cursor: pointer;
        font-size: 18px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        backdrop-filter: blur(5px);
      }

      .preview-close:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: scale(1.1);
      }

      .preview-loading {
        text-align: center;
        color: white;
        padding: 40px;
        font-size: 16px;
      }

      .loading-spinner {
        display: inline-block;
        width: 30px;
        height: 30px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top: 3px solid #3498db;
        animation: spin 1s linear infinite;
        margin-bottom: 15px;
      }

      /* Customiza√ß√£o adicional do popup */
      .leaflet-popup-content {
        color: #333;
        font-size: 14px;
        width: 320px !important;
        max-height: 500px;
        overflow-y: auto;
      }

      .leaflet-popup-content h4 {
        margin: 0 0 10px 0;
        color: #2c3e50;
      }

      /* Estilos para os campos de renomea√ß√£o no popup */
      .rename-section {
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px solid #ddd;
      }

      .rename-input {
        width: 100%;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 5px;
        font-size: 14px;
        margin-bottom: 10px;
        font-family: inherit;
      }

      .rename-input:focus {
        outline: none;
        border-color: #3498db;
        box-shadow: 0 0 5px rgba(52, 152, 219, 0.3);
      }

      .popup-buttons {
        display: flex;
        gap: 5px;
        flex-wrap: wrap;
      }

      .popup-btn {
        background: #3498db;
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 12px;
        font-weight: 500;
        transition: background 0.3s ease;
        flex: 1;
        min-width: 80px;
      }

      .popup-btn:hover {
        background: #2980b9;
        transform: none;
        box-shadow: none;
      }

      .popup-btn.success {
        background: #2ecc71;
      }

      .popup-btn.success:hover {
        background: #27ae60;
      }

      .popup-btn.danger {
        background: #e74c3c;
      }

      .popup-btn.danger:hover {
        background: #c0392b;
      }

      /* Indicadores visuais nos marcadores */
      .leaflet-marker-icon {
        transition: all 0.3s ease;
      }

      .leaflet-marker-icon:hover {
        filter: brightness(1.2) drop-shadow(0 0 10px rgba(52, 152, 219, 0.6));
      }
    </style>
  </head>
  <body>
    <!-- Preview de imagem -->
    <div id="imagePreview" class="image-preview">
      <button class="preview-close" onclick="closePreview()">&times;</button>
      <div class="preview-content">
        <div class="preview-loading">
          <div class="loading-spinner"></div>
          <div>Carregando imagem...</div>
        </div>
        <div class="preview-loaded" style="display: none;">
          <div class="preview-header" id="previewTitle"></div>
          <img class="preview-image" id="previewImg" alt="Preview da imagem">
          <div class="preview-info">
            <div id="previewInfo"></div>
            <div class="preview-coords" id="previewCoords"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Loading para zonas de drone -->
    <div id="droneLoading" class="drone-loading">
      <div class="loading-spinner"></div>
      <div>Carregando zonas de drone...</div>
    </div>

    <div class="main-container">
      <div class="container">
        <h1>Conversor de Imagens Georreferenciadas para KML/KMZ</h1>

        <div class="note">
          <p>
            <strong>Nota:</strong> Este sistema extrai coordenadas GPS de fotos e
            gera arquivos KML/KMZ compat√≠veis com Google Earth, QGIS e outros softwares GIS. Al√©m disso, voc√™ pode renomear as fotos diretamente no mapa e baixar um ZIP com os arquivos renomeados.
            <br><strong>‚ú® Novidade:</strong> Passe o mouse sobre os marcadores no mapa por 2 segundos para ver um preview da imagem!
            <br><strong>üõ£Ô∏è Integra√ß√£o DNIT:</strong> Clique nos marcadores para ver informa√ß√µes das rodovias pr√≥ximas automaticamente!
            <br><strong>üöÅ Zonas de Drone:</strong> Ative o toggle "Zonas de Drone" no mapa para visualizar √°reas permitidas e restritas para voo de drones!
            <br><strong>üìÇ Importa√ß√£o KML:</strong> Importe arquivos KML existentes para combinar com suas fotos georreferenciadas!
            <br><strong>üóúÔ∏è Exporta√ß√£o KMZ:</strong> Baixe um arquivo KMZ com as imagens embutidas para melhor experi√™ncia no Google Earth!
          </p>
        </div>

        <div id="dropZone">
          <h3>Arraste e solte imagens aqui</h3>
          <p>ou</p>
          <input
            type="file"
            id="fileInput"
            multiple
            accept="image/*"
            style="display: none"
          />
          <button onclick="document.getElementById('fileInput').click()">
            Selecionar Imagens
          </button>
          <button onclick="importKMLFile()" style="background: linear-gradient(45deg, #9b59b6, #8e44ad);">
            Importar KML
          </button>
        </div>

        <div class="progress-bar" id="progressBar" style="display: none">
          <div class="progress" id="progress" style="width: 0%">0%</div>
        </div>

        <h2>Pontos Extra√≠dos</h2>
        <div id="stats">
          <p>Total de imagens: <span id="totalImages">0</span></p>
          <p>Imagens com geolocaliza√ß√£o: <span id="geoImages">0</span></p>
          <p>Pontos importados do KML: <span id="importedPoints">0</span></p>
          <p>Imagens renomeadas: <span id="renamedImages">0</span></p>
        </div>

        <table id="resultsTable">
          <thead>
            <tr>
              <th>Nome do Arquivo</th>
              <th>Latitude</th>
              <th>Longitude</th>
              <th>Data/Hora</th>
            </tr>
          </thead>
          <tbody id="resultsBody">
            <!-- Resultados ser√£o adicionados aqui -->
          </tbody>
        </table>

        <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
          <button id="downloadKmlBtn" disabled>Baixar KML</button>
          <button id="downloadKmzBtn" class="btn-kmz" disabled>Baixar KMZ</button>
          <button id="downloadCsvBtn" disabled>Baixar CSV</button>
          <button id="downloadZipBtn" class="btn-zip" disabled>Baixar ZIP com Fotos</button>
        </div>
      </div>
    </div>

    <div class="map-container">
      <div class="map-header">
        <h2>Mapa de Pontos</h2>
        <div class="map-controls">
          <select id="layerSelector">
            <option value="osm">OpenStreetMap</option>
            <option value="satellite">Sat√©lite (Esri)</option>
            <option value="topo">Topogr√°fico</option>
            <option value="dark">Modo Escuro</option>
          </select>
          <div class="drone-toggle" id="droneToggle">
            <span class="drone-icon">üöÅ</span>
            <span>Zonas de Drone</span>
          </div>
          <button id="maxZoomBtn">Zoom M√°ximo</button>
        </div>
      </div>
      <div id="map">
        <!-- Legenda das zonas de drone -->
        <div class="drone-legend" id="droneLegend">
          <h4>üöÅ Zonas de Drone</h4>
          <div class="legend-item">
            <div class="legend-color prohibited"></div>
            <span>Proibido (0-5km aeroportos)</span>
          </div>
          <div class="legend-item">
            <div class="legend-color restricted"></div>
            <span>Restrito (5-10km aeroportos)</span>
          </div>
          <div class="legend-item">
            <div class="legend-color airport"></div>
            <span>Aeroportos/Helipontos</span>
          </div>
          <div class="legend-item">
            <div class="legend-color permitted"></div>
            <span>Permitido (√°reas rurais)</span>
          </div>
        </div>
      </div>
    </div>

    <div class="main-container">
      <footer class="footer">
        <p><span class="zenith-brand">ZenithSolutions</span> - OAE Support</p>
        <p>&copy; 2025 Ferramentas Topogr√°ficas Profissionais</p>
      </footer>
    </div>

    <script>
      // Vers√£o: 4.3
      
      // Vari√°veis globais
      let imagePoints = [];
      let importedPoints = [];
      let originalFiles = new Map();
      let imageDataMap = new Map();
      let renamedFiles = new Map();
      let processedImages = 0;
      let imagesWithGeo = 0;
      let totalImages = 0;
      let importedCount = 0;
      let map;
      let markersLayer;
      let droneZonesLayer;
      let currentTileLayer;
      let previewTimeout;
      let isPreviewOpen = false;
      let rodoviaCache = new Map();
      let droneZonesActive = false;
      let droneDataCache = new Map();
      let airportCache = new Map();

      // Elementos DOM
      const dropZone = document.getElementById("dropZone");
      const fileInput = document.getElementById("fileInput");
      const resultsBody = document.getElementById("resultsBody");
      const downloadKmlBtn = document.getElementById("downloadKmlBtn");
      const downloadKmzBtn = document.getElementById("downloadKmzBtn");
      const downloadCsvBtn = document.getElementById("downloadCsvBtn");
      const downloadZipBtn = document.getElementById("downloadZipBtn");
      const progressBar = document.getElementById("progressBar");
      const progress = document.getElementById("progress");
      const layerSelector = document.getElementById("layerSelector");
      const maxZoomBtn = document.getElementById("maxZoomBtn");
      const droneToggle = document.getElementById("droneToggle");
      const droneLegend = document.getElementById("droneLegend");
      const droneLoading = document.getElementById("droneLoading");
      const imagePreview = document.getElementById("imagePreview");

      // Fun√ß√£o de debug - apenas console
      function debugLog(message) {
        console.log(message);
      }

      // FUN√á√ÉO PARA IMPORTAR KML
      window.importKMLFile = function() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.kml';
        input.style.display = 'none';
        document.body.appendChild(input);
        
        input.addEventListener('change', function(e) {
          const file = e.target.files[0];
          if (!file) {
            document.body.removeChild(input);
            return;
          }
          
          if (!file.name.toLowerCase().endsWith('.kml')) {
            alert('Por favor, selecione um arquivo KML v√°lido.');
            document.body.removeChild(input);
            return;
          }
          
          const reader = new FileReader();
          reader.onload = function(event) {
            try {
              const kmlContent = event.target.result;
              const points = parseKML(kmlContent);
              
              if (points.length > 0) {
                importedPoints.push(...points);
                importedCount = importedPoints.length;
                
                document.getElementById("importedPoints").textContent = importedCount;
                updateResultsTable();
                
                if (imagePoints.length + importedPoints.length > 0) {
                  downloadKmlBtn.disabled = false;
                  downloadCsvBtn.disabled = false;
                }
                
                plotPointsOnMap();
                alert(`Sucesso! ${points.length} pontos importados do KML.`);
              } else {
                alert('Nenhum ponto v√°lido encontrado no arquivo KML.');
              }
            } catch (error) {
              console.error('Erro:', error);
              alert('Erro ao processar arquivo KML: ' + error.message);
            }
            
            document.body.removeChild(input);
          };
          
          reader.onerror = function() {
            alert('Erro ao ler o arquivo.');
            document.body.removeChild(input);
          };
          
          reader.readAsText(file);
        });
        
        input.click();
      };

      // Fun√ß√£o para parsear arquivo KML
      function parseKML(kmlContent) {
        try {
          debugLog('Iniciando parse do KML');
          const parser = new DOMParser();
          const kmlDoc = parser.parseFromString(kmlContent, "text/xml");
          
          const parseError = kmlDoc.getElementsByTagName("parsererror");
          if (parseError.length > 0) {
            throw new Error("XML inv√°lido");
          }
          
          const placemarks = kmlDoc.getElementsByTagName("Placemark");
          debugLog(`Placemarks encontrados: ${placemarks.length}`);
          const points = [];
          
          for (let i = 0; i < placemarks.length; i++) {
            const placemark = placemarks[i];
            const nameElement = placemark.getElementsByTagName("name")[0];
            
            let coordinatesElement = null;
            const pointElement = placemark.getElementsByTagName("Point")[0];
            
            if (pointElement) {
              coordinatesElement = pointElement.getElementsByTagName("coordinates")[0];
            }
            
            if (coordinatesElement) {
              const coordsText = coordinatesElement.textContent.trim();
              const coordPairs = coordsText.split(/[\s\n]+/).filter(pair => pair.trim());
              const firstCoordPair = coordPairs[0];
              
              if (firstCoordPair) {
                const coords = firstCoordPair.split(',');
                
                if (coords.length >= 2) {
                  const lng = parseFloat(coords[0]);
                  const lat = parseFloat(coords[1]);
                  
                  if (isValidCoordinate(lat, lng)) {
                    const name = nameElement ? nameElement.textContent.trim() : `Ponto_Importado_${i + 1}`;
                    
                    const point = {
                      filename: name,
                      latitude: lat,
                      longitude: lng,
                      datetime: null,
                      imported: true,
                      description: ''
                    };
                    
                    points.push(point);
                  }
                }
              }
            }
          }
          
          debugLog(`Total de pontos parseados: ${points.length}`);
          return points;
        } catch (error) {
          debugLog(`Erro ao parsear KML: ${error.message}`);
          throw error;
        }
      }

      // Fun√ß√£o para gerar arquivo KML
      function generateKML(forKMZ = false) {
        const allPoints = [...imagePoints, ...importedPoints];
        
        if (allPoints.length === 0) return null;
        
        let kmlContent = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>Pontos Georreferenciados</name>
    <description>Arquivo KML gerado pelo Conversor de Imagens Georreferenciadas - ZenithSolutions OAE Support</description>
`;

        allPoints.forEach((point, index) => {
          const currentName = renamedFiles.get(point.filename) || point.filename;
          const isRenamed = renamedFiles.has(point.filename);
          const isImported = point.imported || false;
          
          // Construir descri√ß√£o detalhada
          let description = `<![CDATA[
<h3>${currentName}</h3>
<p><strong>Coordenadas:</strong><br/>
Latitude: ${point.latitude.toFixed(8)}<br/>
Longitude: ${point.longitude.toFixed(8)}</p>
`;

          if (point.datetime) {
            description += `<p><strong>Data/Hora:</strong> ${point.datetime}</p>`;
          }
          
          // Para KMZ, incluir refer√™ncia √† imagem se dispon√≠vel
          if (forKMZ && !isImported && imageDataMap.has(point.filename)) {
            const imageFilename = (renamedFiles.get(point.filename) || point.filename).replace(/\.[^/.]+$/, ".jpg");
            description += `
<p><strong>Imagem:</strong></p>
<img src="images/${imageFilename}" width="300" alt="${currentName}"/>`;
          }
          
          if (isRenamed && !isImported) {
            description += `<p><strong>Nome Original:</strong> ${point.filename}</p>`;
            description += `<p><strong>Status:</strong> Arquivo renomeado</p>`;
          }
          
          if (isImported) {
            description += `<p><strong>Tipo:</strong> Ponto importado de KML</p>`;
          } else {
            description += `<p><strong>Tipo:</strong> Extra√≠do de imagem georreferenciada</p>`;
          }
          
          description += `]]>`;
          
          kmlContent += `
    <Placemark>
      <name>${escapeXml(currentName)}</name>
      <description>${description}</description>
      <Point>
        <coordinates>${point.longitude},${point.latitude},0</coordinates>
      </Point>
    </Placemark>`;
        });
        
        kmlContent += `
  </Document>
</kml>`;
        
        return kmlContent;
      }

      // Nova fun√ß√£o para gerar arquivo KMZ
      async function generateKMZ() {
        if (imagePoints.length === 0) {
          alert('Nenhuma imagem georreferenciada dispon√≠vel para KMZ.');
          return;
        }

        try {
          debugLog('Iniciando gera√ß√£o do KMZ');
          
          // Carregar JSZip se necess√°rio
          await new Promise((resolve, reject) => {
            if (window.JSZip) {
              resolve();
              return;
            }

            const script = document.createElement("script");
            script.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
            script.onload = resolve;
            script.onerror = () => reject(new Error("Erro ao carregar JSZip"));
            document.head.appendChild(script);
          });

          const zip = new JSZip();
          
          // Gerar KML espec√≠fico para KMZ
          const kmlContent = generateKML(true);
          zip.file("doc.kml", kmlContent);
          
          // Criar pasta de imagens
          const imagesFolder = zip.folder("images");
          
          // Adicionar cada imagem ao ZIP
          const imagePromises = imagePoints.map(async (point) => {
            if (imageDataMap.has(point.filename)) {
              const imageData = imageDataMap.get(point.filename);
              const currentName = renamedFiles.get(point.filename) || point.filename;
              
              // Converter nome para .jpg
              const imageFilename = currentName.replace(/\.[^/.]+$/, ".jpg");
              
              // Converter data URL para blob
              const response = await fetch(imageData);
              const blob = await response.blob();
              const arrayBuffer = await blob.arrayBuffer();
              
              imagesFolder.file(imageFilename, arrayBuffer);
              debugLog(`Adicionada imagem: ${imageFilename}`);
            }
          });
          
          await Promise.all(imagePromises);
          
          // Gerar o arquivo KMZ
          const kmzBlob = await zip.generateAsync({ type: "blob" });
          
          // Download
          const link = document.createElement("a");
          link.href = URL.createObjectURL(kmzBlob);
          link.download = "pontos_georreferenciados.kmz";
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          
          debugLog('KMZ gerado com sucesso');
          
        } catch (error) {
          debugLog(`Erro ao gerar KMZ: ${error.message}`);
          alert('Erro ao gerar arquivo KMZ: ' + error.message);
        }
      }

      // Fun√ß√£o para escapar caracteres especiais XML
      function escapeXml(text) {
        return text.replace(/[<>&'"]/g, function(match) {
          switch (match) {
            case '<': return '&lt;';
            case '>': return '&gt;';
            case '&': return '&amp;';
            case "'": return '&apos;';
            case '"': return '&quot;';
            default: return match;
          }
        });
      }

      // Fun√ß√£o para combinar pontos importados com pontos das imagens
      function combineAllPoints() {
        return [...imagePoints, ...importedPoints];
      }

      // Consulta rodovias DNIT
      async function consultarRodoviasDNIT(lat, lng) {
        try {
          const dataRef = new Date().toISOString().split('T')[0];
          const url = `https://servicos.dnit.gov.br/sgplan/apigeo/rotas/localizarkm?lng=${lng}&lat=${lat}&r=250&data=${dataRef}`;
          
          const response = await fetch(url, {
            method: 'GET',
            headers: {
              'Accept': 'application/json',
            },
            mode: 'cors'
          });
          
          if (!response.ok) {
            throw new Error(`Erro na API DNIT: ${response.status}`);
          }
          
          const data = await response.json();
          return data;
        } catch (error) {
          console.error(`Erro ao consultar DNIT: ${error.message}`);
          return null;
        }
      }

      // Consulta aeroportos via Overpass API
      async function consultarAeroportosOverpass(bbox) {
        const query = `
          [out:json][timeout:30];
          (
            node["aeroway"="aerodrome"](${bbox});
            node["aeroway"="helipad"](${bbox});
            node["aeroway"="heliport"](${bbox});
            way["aeroway"="aerodrome"](${bbox});
            relation["aeroway"="aerodrome"](${bbox});
          );
          out center;
        `;

        try {
          const response = await fetch('https://overpass-api.de/api/interpreter', {
            method: 'POST',
            body: query,
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded'
            }
          });

          if (!response.ok) {
            throw new Error(`Erro na API Overpass: ${response.status}`);
          }

          const data = await response.json();
          return processarAeroportos(data.elements);
        } catch (error) {
          console.error('Erro ao consultar aeroportos:', error);
          return [];
        }
      }

      // Processar dados de aeroportos
      function processarAeroportos(elements) {
        const aeroportos = [];
        
        elements.forEach(element => {
          let lat, lng, name, type;
          
          if (element.type === 'node') {
            lat = element.lat;
            lng = element.lon;
          } else if (element.center) {
            lat = element.center.lat;
            lng = element.center.lon;
          } else {
            return;
          }

          name = element.tags?.name || element.tags?.ref || 'Sem nome';
          type = element.tags?.aeroway || 'aerodrome';
          
          aeroportos.push({
            lat,
            lng,
            name,
            type,
            icao: element.tags?.icao || '',
            iata: element.tags?.iata || ''
          });
        });

        return aeroportos;
      }

      // Determinar zona de restri√ß√£o baseada na dist√¢ncia de aeroportos
      function determinarZonaRestricao(lat, lng, aeroportos) {
        let menorDistancia = Infinity;
        let aeroportoMaisProximo = null;

        aeroportos.forEach(aeroporto => {
          const distancia = calcularDistanciaHaversine(lat, lng, aeroporto.lat, aeroporto.lng);
          if (distancia < menorDistancia) {
            menorDistancia = distancia;
            aeroportoMaisProximo = aeroporto;
          }
        });

        if (menorDistancia <= 5) {
          return {
            zona: 'prohibited',
            cor: 'rgba(231, 76, 60, 0.7)',
            descricao: 'Zona Proibida',
            aeroporto: aeroportoMaisProximo,
            distancia: menorDistancia
          };
        }
        
        if (menorDistancia <= 10) {
          return {
            zona: 'restricted',
            cor: 'rgba(241, 196, 15, 0.7)',
            descricao: 'Zona Restrita',
            aeroporto: aeroportoMaisProximo,
            distancia: menorDistancia
          };
        }

        return {
          zona: 'permitted',
          cor: 'rgba(46, 204, 113, 0.7)',
          descricao: 'Zona Permitida',
          aeroporto: aeroportoMaisProximo,
          distancia: menorDistancia
        };
      }

      // Calcular dist√¢ncia Haversine em km
      function calcularDistanciaHaversine(lat1, lng1, lat2, lng2) {
        const R = 6371;
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLng = (lng2 - lng1) * Math.PI / 180;
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                  Math.sin(dLng / 2) * Math.sin(dLng / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      // Toggle das zonas de drone
      function toggleDroneZones() {
        droneZonesActive = !droneZonesActive;
        
        if (droneZonesActive) {
          droneToggle.classList.add('active');
          droneLegend.classList.add('active');
          carregarZonasDrone();
        } else {
          droneToggle.classList.remove('active');
          droneLegend.classList.remove('active');
          if (droneZonesLayer) {
            droneZonesLayer.clearLayers();
          }
        }
      }

      // Carregar zonas de drone
      async function carregarZonasDrone() {
        if (!map) return;

        droneLoading.classList.add('active');

        try {
          const bounds = map.getBounds();
          const bbox = `${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}`;
          
          const cacheKey = bbox;
          
          let aeroportos;
          if (airportCache.has(cacheKey)) {
            aeroportos = airportCache.get(cacheKey);
          } else {
            aeroportos = await consultarAeroportosOverpass(bbox);
            airportCache.set(cacheKey, aeroportos);
          }

          if (!droneZonesLayer) {
            droneZonesLayer = L.layerGroup().addTo(map);
          } else {
            droneZonesLayer.clearLayers();
          }

          // Adicionar marcadores de aeroportos
          aeroportos.forEach(aeroporto => {
            const airportIcon = L.divIcon({
              className: 'airport-marker',
              html: `<div style="background: rgba(155, 89, 182, 0.9); color: white; padding: 4px 8px; border-radius: 15px; font-size: 12px; font-weight: bold; text-align: center; min-width: 40px;">‚úàÔ∏è</div>`,
              iconSize: [50, 25],
              iconAnchor: [25, 12]
            });

            const marker = L.marker([aeroporto.lat, aeroporto.lng], { icon: airportIcon });
            
            const popupContent = `
              <div style="min-width: 200px;">
                <h4>‚úàÔ∏è ${aeroporto.name}</h4>
                <p><strong>Tipo:</strong> ${aeroporto.type === 'helipad' || aeroporto.type === 'heliport' ? 'Heliponto' : 'Aeroporto'}</p>
                ${aeroporto.icao ? `<p><strong>ICAO:</strong> ${aeroporto.icao}</p>` : ''}
                ${aeroporto.iata ? `<p><strong>IATA:</strong> ${aeroporto.iata}</p>` : ''}
                <p><strong>Coordenadas:</strong><br>
                Lat: ${aeroporto.lat.toFixed(6)}<br>
                Lng: ${aeroporto.lng.toFixed(6)}</p>
                <div style="margin-top: 10px; padding: 8px; background: #fff3cd; border-radius: 5px; border: 1px solid #ffeaa7;">
                  <strong>‚ö†Ô∏è Zonas de Restri√ß√£o:</strong><br>
                  <span style="color: #e74c3c;">0-5km:</span> Proibido<br>
                  <span style="color: #f1c40f;">5-10km:</span> Restrito
                </div>
              </div>
            `;
            
            marker.bindPopup(popupContent);
            droneZonesLayer.addLayer(marker);

            // C√≠rculos de restri√ß√£o
            const circle5km = L.circle([aeroporto.lat, aeroporto.lng], {
              radius: 5000,
              fillColor: 'rgba(231, 76, 60, 0.3)',
              color: 'rgba(231, 76, 60, 0.8)',
              weight: 2,
              fillOpacity: 0.3
            });

            const circle10km = L.circle([aeroporto.lat, aeroporto.lng], {
              radius: 10000,
              fillColor: 'rgba(241, 196, 15, 0.2)',
              color: 'rgba(241, 196, 15, 0.6)',
              weight: 2,
              fillOpacity: 0.2
            });

            droneZonesLayer.addLayer(circle10km);
            droneZonesLayer.addLayer(circle5km);
          });

          if (imagePoints.length > 0) {
            atualizarZonasParaPontos(aeroportos);
          }

        } catch (error) {
          console.error('Erro ao carregar zonas de drone:', error);
        } finally {
          droneLoading.classList.remove('active');
        }
      }

      // Atualizar zonas para pontos existentes
      function atualizarZonasParaPontos(aeroportos) {
        imagePoints.forEach((point, index) => {
          const zona = determinarZonaRestricao(point.latitude, point.longitude, aeroportos);
          point.droneZone = zona;
        });
      }

      // Processar dados das rodovias
      function processarDadosRodovias(dadosDNIT) {
        if (!dadosDNIT || !Array.isArray(dadosDNIT)) {
          return { rodovias: [] };
        }
        
        const rodovias = dadosDNIT.map(item => ({
          br: item.br || 'N/A',
          km: item.km || '0',
          uf: item.uf || 'N/A',
          tipoTrecho: item.tipoTrecho || 'N/A',
          versao: item.versao || 'N/A'
        }));
        
        return { rodovias };
      }

      // Gerar HTML das informa√ß√µes de rodovias
      function gerarHtmlRodovias(dadosProcessados, coordenadas) {
        if (!dadosProcessados || !dadosProcessados.rodovias || dadosProcessados.rodovias.length === 0) {
          return `
            <div style="margin-top: 10px; padding: 6px; background: #f8f9fa; border-radius: 4px; border: 1px solid #dee2e6;">
              <div style="font-size: 11px; color: #6c757d;">
                Nenhuma rodovia encontrada
              </div>
            </div>
          `;
        }
        
        const rodovias = dadosProcessados.rodovias;
        
        const listaRodovias = rodovias.map(rodovia => {
          const isKmZero = parseFloat(rodovia.km) === 0;
          const alertIcon = isKmZero ? ' ‚ö†Ô∏è' : '';
          
          return `BR-${rodovia.br} (Km ${rodovia.km})${alertIcon}`;
        }).join(' ‚Ä¢ ');
        
        return `
          <div style="margin-top: 10px; padding: 6px; background: #f8f9fa; border-radius: 4px; border: 1px solid #dee2e6;">
            <div style="font-size: 11px; color: #6c757d; margin-bottom: 2px;">Rodovias:</div>
            <div style="font-size: 12px; color: #495057;">${listaRodovias}</div>
          </div>
        `;
      }

      // Definir diferentes camadas de tile
      const tileLayers = {
        osm: {
          url: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
          options: {
            attribution: "¬© OpenStreetMap contributors",
            maxZoom: 19
          }
        },
        satellite: {
          url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
          options: {
            attribution: "¬© Esri, Maxar, GeoEye, Earthstar Geographics",
            maxZoom: 23
          }
        },
        topo: {
          url: "https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png",
          options: {
            attribution: "¬© OpenTopoMap (CC-BY-SA)",
            maxZoom: 17
          }
        },
        dark: {
          url: "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png",
          options: {
            attribution: "¬© CARTO, ¬© OpenStreetMap contributors",
            maxZoom: 20
          }
        }
      };

      // Inicializar o mapa
      function initMap() {
        debugLog('Inicializando mapa');
        
        map = L.map("map", {
          maxZoom: 25,
          minZoom: 2,
          zoomControl: true,
          worldCopyJump: true
        }).setView([-15.7942, -47.8825], 4);

        switchTileLayer('osm');
        markersLayer = L.layerGroup().addTo(map);

        layerSelector.addEventListener('change', function() {
          switchTileLayer(this.value);
        });

        maxZoomBtn.addEventListener('click', function() {
          if (imagePoints.length > 0) {
            let latSum = 0, lngSum = 0;
            imagePoints.forEach(point => {
              latSum += point.latitude;
              lngSum += point.longitude;
            });
            const centerLat = latSum / imagePoints.length;
            const centerLng = lngSum / imagePoints.length;
            
            map.setView([centerLat, centerLng], map.getMaxZoom());
          } else {
            map.setZoom(map.getMaxZoom());
          }
        });

        // Event listener para toggle de zonas de drone
        droneToggle.addEventListener('click', toggleDroneZones);

        // Event listener para recarregar zonas quando o mapa move
        map.on('moveend', function() {
          if (droneZonesActive) {
            carregarZonasDrone();
          }
        });

        if (imagePoints.length > 0) {
          plotPointsOnMap();
        }
        
        debugLog('Mapa inicializado com sucesso');
      }

      // Mostrar preview da imagem
      function showImagePreview(point, currentName, isRenamed) {
        if (isPreviewOpen) return;

        isPreviewOpen = true;
        
        imagePreview.classList.add('loading');
        imagePreview.style.display = 'block';
        
        document.querySelector('.preview-loading').style.display = 'block';
        document.querySelector('.preview-loaded').style.display = 'none';

        const imageData = imageDataMap.get(point.filename);
        if (imageData) {
          const img = document.getElementById('previewImg');
          img.onload = function() {
            let infoHtml = `${isRenamed ? `<div style="color: #7f8c8d; font-style: italic;">Original: ${point.filename}</div>` : ''}
               <div><strong>Data/Hora:</strong> ${point.datetime || "N/A"}</div>`;

            if (point.droneZone) {
              const zoneIcon = point.droneZone.zona === 'prohibited' ? 'üö´' : 
                              point.droneZone.zona === 'restricted' ? '‚ö†Ô∏è' : '‚úÖ';
              
              infoHtml += `
                <div style="margin-top: 10px; padding: 8px; background: rgba(${point.droneZone.zona === 'prohibited' ? '231, 76, 60' : point.droneZone.zona === 'restricted' ? '241, 196, 15' : '46, 204, 113'}, 0.1); border-radius: 5px; border: 1px solid rgba(${point.droneZone.zona === 'prohibited' ? '231, 76, 60' : point.droneZone.zona === 'restricted' ? '241, 196, 15' : '46, 204, 113'}, 0.3);">
                  <strong>${zoneIcon} Zona de Drone:</strong> ${point.droneZone.descricao}<br>
                  ${point.droneZone.aeroporto ? `<small>Aeroporto mais pr√≥ximo: ${point.droneZone.aeroporto.name} (${point.droneZone.distancia.toFixed(1)}km)</small>` : ''}
                </div>
              `;
            }

            document.getElementById('previewTitle').innerHTML = 
              `üì∑ ${isRenamed ? '<span class="renamed-indicator">‚úèÔ∏è ' + currentName + '</span>' : currentName}`;
            
            document.getElementById('previewInfo').innerHTML = infoHtml;
            
            document.getElementById('previewCoords').innerHTML = 
              `<strong>Coordenadas:</strong><br>
               Latitude: ${point.latitude.toFixed(8)}<br>
               Longitude: ${point.longitude.toFixed(8)}`;

            document.querySelector('.preview-loading').style.display = 'none';
            document.querySelector('.preview-loaded').style.display = 'block';
            
            imagePreview.classList.remove('loading');
            imagePreview.classList.add('show');
          };
          
          img.onerror = function() {
            closePreview();
          };
          
          img.src = imageData;
        } else {
          closePreview();
        }
      }

      // Fechar preview
      function closePreview() {
        if (previewTimeout) {
          clearTimeout(previewTimeout);
          previewTimeout = null;
        }
        
        isPreviewOpen = false;
        imagePreview.classList.remove('show', 'loading');
        
        setTimeout(() => {
          if (!imagePreview.classList.contains('show')) {
            imagePreview.style.display = 'none';
          }
        }, 400);
      }

      // Event listeners para fechar preview
      if (imagePreview) {
        imagePreview.addEventListener('click', function(e) {
          if (e.target === this) {
            closePreview();
          }
        });
      }

      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && isPreviewOpen) {
          closePreview();
        }
      });

      // Fun√ß√£o para renomear arquivo
      function renameFile(index, originalFilename, fileExt) {
        const newNameInput = document.getElementById(`newName_${index}`);
        const newName = newNameInput.value.trim();
        
        if (!newName) {
          alert('Por favor, insira um nome v√°lido.');
          return;
        }
        
        const fullNewName = newName + fileExt;
        
        const existingNames = Array.from(renamedFiles.values());
        const originalNames = imagePoints.map(p => p.filename);
        
        if (existingNames.includes(fullNewName) || originalNames.includes(fullNewName)) {
          if (renamedFiles.get(originalFilename) !== fullNewName) {
            alert('Este nome j√° est√° sendo usado por outro arquivo.');
            return;
          }
        }
        
        renamedFiles.set(originalFilename, fullNewName);
        updateResultsTable();
        updateStats();
        plotPointsOnMap();
        downloadZipBtn.disabled = false;
        map.closePopup();
      }

      // Fun√ß√£o para resetar nome do arquivo
      function resetFileName(originalFilename, index) {
        renamedFiles.delete(originalFilename);
        updateResultsTable();
        updateStats();
        plotPointsOnMap();
        
        if (renamedFiles.size === 0) {
          downloadZipBtn.disabled = true;
        }
        
        map.closePopup();
      }

      // Fun√ß√£o para remover ponto importado
      function removeImportedPoint(index) {
        if (confirm('Tem certeza que deseja remover este ponto importado?')) {
          const allPoints = combineAllPoints();
          const imagePointsCount = imagePoints.length;
          
          if (index >= imagePointsCount) {
            const importedIndex = index - imagePointsCount;
            importedPoints.splice(importedIndex, 1);
            importedCount = importedPoints.length;
            
            document.getElementById("importedPoints").textContent = importedCount;
            
            updateResultsTable();
            plotPointsOnMap();
            
            map.closePopup();
            
            const totalPoints = imagePoints.length + importedPoints.length;
            if (totalPoints === 0) {
              downloadKmlBtn.disabled = true;
              downloadCsvBtn.disabled = true;
            }
          }
        }
      }

      // Atualizar estat√≠sticas
      function updateStats() {
        document.getElementById("renamedImages").textContent = renamedFiles.size;
        document.getElementById("importedPoints").textContent = importedCount;
      }

      // Consultar rodovias para popup
      async function consultarRodoviasParaPopup(point, index) {
        const coordKey = `${point.latitude.toFixed(6)}_${point.longitude.toFixed(6)}`;
        
        if (rodoviaCache.has(coordKey)) {
          exibirRodoviasNoPopup(rodoviaCache.get(coordKey), index, point);
          return;
        }
        
        try {
          const dadosDNIT = await consultarRodoviasDNIT(point.latitude, point.longitude);
          const dadosProcessados = processarDadosRodovias(dadosDNIT);
          
          rodoviaCache.set(coordKey, dadosProcessados);
          exibirRodoviasNoPopup(dadosProcessados, index, point);
          
        } catch (error) {
          console.error('Erro ao consultar rodovias:', error);
          exibirErroRodovias(index);
        }
      }

      // Exibir rodovias no popup
      function exibirRodoviasNoPopup(dadosProcessados, index, point) {
        const loadingDiv = document.getElementById(`rodoviaLoading_${index}`);
        const contentDiv = document.getElementById(`rodoviaContent_${index}`);
        
        if (loadingDiv) loadingDiv.style.display = 'none';
        if (contentDiv) {
          contentDiv.innerHTML = gerarHtmlRodovias(dadosProcessados, {
            lat: point.latitude,
            lng: point.longitude
          });
          contentDiv.style.display = 'block';
        }
      }

      // Exibir erro na consulta de rodovias
      function exibirErroRodovias(index) {
        const loadingDiv = document.getElementById(`rodoviaLoading_${index}`);
        const contentDiv = document.getElementById(`rodoviaContent_${index}`);
        
        if (loadingDiv) loadingDiv.style.display = 'none';
        if (contentDiv) {
          contentDiv.innerHTML = `
            <div style="padding: 10px; background: #ffebee; border: 1px solid #f44336; border-radius: 5px; text-align: center;">
              <div style="color: #d32f2f; font-size: 13px; font-weight: bold;">
                ‚ùå Erro ao consultar rodovias
              </div>
              <div style="color: #666; font-size: 11px; margin-top: 3px;">
                Verifique sua conex√£o com a internet
              </div>
            </div>
          `;
          contentDiv.style.display = 'block';
        }
      }

      // Trocar camada de tile
      function switchTileLayer(layerType) {
        if (currentTileLayer) {
          map.removeLayer(currentTileLayer);
        }

        const layer = tileLayers[layerType];
        currentTileLayer = L.tileLayer(layer.url, layer.options).addTo(map);
        map.options.maxZoom = layer.options.maxZoom;
      }

      // Plotar pontos no mapa
      function plotPointsOnMap() {
        if (!map || !markersLayer) return;

        debugLog('Plotando pontos no mapa');
        markersLayer.clearLayers();

        const allPoints = combineAllPoints();
        if (allPoints.length === 0) return;

        let bounds = L.latLngBounds();

        allPoints.forEach((point, index) => {
          const currentName = renamedFiles.get(point.filename) || point.filename;
          const isRenamed = renamedFiles.has(point.filename);
          const isImported = point.imported || false;
          
          // Criar √≠cone personalizado baseado na zona de drone ou se foi importado
          let markerIcon;
          if (isImported) {
            markerIcon = L.divIcon({
              className: 'custom-marker',
              html: `<div style="background: #9b59b6; width: 25px; height: 25px; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 10px rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; font-size: 14px;">üìç</div>`,
              iconSize: [25, 25],
              iconAnchor: [12.5, 12.5]
            });
          } else if (droneZonesActive && point.droneZone) {
            const zoneColor = point.droneZone.zona === 'prohibited' ? '#e74c3c' : 
                             point.droneZone.zona === 'restricted' ? '#f39c12' : '#27ae60';
            
            markerIcon = L.divIcon({
              className: 'custom-marker',
              html: `<div style="background: ${zoneColor}; width: 25px; height: 25px; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 10px rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; font-size: 14px;">üì∑</div>`,
              iconSize: [25, 25],
              iconAnchor: [12.5, 12.5]
            });
          } else {
            markerIcon = new L.Icon.Default();
          }
          
          const marker = L.marker([point.latitude, point.longitude], { icon: markerIcon });
          
          const popup = L.popup({
            maxWidth: 350,
            minWidth: 320
          });
          
          if (isImported) {
            popup.setContent(createImportedPopupContent(point, index));
          } else {
            popup.setContent(createPopupContent(point, index, currentName, isRenamed));
          }
          
          marker.bindPopup(popup);
          
          // Event listener para quando o popup √© aberto (s√≥ para pontos de imagem)
          if (!isImported) {
            marker.on('popupopen', function(e) {
              setTimeout(() => {
                consultarRodoviasParaPopup(point, index);
              }, 100);
            });

            // Adicionar eventos de preview da imagem
            marker.on('mouseover', function(e) {
              if (!isPreviewOpen) {
                previewTimeout = setTimeout(() => {
                  showImagePreview(point, currentName, isRenamed);
                }, 2000);
              }
            });

            marker.on('mouseout', function(e) {
              if (previewTimeout) {
                clearTimeout(previewTimeout);
                previewTimeout = null;
              }
            });
          }

          markersLayer.addLayer(marker);
          bounds.extend([point.latitude, point.longitude]);
        });

        if (allPoints.length > 0) {
          map.fitBounds(bounds, { padding: [20, 20] });
        }

        // Se zonas de drone est√£o ativas, recarregar
        if (droneZonesActive) {
          setTimeout(() => {
            carregarZonasDrone();
          }, 500);
        }
        
        debugLog(`Plotados ${allPoints.length} pontos no mapa`);
      }

      // Criar conte√∫do do popup para pontos importados
      function createImportedPopupContent(point, index) {
        let droneInfo = '';
        if (droneZonesActive && point.droneZone) {
          const zoneIcon = point.droneZone.zona === 'prohibited' ? 'üö´' : 
                          point.droneZone.zona === 'restricted' ? '‚ö†Ô∏è' : '‚úÖ';
          
          droneInfo = `
            <div style="margin-top: 10px; padding: 8px; background: rgba(${point.droneZone.zona === 'prohibited' ? '231, 76, 60' : point.droneZone.zona === 'restricted' ? '241, 196, 15' : '46, 204, 113'}, 0.1); border-radius: 5px; border: 1px solid rgba(${point.droneZone.zona === 'prohibited' ? '231, 76, 60' : point.droneZone.zona === 'restricted' ? '241, 196, 15' : '46, 204, 113'}, 0.3);">
              <div style="font-size: 12px; color: #495057; margin-bottom: 2px;"><strong>${zoneIcon} Zona de Drone:</strong></div>
              <div style="font-size: 11px; color: #6c757d;">${point.droneZone.descricao}</div>
              ${point.droneZone.aeroporto ? `<div style="font-size: 10px; color: #6c757d;">Aeroporto: ${point.droneZone.aeroporto.name} (${point.droneZone.distancia.toFixed(1)}km)</div>` : ''}
            </div>
          `;
        }
        
        return `
          <div style="width: 320px;">
            <h4>üìç ${point.filename} <span style="color: #9b59b6; font-size: 12px;">(Importado)</span></h4>
            <p><strong>Coordenadas:</strong><br>
            Lat: ${point.latitude.toFixed(8)}<br>
            Lng: ${point.longitude.toFixed(8)}</p>
            ${point.datetime ? `<p><strong>Data/Hora:</strong><br>${point.datetime}</p>` : ''}
            ${point.description ? `<p><strong>Descri√ß√£o:</strong><br>${point.description}</p>` : ''}
            
            ${droneInfo}
            
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd;">
              <div class="popup-buttons">
                <button class="popup-btn" onclick="map.setView([${point.latitude}, ${point.longitude}], map.getMaxZoom())">
                  üîç Zoom Max
                </button>
                <button class="popup-btn danger" onclick="removeImportedPoint(${index})">
                  üóëÔ∏è Remover
                </button>
              </div>
            </div>
          </div>
        `;
      }

      // Criar conte√∫do do popup
      function createPopupContent(point, index, currentName, isRenamed) {
        const fileNameWithoutExt = currentName.substring(0, currentName.lastIndexOf('.')) || currentName;
        const fileExt = currentName.substring(currentName.lastIndexOf('.')) || '';
        
        let droneInfo = '';
        if (droneZonesActive && point.droneZone) {
          const zoneIcon = point.droneZone.zona === 'prohibited' ? 'üö´' : 
                          point.droneZone.zona === 'restricted' ? '‚ö†Ô∏è' : '‚úÖ';
          
          droneInfo = `
            <div style="margin-top: 10px; padding: 8px; background: rgba(${point.droneZone.zona === 'prohibited' ? '231, 76, 60' : point.droneZone.zona === 'restricted' ? '241, 196, 15' : '46, 204, 113'}, 0.1); border-radius: 5px; border: 1px solid rgba(${point.droneZone.zona === 'prohibited' ? '231, 76, 60' : point.droneZone.zona === 'restricted' ? '241, 196, 15' : '46, 204, 113'}, 0.3);">
              <div style="font-size: 12px; color: #495057; margin-bottom: 2px;"><strong>${zoneIcon} Zona de Drone:</strong></div>
              <div style="font-size: 11px; color: #6c757d;">${point.droneZone.descricao}</div>
              ${point.droneZone.aeroporto ? `<div style="font-size: 10px; color: #6c757d;">Aeroporto: ${point.droneZone.aeroporto.name} (${point.droneZone.distancia.toFixed(1)}km)</div>` : ''}
            </div>
          `;
        }
        
        return `
          <div style="width: 320px;">
            <h4>üì∑ ${isRenamed ? '<span class="renamed-indicator">‚úèÔ∏è ' + currentName + '</span>' : currentName}</h4>
            ${isRenamed ? `<p class="original-name">Original: ${point.filename}</p>` : ''}
            <p><strong>Coordenadas:</strong><br>
            Lat: ${point.latitude.toFixed(8)}<br>
            Lng: ${point.longitude.toFixed(8)}</p>
            <p><strong>Data/Hora:</strong><br>
            ${point.datetime || "N/A"}</p>
            
            ${droneInfo}
            
            <div class="rename-section">
              <p><strong>Renomear arquivo:</strong></p>
              <input type="text" id="newName_${index}" class="rename-input" 
                     value="${fileNameWithoutExt}" placeholder="Novo nome do arquivo">
              <div class="popup-buttons">
                <button class="popup-btn success" onclick="renameFile(${index}, '${point.filename}', '${fileExt}')">
                  ‚úì Renomear
                </button>
                <button class="popup-btn" onclick="map.setView([${point.latitude}, ${point.longitude}], map.getMaxZoom())">
                  üîç Zoom Max
                </button>
                ${isRenamed ? `<button class="popup-btn danger" onclick="resetFileName('${point.filename}', ${index})">‚Ü∂ Desfazer</button>` : ''}
              </div>
            </div>
            
            <!-- Se√ß√£o de Rodovias -->
            <div id="rodoviaInfo_${index}">
              <div id="rodoviaLoading_${index}" style="margin-top: 10px; padding: 6px; background: #f8f9fa; border-radius: 4px; text-align: center;">
                <div style="display: inline-block; width: 12px; height: 12px; border: 2px solid #ddd; border-radius: 50%; border-top: 2px solid #6c757d; animation: spin 1s linear infinite; margin-right: 5px;"></div>
                <span style="font-size: 11px; color: #6c757d;">Consultando rodovias...</span>
              </div>
              <div id="rodoviaContent_${index}" style="display: none;"></div>
            </div>
          </div>
        `;
      }

      // Atualizar tabela de resultados (incluindo pontos importados)
      function updateResultsTable() {
        resultsBody.innerHTML = "";
        
        const allPoints = combineAllPoints();
        
        allPoints.forEach((point) => {
          const currentName = renamedFiles.get(point.filename) || point.filename;
          const isRenamed = renamedFiles.has(point.filename);
          const isImported = point.imported || false;
          
          const row = resultsBody.insertRow();
          
          const nameCell = row.insertCell(0);
          if (isImported) {
            nameCell.innerHTML = `<span style="color: #9b59b6;">${currentName}</span><br><small style="color: #9b59b6; font-style: italic;">(Importado do KML)</small>`;
          } else if (isRenamed) {
            nameCell.innerHTML = `<span class="renamed-indicator">${currentName}</span><br><small class="original-name">${point.filename}</small>`;
          } else {
            nameCell.textContent = currentName;
          }
          
          row.insertCell(1).textContent = point.latitude.toFixed(8);
          row.insertCell(2).textContent = point.longitude.toFixed(8);
          row.insertCell(3).textContent = point.datetime || "N/A";
        });
      }

      // Setup de eventos
      dropZone.addEventListener("dragover", (e) => {
        e.preventDefault();
        dropZone.style.backgroundColor = "rgba(52, 152, 219, 0.2)";
      });

      dropZone.addEventListener("dragleave", (e) => {
        e.preventDefault();
        dropZone.style.backgroundColor = "rgba(52, 152, 219, 0.1)";
      });

      dropZone.addEventListener("drop", (e) => {
        e.preventDefault();
        dropZone.style.backgroundColor = "rgba(52, 152, 219, 0.1)";
        handleFiles(e.dataTransfer.files);
      });

      fileInput.addEventListener("change", (e) => {
        handleFiles(e.target.files);
      });

      // Fun√ß√£o principal para processar os arquivos
      function handleFiles(files) {
        if (!files || files.length === 0) {
          debugLog('Nenhum arquivo selecionado');
          return;
        }

        debugLog(`Processando ${files.length} arquivos`);

        // Reset
        imagePoints = [];
        originalFiles.clear();
        imageDataMap.clear();
        renamedFiles.clear();
        processedImages = 0;
        imagesWithGeo = 0;
        totalImages = files.length;
        resultsBody.innerHTML = "";

        document.getElementById("totalImages").textContent = totalImages;
        document.getElementById("geoImages").textContent = "0";
        document.getElementById("renamedImages").textContent = "0";

        progressBar.style.display = "block";
        progress.style.width = "0%";
        progress.textContent = "0%";

        downloadKmlBtn.disabled = true;
        downloadKmzBtn.disabled = true;
        downloadCsvBtn.disabled = true;
        downloadZipBtn.disabled = true;

        if (markersLayer) {
          markersLayer.clearLayers();
        }

        // Verificar se EXIF est√° dispon√≠vel
        if (typeof EXIF === 'undefined') {
          debugLog('ERRO: Biblioteca EXIF n√£o carregada');
          alert('Erro: Biblioteca EXIF n√£o foi carregada. Recarregue a p√°gina.');
          return;
        }

        Array.from(files).forEach((file, index) => {
          if (!file.type.startsWith("image/")) {
            debugLog(`Arquivo ${file.name} n√£o √© uma imagem`);
            updateProgress();
            return;
          }

          debugLog(`Processando imagem: ${file.name}`);
          originalFiles.set(file.name, file);

          const reader = new FileReader();
          reader.onload = function (e) {
            processImage(file, e.target.result);
          };
          reader.onerror = function() {
            debugLog(`Erro ao ler arquivo: ${file.name}`);
            updateProgress();
          };
          reader.readAsDataURL(file);
        });
      }

      // Processa uma imagem individual
      function processImage(file, dataUrl) {
        debugLog(`Processando imagem: ${file.name}`);
        
        const img = new Image();
        img.onload = function () {
          debugLog(`Imagem carregada: ${file.name}`);
          
          try {
            EXIF.getData(img, function () {
              let lat = null;
              let lng = null;
              let datetime = null;

              const gpsLat = EXIF.getTag(this, "GPSLatitude");
              const gpsLng = EXIF.getTag(this, "GPSLongitude");
              
              debugLog(`GPS Latitude: ${gpsLat}, GPS Longitude: ${gpsLng}`);

              if (gpsLat && gpsLng) {
                lat = convertDMSToDD(
                  gpsLat,
                  EXIF.getTag(this, "GPSLatitudeRef")
                );

                lng = convertDMSToDD(
                  gpsLng,
                  EXIF.getTag(this, "GPSLongitudeRef")
                );

                const dateTimeOriginal = EXIF.getTag(this, "DateTimeOriginal");
                if (dateTimeOriginal) {
                  datetime = dateTimeOriginal;
                }

                debugLog(`Coordenadas convertidas: Lat=${lat}, Lng=${lng}`);

                if (isValidCoordinate(lat, lng)) {
                  imagesWithGeo++;
                  document.getElementById("geoImages").textContent = imagesWithGeo;

                  // Criar vers√£o redimensionada da imagem para economizar mem√≥ria
                  const canvas = document.createElement('canvas');
                  const ctx = canvas.getContext('2d');
                  
                  const maxSize = 800;
                  let { width, height } = img;
                  
                  if (width > height && width > maxSize) {
                    height = (height * maxSize) / width;
                    width = maxSize;
                  } else if (height > maxSize) {
                    width = (width * maxSize) / height;
                    height = maxSize;
                  }
                  
                  canvas.width = width;
                  canvas.height = height;
                  ctx.drawImage(img, 0, 0, width, height);
                  
                  imageDataMap.set(file.name, canvas.toDataURL('image/jpeg', 0.85));

                  imagePoints.push({
                    filename: file.name,
                    latitude: lat,
                    longitude: lng,
                    datetime: datetime,
                  });

                  const row = resultsBody.insertRow();
                  row.insertCell(0).textContent = file.name;
                  row.insertCell(1).textContent = lat.toFixed(8);
                  row.insertCell(2).textContent = lng.toFixed(8);
                  row.insertCell(3).textContent = datetime || "N/A";
                  
                  debugLog(`Ponto adicionado: ${file.name}`);
                } else {
                  debugLog(`Coordenadas inv√°lidas para: ${file.name}`);
                }
              } else {
                debugLog(`Sem coordenadas GPS em: ${file.name}`);
              }

              updateProgress();
            });
          } catch (error) {
            debugLog(`Erro ao processar EXIF de ${file.name}: ${error.message}`);
            updateProgress();
          }
        };
        
        img.onerror = function() {
          debugLog(`Erro ao carregar imagem: ${file.name}`);
          updateProgress();
        };
        
        img.src = dataUrl;
      }

      // Atualiza o progresso
      function updateProgress() {
        processedImages++;
        const percentage = Math.round((processedImages / totalImages) * 100);
        progress.style.width = percentage + "%";
        progress.textContent = percentage + "%";

        debugLog(`Progresso: ${processedImages}/${totalImages} (${percentage}%)`);

        if (processedImages === totalImages) {
          const totalPoints = imagePoints.length + importedPoints.length;
          if (totalPoints > 0) {
            downloadKmlBtn.disabled = false;
            downloadCsvBtn.disabled = false;
            
            // Habilitar KMZ apenas se h√° imagens com geolocaliza√ß√£o
            if (imagePoints.length > 0) {
              downloadKmzBtn.disabled = false;
            }
            
            plotPointsOnMap();
          }
          
          debugLog(`Processamento conclu√≠do: ${imagePoints.length} imagens com GPS de ${totalImages} total`);
        }
      }

      // Converter coordenadas DMS para Decimal Degrees
      function convertDMSToDD(dms, ref) {
        if (!dms || dms.length !== 3) return null;

        let dd = Number(dms[0]) + Number(dms[1]) / 60 + Number(dms[2]) / 3600;

        if (ref === "S" || ref === "W") {
          dd = -dd;
        }

        return dd;
      }

      // Verifica se as coordenadas s√£o v√°lidas
      function isValidCoordinate(lat, lng) {
        return (
          lat !== null &&
          lng !== null &&
          !isNaN(lat) &&
          !isNaN(lng) &&
          lat >= -90 &&
          lat <= 90 &&
          lng >= -180 &&
          lng <= 180
        );
      }

      // Event listeners dos bot√µes de download
      downloadKmlBtn.addEventListener("click", () => {
        const allPoints = combineAllPoints();
        if (allPoints.length === 0) return;

        const kmlContent = generateKML();
        if (!kmlContent) return;

        const dataStr =
          "data:application/vnd.google-earth.kml+xml;charset=utf-8," +
          encodeURIComponent(kmlContent);
        const downloadAnchor = document.createElement("a");
        downloadAnchor.setAttribute("href", dataStr);
        downloadAnchor.setAttribute("download", "pontos_georreferenciados.kml");
        document.body.appendChild(downloadAnchor);
        downloadAnchor.click();
        downloadAnchor.remove();
      });

      downloadKmzBtn.addEventListener("click", () => {
        generateKMZ();
      });

      downloadCsvBtn.addEventListener("click", () => {
        const allPoints = combineAllPoints();
        if (allPoints.length === 0) return;

        let csvContent = "Nome do Arquivo,Nome Original,Latitude,Longitude,Data/Hora,Tipo\n";

        allPoints.forEach((point) => {
          const currentName = renamedFiles.get(point.filename) || point.filename;
          const isImported = point.imported || false;
          const tipo = isImported ? 'Importado' : 'Imagem';
          const originalName = point.filename;
          
          csvContent += `"${currentName}","${originalName}",${String(point.latitude)},${String(
            point.longitude
          )},"${point.datetime || ""}","${tipo}"\n`;
        });

        const dataStr =
          "data:text/csv;charset=utf-8," + encodeURIComponent(csvContent);
        const downloadAnchor = document.createElement("a");
        downloadAnchor.setAttribute("href", dataStr);
        downloadAnchor.setAttribute("download", "pontos_georreferenciados.csv");
        document.body.appendChild(downloadAnchor);
        downloadAnchor.click();
        downloadAnchor.remove();
      });

      // Fun√ß√£o para carregar JSZip dinamicamente
      function loadJSZip(callback) {
        if (window.JSZip) {
          callback();
          return;
        }

        const script = document.createElement("script");
        script.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
        script.onload = callback;
        script.onerror = () => {
          alert("Erro ao carregar JSZip. Verifique sua conex√£o com a internet.");
        };

        document.head.appendChild(script);
      }

      downloadZipBtn.addEventListener("click", () => {
        if (imagePoints.length === 0) return;

        loadJSZip(() => {
          const zip = new JSZip();
          let promises = [];

          imagePoints.forEach((point) => {
            const originalFile = originalFiles.get(point.filename);
            if (originalFile) {
              const currentName = renamedFiles.get(point.filename) || point.filename;
              
              const promise = new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                  zip.file(currentName, e.target.result);
                  resolve();
                };
                reader.onerror = reject;
                reader.readAsArrayBuffer(originalFile);
              });
              
              promises.push(promise);
            }
          });

          Promise.all(promises)
            .then(() => {
              return zip.generateAsync({ type: "blob" });
            })
            .then((blob) => {
              const link = document.createElement("a");
              link.href = URL.createObjectURL(blob);
              link.download = "fotos_georreferenciadas.zip";
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
            })
            .catch((error) => {
              alert("Erro ao criar o ZIP: " + error.message);
            });
        });
      });

      // Inicializar o mapa quando a p√°gina carregar
      document.addEventListener("DOMContentLoaded", function () {
        debugLog('DOM carregado, inicializando aplica√ß√£o');
        initMap();
        
        // Teste b√°sico das bibliotecas
        if (typeof EXIF === 'undefined') {
          debugLog('ERRO: EXIF n√£o carregado');
        } else {
          debugLog('EXIF carregado com sucesso');
        }
        
        if (typeof L === 'undefined') {
          debugLog('ERRO: Leaflet n√£o carregado');
        } else {
          debugLog('Leaflet carregado com sucesso');
        }
      });
    </script>
  </body>
</html>