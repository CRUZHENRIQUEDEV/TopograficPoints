<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <!-- Versão: 3.0 -->
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
      Conversor de Imagens Georreferenciadas para KML - OAE Support
    </title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exif-js/2.3.0/exif.min.js"></script>

    <!-- Leaflet CSS e JS -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(
          135deg,
          #2c3e50 0%,
          #34495e 50%,
          #2c3e50 100%
        );
        min-height: 100vh;
        color: #ffffff;
        overflow-x: hidden;
      }

      .main-container {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
      }

      .map-container {
        width: 100vw;
        margin-left: calc(-50vw + 50%);
        padding: 0;
        background: rgba(255, 255, 255, 0.05);
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .map-header {
        max-width: 800px;
        margin: 0 auto;
        padding: 2rem 2rem 1rem 2rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 1rem;
      }

      .map-controls {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }

      .map-controls select {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        color: white;
        padding: 8px 12px;
        font-size: 14px;
        backdrop-filter: blur(5px);
      }

      .map-controls select option {
        background: #2c3e50;
        color: white;
      }

      /* Toggle para zonas de drone */
      .drone-toggle {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        padding: 8px 12px;
        color: white;
        cursor: pointer;
        font-size: 14px;
        backdrop-filter: blur(5px);
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .drone-toggle:hover {
        background: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.5);
      }

      .drone-toggle.active {
        background: linear-gradient(45deg, #e74c3c, #c0392b);
        border-color: #e74c3c;
        box-shadow: 0 0 10px rgba(231, 76, 60, 0.3);
      }

      .drone-icon {
        font-size: 16px;
      }

      h1,
      h2 {
        color: #ffffff;
        font-weight: 700;
        margin-bottom: 1rem;
        background: linear-gradient(45deg, #ffffff, #e3f2fd);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      }

      h1 {
        font-size: 2.2rem;
        text-align: center;
        margin-bottom: 2rem;
      }

      h2 {
        font-size: 1.5rem;
      }

      .container {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 20px;
        padding: 2rem;
        margin-bottom: 2rem;
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
      }

      .container::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.1),
          transparent
        );
        transition: left 0.5s ease;
      }

      .container:hover::before {
        left: 100%;
      }

      .container:hover {
        transform: translateY(-5px);
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        border-color: rgba(255, 255, 255, 0.4);
      }

      #dropZone {
        border: 2px dashed #3498db;
        border-radius: 15px;
        padding: 30px;
        text-align: center;
        margin: 20px 0;
        cursor: pointer;
        background: rgba(52, 152, 219, 0.1);
        transition: all 0.3s ease;
        backdrop-filter: blur(5px);
      }

      #dropZone:hover {
        background: rgba(52, 152, 219, 0.2);
        border-color: #64b5f6;
        transform: translateY(-2px);
      }

      #dropZone h3 {
        color: #64b5f6;
        margin-bottom: 1rem;
      }

      button {
        background: linear-gradient(45deg, #3498db, #2ecc71);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 15px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 600;
        margin: 10px 5px;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        background: linear-gradient(45deg, #2980b9, #27ae60);
      }

      button:disabled {
        background: linear-gradient(45deg, #95a5a6, #7f8c8d);
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        overflow: hidden;
        backdrop-filter: blur(5px);
      }

      th,
      td {
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: 12px;
        text-align: left;
      }

      th {
        background: rgba(52, 152, 219, 0.3);
        font-weight: 600;
        color: #ffffff;
      }

      td {
        background: rgba(255, 255, 255, 0.05);
      }

      tbody tr:hover td {
        background: rgba(255, 255, 255, 0.1);
      }

      #map {
        height: 70vh;
        min-height: 500px;
        width: 100%;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(5px);
        z-index: 1;
        position: relative;
      }

      /* Legenda das zonas de drone */
      .drone-legend {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 10px;
        padding: 15px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        z-index: 1000;
        min-width: 200px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        display: none;
      }

      .drone-legend.active {
        display: block;
      }

      .drone-legend h4 {
        color: #2c3e50;
        margin-bottom: 10px;
        font-size: 14px;
        font-weight: 600;
      }

      .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
        font-size: 12px;
        color: #333;
      }

      .legend-color {
        width: 20px;
        height: 15px;
        border-radius: 3px;
        margin-right: 8px;
        border: 1px solid rgba(0, 0, 0, 0.2);
      }

      .legend-color.prohibited {
        background: rgba(231, 76, 60, 0.7);
      }

      .legend-color.restricted {
        background: rgba(241, 196, 15, 0.7);
      }

      .legend-color.permitted {
        background: rgba(46, 204, 113, 0.7);
      }

      .legend-color.airport {
        background: rgba(155, 89, 182, 0.7);
      }

      .progress-bar {
        width: 100%;
        background: rgba(255, 255, 255, 0.2);
        padding: 3px;
        border-radius: 15px;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
        margin: 20px 0;
        backdrop-filter: blur(5px);
      }

      .progress {
        background: linear-gradient(45deg, #3498db, #2ecc71);
        height: 20px;
        border-radius: 12px;
        transition: width 0.3s ease;
        text-align: center;
        line-height: 20px;
        color: white;
        font-weight: 600;
      }

      .note {
        background: rgba(255, 235, 59, 0.2);
        padding: 15px;
        border-left: 4px solid #ffd600;
        margin: 15px 0;
        border-radius: 10px;
        backdrop-filter: blur(5px);
      }

      #stats {
        background: rgba(255, 255, 255, 0.1);
        padding: 15px;
        border-radius: 15px;
        margin: 20px 0;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      #stats p {
        margin: 5px 0;
        font-weight: 500;
      }

      #stats span {
        color: #64b5f6;
        font-weight: 700;
      }

      .footer {
        text-align: center;
        padding: 2rem 0;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        margin-top: 3rem;
        background: rgba(44, 62, 80, 0.3);
        border-radius: 15px 15px 0 0;
      }

      .footer p {
        opacity: 0.9;
        font-size: 0.95rem;
        margin-bottom: 0.5rem;
      }

      .zenith-brand {
        font-weight: 600;
        background: linear-gradient(45deg, #3498db, #2ecc71);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        font-size: 1.1rem;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      /* Customização adicional do popup com rodovias */
      .leaflet-popup-content {
        color: #333;
        font-size: 14px;
        width: 320px !important;
        max-height: 500px;
        overflow-y: auto;
      }

      .leaflet-popup-content h4 {
        margin: 0 0 10px 0;
        color: #2c3e50;
      }

      /* Estilos para os campos de renomeação no popup */
      .rename-section {
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px solid #ddd;
      }

      .rename-input {
        width: 100%;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 5px;
        font-size: 14px;
        margin-bottom: 10px;
        font-family: inherit;
      }

      .rename-input:focus {
        outline: none;
        border-color: #3498db;
        box-shadow: 0 0 5px rgba(52, 152, 219, 0.3);
      }

      .popup-buttons {
        display: flex;
        gap: 5px;
        flex-wrap: wrap;
      }

      .popup-btn {
        background: #3498db;
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 12px;
        font-weight: 500;
        transition: background 0.3s ease;
        flex: 1;
        min-width: 80px;
      }

      .popup-btn:hover {
        background: #2980b9;
        transform: none;
        box-shadow: none;
      }

      .popup-btn.success {
        background: #2ecc71;
      }

      .popup-btn.success:hover {
        background: #27ae60;
      }

      .popup-btn.danger {
        background: #e74c3c;
      }

      .popup-btn.danger:hover {
        background: #c0392b;
      }

      /* Indicadores visuais nos marcadores */
      .leaflet-marker-icon {
        transition: all 0.3s ease;
      }

      .leaflet-marker-icon:hover {
        filter: brightness(1.2) drop-shadow(0 0 10px rgba(52, 152, 219, 0.6));
      }

      /* Botão especial para baixar ZIP */
      .btn-zip {
        background: linear-gradient(45deg, #9b59b6, #8e44ad);
      }

      .btn-zip:hover {
        background: linear-gradient(45deg, #8e44ad, #7d3c98);
      }

      /* Estilos para o preview de imagem */
      .image-preview {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10000;
        background: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
        border: 2px solid rgba(255, 255, 255, 0.2);
        max-width: 90vw;
        max-height: 90vh;
        display: none;
        opacity: 0;
        transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        pointer-events: none;
      }

      .image-preview.show {
        display: block;
        opacity: 1;
        pointer-events: all;
        transform: translate(-50%, -50%) scale(1);
      }

      .image-preview.loading {
        display: block;
        opacity: 1;
        pointer-events: none;
      }

      .preview-header {
        color: white;
        margin-bottom: 15px;
        text-align: center;
        font-size: 18px;
        font-weight: 600;
        background: linear-gradient(45deg, #3498db, #2ecc71);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .preview-image {
        max-width: 100%;
        max-height: 60vh;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        display: block;
        margin: 0 auto;
      }

      .preview-info {
        color: rgba(255, 255, 255, 0.9);
        margin-top: 15px;
        text-align: center;
        font-size: 14px;
        line-height: 1.6;
      }

      .preview-coords {
        background: rgba(255, 255, 255, 0.1);
        padding: 10px;
        border-radius: 10px;
        margin-top: 10px;
        font-family: 'Courier New', monospace;
        font-size: 13px;
      }

      .preview-close {
        position: absolute;
        top: 15px;
        right: 20px;
        background: rgba(255, 255, 255, 0.2);
        border: none;
        border-radius: 50%;
        width: 35px;
        height: 35px;
        color: white;
        cursor: pointer;
        font-size: 18px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s ease;
        backdrop-filter: blur(5px);
      }

      .preview-close:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: scale(1.1);
      }

      .preview-loading {
        text-align: center;
        color: white;
        padding: 40px;
        font-size: 16px;
      }

      .loading-spinner {
        display: inline-block;
        width: 30px;
        height: 30px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top: 3px solid #3498db;
        animation: spin 1s linear infinite;
        margin-bottom: 15px;
      }

      /* Loading para zonas de drone */
      .drone-loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 20px;
        border-radius: 10px;
        z-index: 10000;
        text-align: center;
        backdrop-filter: blur(5px);
        display: none;
      }

      .drone-loading.active {
        display: block;
      }

      /* Indicador de arquivo renomeado */
      .renamed-indicator {
        color: #2ecc71;
        font-weight: bold;
      }

      .original-name {
        color: #7f8c8d;
        font-style: italic;
        text-decoration: line-through;
      }

      @media (max-width: 768px) {
        .main-container {
          padding: 1rem;
        }

        h1 {
          font-size: 1.8rem;
        }

        .container {
          padding: 1.5rem;
        }

        .map-header {
          padding: 1rem;
          flex-direction: column;
          align-items: stretch;
        }

        .map-controls {
          justify-content: center;
        }

        #dropZone {
          padding: 20px;
        }

        table {
          font-size: 14px;
        }

        th,
        td {
          padding: 8px;
        }

        #map {
          height: 50vh;
          min-height: 300px;
        }

        .leaflet-popup-content {
          width: 280px !important;
        }

        .image-preview {
          padding: 15px;
          max-width: 95vw;
          max-height: 95vh;
        }

        .preview-image {
          max-height: 50vh;
        }

        .preview-header {
          font-size: 16px;
        }

        .drone-legend {
          right: 5px;
          top: 5px;
          min-width: 180px;
        }
      }

      /* Animações */
      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(30px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .container:nth-child(1) {
        animation-delay: 0.1s;
      }
      .container:nth-child(2) {
        animation-delay: 0.2s;
      }
      .container:nth-child(3) {
        animation-delay: 0.3s;
      }
    </style>
  </head>
  <body>
    <!-- Preview de imagem -->
    <div id="imagePreview" class="image-preview">
      <button class="preview-close" onclick="closePreview()">&times;</button>
      <div class="preview-content">
        <div class="preview-loading">
          <div class="loading-spinner"></div>
          <div>Carregando imagem...</div>
        </div>
        <div class="preview-loaded" style="display: none;">
          <div class="preview-header" id="previewTitle"></div>
          <img class="preview-image" id="previewImg" alt="Preview da imagem">
          <div class="preview-info">
            <div id="previewInfo"></div>
            <div class="preview-coords" id="previewCoords"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Loading para zonas de drone -->
    <div id="droneLoading" class="drone-loading">
      <div class="loading-spinner"></div>
      <div>Carregando zonas de drone...</div>
    </div>

    <div class="main-container">
      <div class="container">
        <h1>📷 Conversor de Imagens Georreferenciadas para KML</h1>

        <div class="note">
          <p>
            <strong>Nota:</strong> Este sistema extrai coordenadas GPS de fotos e
            gera um arquivo KML compatível com Google Earth, QGIS e outros softwares GIS. Além disso, você pode renomear as fotos diretamente no mapa e baixar um ZIP com os arquivos renomeados.
            <br><strong>✨ Novidade:</strong> Passe o mouse sobre os marcadores no mapa por 2 segundos para ver um preview da imagem!
            <br><strong>🛣️ Integração DNIT:</strong> Clique nos marcadores para ver informações das rodovias próximas automaticamente!
            <br><strong>🚁 Zonas de Drone:</strong> Ative o toggle "Zonas de Drone" no mapa para visualizar áreas permitidas e restritas para voo de drones!
            <br><strong>📂 Importação KML:</strong> Importe arquivos KML existentes para combinar com suas fotos georreferenciadas!
          </p>
        </div>

        <div id="dropZone">
          <h3>📁 Arraste e solte imagens aqui</h3>
          <p>ou</p>
          <input
            type="file"
            id="fileInput"
            multiple
            accept="image/*"
            style="display: none"
          />
          <button onclick="document.getElementById('fileInput').click()">
            📂 Selecionar Imagens
          </button>
          <button onclick="importKMLFile()" style="background: linear-gradient(45deg, #9b59b6, #8e44ad);">
            📥 Importar KML
          </button>
        </div>

        <div class="progress-bar" style="display: none">
          <div class="progress" style="width: 0%">0%</div>
        </div>

        <h2>📍 Pontos Extraídos</h2>
        <div id="stats">
          <p>📊 Total de imagens: <span id="totalImages">0</span></p>
          <p>🗺️ Imagens com geolocalização: <span id="geoImages">0</span></p>
          <p>📥 Pontos importados do KML: <span id="importedPoints">0</span></p>
          <p>✏️ Imagens renomeadas: <span id="renamedImages">0</span></p>
        </div>

        <table id="resultsTable">
          <thead>
            <tr>
              <th>Nome do Arquivo</th>
              <th>Latitude</th>
              <th>Longitude</th>
              <th>Data/Hora</th>
            </tr>
          </thead>
          <tbody id="resultsBody">
            <!-- Resultados serão adicionados aqui -->
          </tbody>
        </table>

        <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
          <button id="downloadKmlBtn" disabled>💾 Baixar KML</button>
          <button id="downloadCsvBtn" disabled>📊 Baixar CSV</button>
          <button id="downloadZipBtn" class="btn-zip" disabled>📦 Baixar ZIP com Fotos</button>
        </div>
      </div>
    </div>

    <div class="map-container">
      <div class="map-header">
        <h2>🗺️ Mapa de Pontos</h2>
        <div class="map-controls">
          <select id="layerSelector">
            <option value="osm">OpenStreetMap</option>
            <option value="satellite">Satélite (Esri)</option>
            <option value="topo">Topográfico</option>
            <option value="dark">Modo Escuro</option>
          </select>
          <div class="drone-toggle" id="droneToggle">
            <span class="drone-icon">🚁</span>
            <span>Zonas de Drone</span>
          </div>
          <button id="maxZoomBtn">🔍 Zoom Máximo</button>
        </div>
      </div>
      <div id="map">
        <!-- Legenda das zonas de drone -->
        <div class="drone-legend" id="droneLegend">
          <h4>🚁 Zonas de Drone</h4>
          <div class="legend-item">
            <div class="legend-color prohibited"></div>
            <span>Proibido (0-5km aeroportos)</span>
          </div>
          <div class="legend-item">
            <div class="legend-color restricted"></div>
            <span>Restrito (5-10km aeroportos)</span>
          </div>
          <div class="legend-item">
            <div class="legend-color airport"></div>
            <span>Aeroportos/Helipontos</span>
          </div>
          <div class="legend-item">
            <div class="legend-color permitted"></div>
            <span>Permitido (áreas rurais)</span>
          </div>
        </div>
      </div>
    </div>

    <div class="main-container">
      <footer class="footer">
        <p><span class="zenith-brand">ZenithSolutions</span> - OAE Support</p>
        <p>&copy; 2025 Ferramentas Topográficas Profissionais</p>
      </footer>
    </div>

    <script>
      // Versão: 4.1
      
      // Variáveis globais
      let imagePoints = [];
      let importedPoints = [];
      let originalFiles = new Map();
      let imageDataMap = new Map();
      let renamedFiles = new Map();
      let processedImages = 0;
      let imagesWithGeo = 0;
      let totalImages = 0;
      let importedCount = 0;
      let map;
      let markersLayer;
      let droneZonesLayer;
      let currentTileLayer;
      let previewTimeout;
      let isPreviewOpen = false;
      let rodoviaCache = new Map();
      let droneZonesActive = false;
      let droneDataCache = new Map();
      let airportCache = new Map();

      // Elementos DOM
      const dropZone = document.getElementById("dropZone");
      const fileInput = document.getElementById("fileInput");
      const resultsBody = document.getElementById("resultsBody");
      const downloadKmlBtn = document.getElementById("downloadKmlBtn");
      const downloadCsvBtn = document.getElementById("downloadCsvBtn");
      const downloadZipBtn = document.getElementById("downloadZipBtn");
      const progressBar = document.querySelector(".progress-bar");
      const progress = document.querySelector(".progress");
      const layerSelector = document.getElementById("layerSelector");
      const maxZoomBtn = document.getElementById("maxZoomBtn");
      const imagePreview = document.getElementById("imagePreview");
      const droneToggle = document.getElementById("droneToggle");
      const droneLegend = document.getElementById("droneLegend");
      const droneLoading = document.getElementById("droneLoading");

      // FUNÇÃO PARA IMPORTAR KML - FUNCIONAL
      window.importKMLFile = function() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.kml';
        input.style.display = 'none';
        document.body.appendChild(input);
        
        input.addEventListener('change', function(e) {
          const file = e.target.files[0];
          if (!file) {
            document.body.removeChild(input);
            return;
          }
          
          if (!file.name.toLowerCase().endsWith('.kml')) {
            alert('Por favor, selecione um arquivo KML válido.');
            document.body.removeChild(input);
            return;
          }
          
          const reader = new FileReader();
          reader.onload = function(event) {
            try {
              const kmlContent = event.target.result;
              const points = parseKML(kmlContent);
              
              if (points.length > 0) {
                // Adicionar pontos importados
                importedPoints.push(...points);
                importedCount = importedPoints.length;
                
                // Atualizar interface
                document.getElementById("importedPoints").textContent = importedCount;
                updateResultsTable();
                
                // Habilitar botões
                if (imagePoints.length + importedPoints.length > 0) {
                  downloadKmlBtn.disabled = false;
                  downloadCsvBtn.disabled = false;
                }
                
                // Atualizar mapa
                plotPointsOnMap();
                
                alert(`Sucesso! ${points.length} pontos importados do KML.`);
              } else {
                alert('Nenhum ponto válido encontrado no arquivo KML.');
              }
            } catch (error) {
              console.error('Erro:', error);
              alert('Erro ao processar arquivo KML: ' + error.message);
            }
            
            document.body.removeChild(input);
          };
          
          reader.onerror = function() {
            alert('Erro ao ler o arquivo.');
            document.body.removeChild(input);
          };
          
          reader.readAsText(file);
        });
        
        input.click();
      };

      // FUNÇÃO PARA PARSEAR KML - FUNCIONAL
      function parseKML(kmlContent) {
        try {
          const parser = new DOMParser();
          const kmlDoc = parser.parseFromString(kmlContent, "text/xml");
          
          // Verificar erros de parsing
          const parseError = kmlDoc.querySelector("parsererror");
          if (parseError) {
            throw new Error("Arquivo KML inválido");
          }
          
          const points = [];
          const placemarks = kmlDoc.querySelectorAll("Placemark");
          
          placemarks.forEach((placemark, index) => {
            const nameEl = placemark.querySelector("name");
            const coordsEl = placemark.querySelector("coordinates");
            
            if (coordsEl) {
              const coordsText = coordsEl.textContent.trim();
              // Formato KML: longitude,latitude,altitude
              const coords = coordsText.split(',');
              
              if (coords.length >= 2) {
                const lng = parseFloat(coords[0].trim());
                const lat = parseFloat(coords[1].trim());
                
                if (!isNaN(lat) && !isNaN(lng) && 
                    lat >= -90 && lat <= 90 && 
                    lng >= -180 && lng <= 180) {
                  
                  const name = nameEl ? nameEl.textContent.trim() : `Ponto_Importado_${index + 1}`;
                  const descEl = placemark.querySelector("description");
                  const description = descEl ? descEl.textContent : '';
                  
                  // Tentar extrair data/hora da descrição
                  let datetime = null;
                  const dateMatch = description.match(/(\d{4}[-\/]\d{2}[-\/]\d{2})/);
                  if (dateMatch) {
                    datetime = dateMatch[1];
                  }
                  
                  points.push({
                    filename: name,
                    latitude: lat,
                    longitude: lng,
                    datetime: datetime,
                    imported: true,
                    description: description
                  });
                }
              }
            }
          });
          
          return points;
        } catch (error) {
          throw new Error('Erro ao processar KML: ' + error.message);
        }
      }

      // Função para parsear arquivo KML
      function parseKML(kmlContent) {
        try {
          console.log('Iniciando parse do KML');
          const parser = new DOMParser();
          const kmlDoc = parser.parseFromString(kmlContent, "text/xml");
          
          // Verificar se há erros no XML
          const parseError = kmlDoc.getElementsByTagName("parsererror");
          if (parseError.length > 0) {
            console.error('Erro de parse XML:', parseError[0].textContent);
            throw new Error("XML inválido: " + parseError[0].textContent);
          }
          
          const placemarks = kmlDoc.getElementsByTagName("Placemark");
          console.log('Placemarks encontrados:', placemarks.length);
          const points = [];
          
          for (let i = 0; i < placemarks.length; i++) {
            const placemark = placemarks[i];
            const nameElement = placemark.getElementsByTagName("name")[0];
            
            // Tentar encontrar coordenadas em diferentes estruturas
            let coordinatesElement = null;
            const pointElement = placemark.getElementsByTagName("Point")[0];
            
            if (pointElement) {
              coordinatesElement = pointElement.getElementsByTagName("coordinates")[0];
            }
            
            // Se não encontrar Point, tentar LineString (alguns KMLs usam isso)
            if (!coordinatesElement) {
              const lineElement = placemark.getElementsByTagName("LineString")[0];
              if (lineElement) {
                coordinatesElement = lineElement.getElementsByTagName("coordinates")[0];
              }
            }
            
            // Se não encontrar ainda, tentar Polygon
            if (!coordinatesElement) {
              const polygonElement = placemark.getElementsByTagName("Polygon")[0];
              if (polygonElement) {
                const outerBoundary = polygonElement.getElementsByTagName("outerBoundaryIs")[0];
                if (outerBoundary) {
                  const linearRing = outerBoundary.getElementsByTagName("LinearRing")[0];
                  if (linearRing) {
                    coordinatesElement = linearRing.getElementsByTagName("coordinates")[0];
                  }
                }
              }
            }
            
            if (coordinatesElement) {
              const coordsText = coordinatesElement.textContent.trim();
              console.log('Coordenadas encontradas:', coordsText);
              
              // Separar por espaços ou quebras de linha, depois por vírgula
              const coordPairs = coordsText.split(/[\s\n]+/).filter(pair => pair.trim());
              const firstCoordPair = coordPairs[0];
              
              if (firstCoordPair) {
                const coords = firstCoordPair.split(',');
                console.log('Coords splitadas:', coords);
                
                if (coords.length >= 2) {
                  const lng = parseFloat(coords[0]);
                  const lat = parseFloat(coords[1]);
                  console.log('Lat:', lat, 'Lng:', lng);
                  
                  if (isValidCoordinate(lat, lng)) {
                    const name = nameElement ? nameElement.textContent.trim() : `Ponto_Importado_${i + 1}`;
                    
                    // Extrair dados adicionais da descrição se houver
                    const descElement = placemark.getElementsByTagName("description")[0];
                    let description = '';
                    let datetime = null;
                    
                    if (descElement) {
                      description = descElement.textContent;
                      // Tentar extrair data/hora da descrição
                      const dateMatch = description.match(/Data\/Hora:\s*([^\n<]+)/);
                      if (dateMatch) {
                        datetime = dateMatch[1].trim();
                      }
                    }
                    
                    const point = {
                      filename: name,
                      latitude: lat,
                      longitude: lng,
                      datetime: datetime,
                      imported: true,
                      description: description
                    };
                    
                    console.log('Ponto adicionado:', point);
                    points.push(point);
                  } else {
                    console.warn('Coordenadas inválidas:', lat, lng);
                  }
                }
              }
            } else {
              console.warn('Nenhuma coordenada encontrada no placemark', i);
            }
          }
          
          console.log('Total de pontos parseados:', points.length);
          return points;
        } catch (error) {
          console.error('Erro ao parsear KML:', error);
          throw error;
        }
      }

      // Função para gerar arquivo KML
      function generateKML() {
        const allPoints = [...imagePoints, ...importedPoints];
        
        if (allPoints.length === 0) return null;
        
        let kmlContent = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>Pontos Georreferenciados</name>
    <description>Arquivo KML gerado pelo Conversor de Imagens Georreferenciadas - ZenithSolutions OAE Support</description>
    
    <!-- Estilos para diferentes tipos de zona -->
    <Style id="prohibited">
      <IconStyle>
        <color>ff0000ff</color>
        <scale>1.2</scale>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/pushpin/red-pushpin.png</href>
        </Icon>
      </IconStyle>
    </Style>
    
    <Style id="restricted">
      <IconStyle>
        <color>ff00ffff</color>
        <scale>1.2</scale>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png</href>
        </Icon>
      </IconStyle>
    </Style>
    
    <Style id="permitted">
      <IconStyle>
        <color>ff00ff00</color>
        <scale>1.2</scale>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/pushpin/grn-pushpin.png</href>
        </Icon>
      </IconStyle>
    </Style>
    
    <Style id="imported">
      <IconStyle>
        <color>ffff00ff</color>
        <scale>1.0</scale>
        <Icon>
          <href>http://maps.google.com/mapfiles/kml/pushpin/purple-pushpin.png</href>
        </Icon>
      </IconStyle>
    </Style>
`;

        allPoints.forEach((point, index) => {
          const currentName = renamedFiles.get(point.filename) || point.filename;
          const isRenamed = renamedFiles.has(point.filename);
          const isImported = point.imported || false;
          
          // Determinar estilo baseado na zona de drone ou se foi importado
          let styleUrl = '#permitted';
          if (isImported) {
            styleUrl = '#imported';
          } else if (point.droneZone) {
            switch (point.droneZone.zona) {
              case 'prohibited':
                styleUrl = '#prohibited';
                break;
              case 'restricted':
                styleUrl = '#restricted';
                break;
              default:
                styleUrl = '#permitted';
            }
          }
          
          // Construir descrição detalhada
          let description = `<![CDATA[
<h3>${currentName}</h3>
<p><strong>Coordenadas:</strong><br/>
Latitude: ${point.latitude.toFixed(8)}<br/>
Longitude: ${point.longitude.toFixed(8)}</p>
`;

          if (point.datetime) {
            description += `<p><strong>Data/Hora:</strong> ${point.datetime}</p>`;
          }
          
          if (isRenamed && !isImported) {
            description += `<p><strong>Nome Original:</strong> ${point.filename}</p>`;
            description += `<p><strong>Status:</strong> Arquivo renomeado</p>`;
          }
          
          if (isImported) {
            description += `<p><strong>Tipo:</strong> Ponto importado de KML</p>`;
          } else {
            description += `<p><strong>Tipo:</strong> Extraído de imagem georreferenciada</p>`;
          }
          
          // Informações da zona de drone
          if (point.droneZone) {
            const zoneIcon = point.droneZone.zona === 'prohibited' ? '🚫' : 
                            point.droneZone.zona === 'restricted' ? '⚠️' : '✅';
            description += `
<p><strong>${zoneIcon} Zona de Drone:</strong> ${point.droneZone.descricao}</p>`;
            
            if (point.droneZone.aeroporto) {
              description += `<p><strong>Aeroporto mais próximo:</strong> ${point.droneZone.aeroporto.name} (${point.droneZone.distancia.toFixed(1)}km)</p>`;
            }
          }
          
          // Informações de rodovias (se disponível no cache)
          const coordKey = `${point.latitude.toFixed(6)}_${point.longitude.toFixed(6)}`;
          if (rodoviaCache.has(coordKey)) {
            const rodoviaData = rodoviaCache.get(coordKey);
            if (rodoviaData && rodoviaData.rodovias && rodoviaData.rodovias.length > 0) {
              description += `<p><strong>🛣️ Rodovias próximas:</strong></p>`;
              rodoviaData.rodovias.forEach(r => {
                description += `<p style="margin-left: 10px;">• BR-${r.br} - Km ${r.km} (${r.uf})</p>`;
              });
            }
          }
          
          description += `]]>`;
          
          kmlContent += `
    <Placemark>
      <name>${escapeXml(currentName)}</name>
      <description>${description}</description>
      <styleUrl>${styleUrl}</styleUrl>
      <Point>
        <coordinates>${point.longitude},${point.latitude},0</coordinates>
      </Point>
    </Placemark>`;
        });
        
        kmlContent += `
  </Document>
</kml>`;
        
        return kmlContent;
      }

      // Função para escapar caracteres especiais XML
      function escapeXml(text) {
        return text.replace(/[<>&'"]/g, function(match) {
          switch (match) {
            case '<': return '&lt;';
            case '>': return '&gt;';
            case '&': return '&amp;';
            case "'": return '&apos;';
            case '"': return '&quot;';
            default: return match;
          }
        });
      }

      // Função para combinar pontos importados com pontos das imagens
      function combineAllPoints() {
        return [...imagePoints, ...importedPoints];
      }
      async function consultarRodoviasDNIT(lat, lng) {
        try {
          const dataRef = new Date().toISOString().split('T')[0];
          const url = `https://servicos.dnit.gov.br/sgplan/apigeo/rotas/localizarkm?lng=${lng}&lat=${lat}&r=250&data=${dataRef}`;
          
          const response = await fetch(url, {
            method: 'GET',
            headers: {
              'Accept': 'application/json',
            },
            mode: 'cors'
          });
          
          if (!response.ok) {
            throw new Error(`Erro na API DNIT: ${response.status}`);
          }
          
          const data = await response.json();
          return data;
        } catch (error) {
          console.error(`Erro ao consultar DNIT: ${error.message}`);
          return null;
        }
      }

      // Função para consultar aeroportos via Overpass API
      async function consultarAeroportosOverpass(bbox) {
        const query = `
          [out:json][timeout:30];
          (
            node["aeroway"="aerodrome"](${bbox});
            node["aeroway"="helipad"](${bbox});
            node["aeroway"="heliport"](${bbox});
            way["aeroway"="aerodrome"](${bbox});
            relation["aeroway"="aerodrome"](${bbox});
          );
          out center;
        `;

        try {
          const response = await fetch('https://overpass-api.de/api/interpreter', {
            method: 'POST',
            body: query,
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded'
            }
          });

          if (!response.ok) {
            throw new Error(`Erro na API Overpass: ${response.status}`);
          }

          const data = await response.json();
          return processarAeroportos(data.elements);
        } catch (error) {
          console.error('Erro ao consultar aeroportos:', error);
          return [];
        }
      }

      // Processar dados de aeroportos
      function processarAeroportos(elements) {
        const aeroportos = [];
        
        elements.forEach(element => {
          let lat, lng, name, type;
          
          if (element.type === 'node') {
            lat = element.lat;
            lng = element.lon;
          } else if (element.center) {
            lat = element.center.lat;
            lng = element.center.lon;
          } else {
            return;
          }

          name = element.tags?.name || element.tags?.ref || 'Sem nome';
          type = element.tags?.aeroway || 'aerodrome';
          
          aeroportos.push({
            lat,
            lng,
            name,
            type,
            icao: element.tags?.icao || '',
            iata: element.tags?.iata || ''
          });
        });

        return aeroportos;
      }

      // Função para determinar zona de restrição baseada na distância de aeroportos
      function determinarZonaRestricao(lat, lng, aeroportos) {
        let menorDistancia = Infinity;
        let aeroportoMaisProximo = null;

        aeroportos.forEach(aeroporto => {
          const distancia = calcularDistanciaHaversine(lat, lng, aeroporto.lat, aeroporto.lng);
          if (distancia < menorDistancia) {
            menorDistancia = distancia;
            aeroportoMaisProximo = aeroporto;
          }
        });

        if (menorDistancia <= 5) {
          return {
            zona: 'prohibited',
            cor: 'rgba(231, 76, 60, 0.7)',
            descricao: 'Zona Proibida',
            aeroporto: aeroportoMaisProximo,
            distancia: menorDistancia
          };
        }
        
        if (menorDistancia <= 10) {
          return {
            zona: 'restricted',
            cor: 'rgba(241, 196, 15, 0.7)',
            descricao: 'Zona Restrita',
            aeroporto: aeroportoMaisProximo,
            distancia: menorDistancia
          };
        }

        return {
          zona: 'permitted',
          cor: 'rgba(46, 204, 113, 0.7)',
          descricao: 'Zona Permitida',
          aeroporto: aeroportoMaisProximo,
          distancia: menorDistancia
        };
      }

      // Calcular distância Haversine em km
      function calcularDistanciaHaversine(lat1, lng1, lat2, lng2) {
        const R = 6371;
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLng = (lng2 - lng1) * Math.PI / 180;
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                  Math.sin(dLng / 2) * Math.sin(dLng / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      // Toggle das zonas de drone
      function toggleDroneZones() {
        droneZonesActive = !droneZonesActive;
        
        if (droneZonesActive) {
          droneToggle.classList.add('active');
          droneLegend.classList.add('active');
          carregarZonasDrone();
        } else {
          droneToggle.classList.remove('active');
          droneLegend.classList.remove('active');
          if (droneZonesLayer) {
            droneZonesLayer.clearLayers();
          }
        }
      }

      // Carregar zonas de drone
      async function carregarZonasDrone() {
        if (!map) return;

        droneLoading.classList.add('active');

        try {
          const bounds = map.getBounds();
          const bbox = `${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}`;
          
          // Criar cache key baseado na bbox
          const cacheKey = bbox;
          
          let aeroportos;
          if (airportCache.has(cacheKey)) {
            aeroportos = airportCache.get(cacheKey);
          } else {
            aeroportos = await consultarAeroportosOverpass(bbox);
            airportCache.set(cacheKey, aeroportos);
          }

          // Limpar camada anterior
          if (!droneZonesLayer) {
            droneZonesLayer = L.layerGroup().addTo(map);
          } else {
            droneZonesLayer.clearLayers();
          }

          // Adicionar marcadores de aeroportos
          aeroportos.forEach(aeroporto => {
            const airportIcon = L.divIcon({
              className: 'airport-marker',
              html: `<div style="background: rgba(155, 89, 182, 0.9); color: white; padding: 4px 8px; border-radius: 15px; font-size: 12px; font-weight: bold; text-align: center; min-width: 40px;">✈️</div>`,
              iconSize: [50, 25],
              iconAnchor: [25, 12]
            });

            const marker = L.marker([aeroporto.lat, aeroporto.lng], { icon: airportIcon });
            
            // Popup com informações do aeroporto
            const popupContent = `
              <div style="min-width: 200px;">
                <h4>✈️ ${aeroporto.name}</h4>
                <p><strong>Tipo:</strong> ${aeroporto.type === 'helipad' || aeroporto.type === 'heliport' ? 'Heliponto' : 'Aeroporto'}</p>
                ${aeroporto.icao ? `<p><strong>ICAO:</strong> ${aeroporto.icao}</p>` : ''}
                ${aeroporto.iata ? `<p><strong>IATA:</strong> ${aeroporto.iata}</p>` : ''}
                <p><strong>Coordenadas:</strong><br>
                Lat: ${aeroporto.lat.toFixed(6)}<br>
                Lng: ${aeroporto.lng.toFixed(6)}</p>
                <div style="margin-top: 10px; padding: 8px; background: #fff3cd; border-radius: 5px; border: 1px solid #ffeaa7;">
                  <strong>⚠️ Zonas de Restrição:</strong><br>
                  <span style="color: #e74c3c;">0-5km:</span> Proibido<br>
                  <span style="color: #f1c40f;">5-10km:</span> Restrito
                </div>
              </div>
            `;
            
            marker.bindPopup(popupContent);
            droneZonesLayer.addLayer(marker);

            // Adicionar círculos de restrição
            const circle5km = L.circle([aeroporto.lat, aeroporto.lng], {
              radius: 5000,
              fillColor: 'rgba(231, 76, 60, 0.3)',
              color: 'rgba(231, 76, 60, 0.8)',
              weight: 2,
              fillOpacity: 0.3
            });

            const circle10km = L.circle([aeroporto.lat, aeroporto.lng], {
              radius: 10000,
              fillColor: 'rgba(241, 196, 15, 0.2)',
              color: 'rgba(241, 196, 15, 0.6)',
              weight: 2,
              fillOpacity: 0.2
            });

            droneZonesLayer.addLayer(circle10km);
            droneZonesLayer.addLayer(circle5km);
          });

          // Se há pontos de imagem, verificar zonas para cada um
          if (imagePoints.length > 0) {
            atualizarZonasParaPontos(aeroportos);
          }

        } catch (error) {
          console.error('Erro ao carregar zonas de drone:', error);
        } finally {
          droneLoading.classList.remove('active');
        }
      }

      // Atualizar zonas para pontos existentes
      function atualizarZonasParaPontos(aeroportos) {
        imagePoints.forEach((point, index) => {
          const zona = determinarZonaRestricao(point.latitude, point.longitude, aeroportos);
          point.droneZone = zona;
        });
      }

      // Processar dados das rodovias
      function processarDadosRodovias(dadosDNIT) {
        if (!dadosDNIT || !Array.isArray(dadosDNIT)) {
          return { rodovias: [] };
        }
        
        const rodovias = dadosDNIT.map(item => ({
          br: item.br || 'N/A',
          km: item.km || '0',
          uf: item.uf || 'N/A',
          tipoTrecho: item.tipoTrecho || 'N/A',
          versao: item.versao || 'N/A'
        }));
        
        return { rodovias };
      }

      // Função para gerar HTML das informações de rodovias (formato compacto)
      function gerarHtmlRodovias(dadosProcessados, coordenadas) {
        if (!dadosProcessados || !dadosProcessados.rodovias || dadosProcessados.rodovias.length === 0) {
          return `
            <div style="margin-top: 10px; padding: 6px; background: #f8f9fa; border-radius: 4px; border: 1px solid #dee2e6;">
              <div style="font-size: 11px; color: #6c757d;">
                Nenhuma rodovia encontrada
              </div>
            </div>
          `;
        }
        
        const rodovias = dadosProcessados.rodovias;
        
        // Lista compacta das rodovias
        const listaRodovias = rodovias.map(rodovia => {
          const isKmZero = parseFloat(rodovia.km) === 0;
          const alertIcon = isKmZero ? ' ⚠️' : '';
          
          return `BR-${rodovia.br} (Km ${rodovia.km})${alertIcon}`;
        }).join(' • ');
        
        return `
          <div style="margin-top: 10px; padding: 6px; background: #f8f9fa; border-radius: 4px; border: 1px solid #dee2e6;">
            <div style="font-size: 11px; color: #6c757d; margin-bottom: 2px;">Rodovias:</div>
            <div style="font-size: 12px; color: #495057;">${listaRodovias}</div>
          </div>
        `;
      }

      // Definir diferentes camadas de tile com zoom máximo aprimorado
      const tileLayers = {
        osm: {
          url: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
          options: {
            attribution: "© OpenStreetMap contributors",
            maxZoom: 19
          }
        },
        satellite: {
          url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
          options: {
            attribution: "© Esri, Maxar, GeoEye, Earthstar Geographics",
            maxZoom: 23
          }
        },
        topo: {
          url: "https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png",
          options: {
            attribution: "© OpenTopoMap (CC-BY-SA)",
            maxZoom: 17
          }
        },
        dark: {
          url: "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png",
          options: {
            attribution: "© CARTO, © OpenStreetMap contributors",
            maxZoom: 20
          }
        }
      };

      // Inicializar o mapa
      function initMap() {
        // Criar o mapa centrado no Brasil com configurações aprimoradas
        map = L.map("map", {
          maxZoom: 25,
          minZoom: 2,
          zoomControl: true,
          worldCopyJump: true
        }).setView([-15.7942, -47.8825], 4);

        // Adicionar camada inicial (OpenStreetMap)
        switchTileLayer('osm');

        // Criar camada para os marcadores
        markersLayer = L.layerGroup().addTo(map);

        // Event listeners
        layerSelector.addEventListener('change', function() {
          switchTileLayer(this.value);
        });

        maxZoomBtn.addEventListener('click', function() {
          if (imagePoints.length > 0) {
            let latSum = 0, lngSum = 0;
            imagePoints.forEach(point => {
              latSum += point.latitude;
              lngSum += point.longitude;
            });
            const centerLat = latSum / imagePoints.length;
            const centerLng = lngSum / imagePoints.length;
            
            map.setView([centerLat, centerLng], map.getMaxZoom());
          } else {
            map.setZoom(map.getMaxZoom());
          }
        });

        // Event listener para toggle de zonas de drone
        droneToggle.addEventListener('click', toggleDroneZones);

        // Event listener para recarregar zonas quando o mapa move
        map.on('moveend', function() {
          if (droneZonesActive) {
            carregarZonasDrone();
          }
        });

        // Se já temos pontos, plotá-los
        if (imagePoints.length > 0) {
          plotPointsOnMap();
        }
      }

      // Trocar camada de tile
      function switchTileLayer(layerType) {
        if (currentTileLayer) {
          map.removeLayer(currentTileLayer);
        }

        const layer = tileLayers[layerType];
        currentTileLayer = L.tileLayer(layer.url, layer.options).addTo(map);
        map.options.maxZoom = layer.options.maxZoom;
      }

      // Plotar pontos no mapa
      function plotPointsOnMap() {
        if (!map || !markersLayer) return;

        markersLayer.clearLayers();

        const allPoints = combineAllPoints();
        if (allPoints.length === 0) return;

        let bounds = L.latLngBounds();

        allPoints.forEach((point, index) => {
          const currentName = renamedFiles.get(point.filename) || point.filename;
          const isRenamed = renamedFiles.has(point.filename);
          const isImported = point.imported || false;
          
          // Criar ícone personalizado baseado na zona de drone ou se foi importado
          let markerIcon;
          if (isImported) {
            markerIcon = L.divIcon({
              className: 'custom-marker',
              html: `<div style="background: #9b59b6; width: 25px; height: 25px; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 10px rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; font-size: 14px;">📍</div>`,
              iconSize: [25, 25],
              iconAnchor: [12.5, 12.5]
            });
          } else if (droneZonesActive && point.droneZone) {
            const zoneColor = point.droneZone.zona === 'prohibited' ? '#e74c3c' : 
                             point.droneZone.zona === 'restricted' ? '#f39c12' : '#27ae60';
            
            markerIcon = L.divIcon({
              className: 'custom-marker',
              html: `<div style="background: ${zoneColor}; width: 25px; height: 25px; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 10px rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; font-size: 14px;">📷</div>`,
              iconSize: [25, 25],
              iconAnchor: [12.5, 12.5]
            });
          } else {
            markerIcon = new L.Icon.Default();
          }
          
          const marker = L.marker([point.latitude, point.longitude], { icon: markerIcon });
          
          // Criar popup - diferente para pontos importados
          const popup = L.popup({
            maxWidth: 350,
            minWidth: 320
          });
          
          if (isImported) {
            popup.setContent(createImportedPopupContent(point, index));
          } else {
            popup.setContent(createPopupContent(point, index, currentName, isRenamed));
          }
          
          marker.bindPopup(popup);
          
          // Event listener para quando o popup é aberto (só para pontos de imagem)
          if (!isImported) {
            marker.on('popupopen', function(e) {
              setTimeout(() => {
                consultarRodoviasParaPopup(point, index);
              }, 100);
            });

            // Adicionar eventos de preview da imagem
            marker.on('mouseover', function(e) {
              if (!isPreviewOpen) {
                previewTimeout = setTimeout(() => {
                  showImagePreview(point, currentName, isRenamed);
                }, 2000);
              }
            });

            marker.on('mouseout', function(e) {
              if (previewTimeout) {
                clearTimeout(previewTimeout);
                previewTimeout = null;
              }
            });
          }

          markersLayer.addLayer(marker);
          bounds.extend([point.latitude, point.longitude]);
        });

        // Ajustar o zoom para mostrar todos os pontos
        if (allPoints.length > 0) {
          map.fitBounds(bounds, { padding: [20, 20] });
        }

        // Se zonas de drone estão ativas, recarregar
        if (droneZonesActive) {
          setTimeout(() => {
            carregarZonasDrone();
          }, 500);
        }
      }

      // Criar conteúdo do popup para pontos importados
      function createImportedPopupContent(point, index) {
        let droneInfo = '';
        if (droneZonesActive && point.droneZone) {
          const zoneIcon = point.droneZone.zona === 'prohibited' ? '🚫' : 
                          point.droneZone.zona === 'restricted' ? '⚠️' : '✅';
          
          droneInfo = `
            <div style="margin-top: 10px; padding: 8px; background: rgba(${point.droneZone.zona === 'prohibited' ? '231, 76, 60' : point.droneZone.zona === 'restricted' ? '241, 196, 15' : '46, 204, 113'}, 0.1); border-radius: 5px; border: 1px solid rgba(${point.droneZone.zona === 'prohibited' ? '231, 76, 60' : point.droneZone.zona === 'restricted' ? '241, 196, 15' : '46, 204, 113'}, 0.3);">
              <div style="font-size: 12px; color: #495057; margin-bottom: 2px;"><strong>${zoneIcon} Zona de Drone:</strong></div>
              <div style="font-size: 11px; color: #6c757d;">${point.droneZone.descricao}</div>
              ${point.droneZone.aeroporto ? `<div style="font-size: 10px; color: #6c757d;">Aeroporto: ${point.droneZone.aeroporto.name} (${point.droneZone.distancia.toFixed(1)}km)</div>` : ''}
            </div>
          `;
        }
        
        return `
          <div style="width: 320px;">
            <h4>📍 ${point.filename} <span style="color: #9b59b6; font-size: 12px;">(Importado)</span></h4>
            <p><strong>Coordenadas:</strong><br>
            Lat: ${point.latitude.toFixed(8)}<br>
            Lng: ${point.longitude.toFixed(8)}</p>
            ${point.datetime ? `<p><strong>Data/Hora:</strong><br>${point.datetime}</p>` : ''}
            ${point.description ? `<p><strong>Descrição:</strong><br>${point.description}</p>` : ''}
            
            ${droneInfo}
            
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd;">
              <div class="popup-buttons">
                <button class="popup-btn" onclick="map.setView([${point.latitude}, ${point.longitude}], map.getMaxZoom())">
                  🔍 Zoom Max
                </button>
                <button class="popup-btn danger" onclick="removeImportedPoint(${index})">
                  🗑️ Remover
                </button>
              </div>
            </div>
          </div>
        `;
      }

      // Mostrar preview da imagem
      function showImagePreview(point, currentName, isRenamed) {
        if (isPreviewOpen) return;

        isPreviewOpen = true;
        
        imagePreview.classList.add('loading');
        imagePreview.style.display = 'block';
        
        document.querySelector('.preview-loading').style.display = 'block';
        document.querySelector('.preview-loaded').style.display = 'none';

        const imageData = imageDataMap.get(point.filename);
        if (imageData) {
          const img = document.getElementById('previewImg');
          img.onload = function() {
            // Informações básicas
            let infoHtml = `${isRenamed ? `<div style="color: #7f8c8d; font-style: italic;">Original: ${point.filename}</div>` : ''}
               <div><strong>Data/Hora:</strong> ${point.datetime || "N/A"}</div>`;

            // Adicionar informação de zona de drone se disponível
            if (point.droneZone) {
              const zoneIcon = point.droneZone.zona === 'prohibited' ? '🚫' : 
                              point.droneZone.zona === 'restricted' ? '⚠️' : '✅';
              
              infoHtml += `
                <div style="margin-top: 10px; padding: 8px; background: rgba(${point.droneZone.zona === 'prohibited' ? '231, 76, 60' : point.droneZone.zona === 'restricted' ? '241, 196, 15' : '46, 204, 113'}, 0.1); border-radius: 5px; border: 1px solid rgba(${point.droneZone.zona === 'prohibited' ? '231, 76, 60' : point.droneZone.zona === 'restricted' ? '241, 196, 15' : '46, 204, 113'}, 0.3);">
                  <strong>${zoneIcon} Zona de Drone:</strong> ${point.droneZone.descricao}<br>
                  ${point.droneZone.aeroporto ? `<small>Aeroporto mais próximo: ${point.droneZone.aeroporto.name} (${point.droneZone.distancia.toFixed(1)}km)</small>` : ''}
                </div>
              `;
            }

            document.getElementById('previewTitle').innerHTML = 
              `📷 ${isRenamed ? '<span class="renamed-indicator">✏️ ' + currentName + '</span>' : currentName}`;
            
            document.getElementById('previewInfo').innerHTML = infoHtml;
            
            document.getElementById('previewCoords').innerHTML = 
              `<strong>Coordenadas:</strong><br>
               Latitude: ${point.latitude.toFixed(8)}<br>
               Longitude: ${point.longitude.toFixed(8)}`;

            document.querySelector('.preview-loading').style.display = 'none';
            document.querySelector('.preview-loaded').style.display = 'block';
            
            imagePreview.classList.remove('loading');
            imagePreview.classList.add('show');
          };
          
          img.onerror = function() {
            closePreview();
          };
          
          img.src = imageData;
        } else {
          closePreview();
        }
      }

      // Fechar preview
      function closePreview() {
        if (previewTimeout) {
          clearTimeout(previewTimeout);
          previewTimeout = null;
        }
        
        isPreviewOpen = false;
        imagePreview.classList.remove('show', 'loading');
        
        setTimeout(() => {
          if (!imagePreview.classList.contains('show')) {
            imagePreview.style.display = 'none';
          }
        }, 400);
      }

      // Event listeners para fechar preview
      imagePreview.addEventListener('click', function(e) {
        if (e.target === this) {
          closePreview();
        }
      });

      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && isPreviewOpen) {
          closePreview();
        }
      });

      // Criar conteúdo do popup
      function createPopupContent(point, index, currentName, isRenamed) {
        const fileNameWithoutExt = currentName.substring(0, currentName.lastIndexOf('.')) || currentName;
        const fileExt = currentName.substring(currentName.lastIndexOf('.')) || '';
        
        let droneInfo = '';
        if (droneZonesActive && point.droneZone) {
          const zoneIcon = point.droneZone.zona === 'prohibited' ? '🚫' : 
                          point.droneZone.zona === 'restricted' ? '⚠️' : '✅';
          
          droneInfo = `
            <div style="margin-top: 10px; padding: 8px; background: rgba(${point.droneZone.zona === 'prohibited' ? '231, 76, 60' : point.droneZone.zona === 'restricted' ? '241, 196, 15' : '46, 204, 113'}, 0.1); border-radius: 5px; border: 1px solid rgba(${point.droneZone.zona === 'prohibited' ? '231, 76, 60' : point.droneZone.zona === 'restricted' ? '241, 196, 15' : '46, 204, 113'}, 0.3);">
              <div style="font-size: 12px; color: #495057; margin-bottom: 2px;"><strong>${zoneIcon} Zona de Drone:</strong></div>
              <div style="font-size: 11px; color: #6c757d;">${point.droneZone.descricao}</div>
              ${point.droneZone.aeroporto ? `<div style="font-size: 10px; color: #6c757d;">Aeroporto: ${point.droneZone.aeroporto.name} (${point.droneZone.distancia.toFixed(1)}km)</div>` : ''}
            </div>
          `;
        }
        
        return `
          <div style="width: 320px;">
            <h4>📷 ${isRenamed ? '<span class="renamed-indicator">✏️ ' + currentName + '</span>' : currentName}</h4>
            ${isRenamed ? `<p class="original-name">Original: ${point.filename}</p>` : ''}
            <p><strong>Coordenadas:</strong><br>
            Lat: ${point.latitude.toFixed(8)}<br>
            Lng: ${point.longitude.toFixed(8)}</p>
            <p><strong>Data/Hora:</strong><br>
            ${point.datetime || "N/A"}</p>
            
            ${droneInfo}
            
            <div class="rename-section">
              <p><strong>Renomear arquivo:</strong></p>
              <input type="text" id="newName_${index}" class="rename-input" 
                     value="${fileNameWithoutExt}" placeholder="Novo nome do arquivo">
              <div class="popup-buttons">
                <button class="popup-btn success" onclick="renameFile(${index}, '${point.filename}', '${fileExt}')">
                  ✓ Renomear
                </button>
                <button class="popup-btn" onclick="map.setView([${point.latitude}, ${point.longitude}], map.getMaxZoom())">
                  🔍 Zoom Max
                </button>
                ${isRenamed ? `<button class="popup-btn danger" onclick="resetFileName('${point.filename}', ${index})">↶ Desfazer</button>` : ''}
              </div>
            </div>
            
            <!-- Seção de Rodovias -->
            <div id="rodoviaInfo_${index}">
              <div id="rodoviaLoading_${index}" style="margin-top: 10px; padding: 6px; background: #f8f9fa; border-radius: 4px; text-align: center;">
                <div style="display: inline-block; width: 12px; height: 12px; border: 2px solid #ddd; border-radius: 50%; border-top: 2px solid #6c757d; animation: spin 1s linear infinite; margin-right: 5px;"></div>
                <span style="font-size: 11px; color: #6c757d;">Consultando rodovias...</span>
              </div>
              <div id="rodoviaContent_${index}" style="display: none;"></div>
            </div>
          </div>
        `;
      }

      // Função chamada quando o popup é aberto para consultar rodovias
      async function consultarRodoviasParaPopup(point, index) {
        const coordKey = `${point.latitude.toFixed(6)}_${point.longitude.toFixed(6)}`;
        
        if (rodoviaCache.has(coordKey)) {
          exibirRodoviasNoPopup(rodoviaCache.get(coordKey), index, point);
          return;
        }
        
        try {
          const dadosDNIT = await consultarRodoviasDNIT(point.latitude, point.longitude);
          const dadosProcessados = processarDadosRodovias(dadosDNIT);
          
          rodoviaCache.set(coordKey, dadosProcessados);
          exibirRodoviasNoPopup(dadosProcessados, index, point);
          
        } catch (error) {
          console.error('Erro ao consultar rodovias:', error);
          exibirErroRodovias(index);
        }
      }

      // Função para exibir rodovias no popup
      function exibirRodoviasNoPopup(dadosProcessados, index, point) {
        const loadingDiv = document.getElementById(`rodoviaLoading_${index}`);
        const contentDiv = document.getElementById(`rodoviaContent_${index}`);
        
        if (loadingDiv) loadingDiv.style.display = 'none';
        if (contentDiv) {
          contentDiv.innerHTML = gerarHtmlRodovias(dadosProcessados, {
            lat: point.latitude,
            lng: point.longitude
          });
          contentDiv.style.display = 'block';
        }
      }

      // Função para exibir erro na consulta de rodovias
      function exibirErroRodovias(index) {
        const loadingDiv = document.getElementById(`rodoviaLoading_${index}`);
        const contentDiv = document.getElementById(`rodoviaContent_${index}`);
        
        if (loadingDiv) loadingDiv.style.display = 'none';
        if (contentDiv) {
          contentDiv.innerHTML = `
            <div style="padding: 10px; background: #ffebee; border: 1px solid #f44336; border-radius: 5px; text-align: center;">
              <div style="color: #d32f2f; font-size: 13px; font-weight: bold;">
                ❌ Erro ao consultar rodovias
              </div>
              <div style="color: #666; font-size: 11px; margin-top: 3px;">
                Verifique sua conexão com a internet
              </div>
            </div>
          `;
          contentDiv.style.display = 'block';
        }
      }

      // Função para renomear arquivo
      function renameFile(index, originalFilename, fileExt) {
        const newNameInput = document.getElementById(`newName_${index}`);
        const newName = newNameInput.value.trim();
        
        if (!newName) {
          alert('Por favor, insira um nome válido.');
          return;
        }
        
        const fullNewName = newName + fileExt;
        
        const existingNames = Array.from(renamedFiles.values());
        const originalNames = imagePoints.map(p => p.filename);
        
        if (existingNames.includes(fullNewName) || originalNames.includes(fullNewName)) {
          if (renamedFiles.get(originalFilename) !== fullNewName) {
            alert('Este nome já está being usado por outro arquivo.');
            return;
          }
        }
        
        renamedFiles.set(originalFilename, fullNewName);
        updateResultsTable();
        updateStats();
        plotPointsOnMap();
        downloadZipBtn.disabled = false;
        map.closePopup();
      }

      // Função para resetar nome do arquivo
      function resetFileName(originalFilename, index) {
        renamedFiles.delete(originalFilename);
        updateResultsTable();
        updateStats();
        plotPointsOnMap();
        
        if (renamedFiles.size === 0) {
          downloadZipBtn.disabled = true;
        }
        
        map.closePopup();
      }

      // Função para remover ponto importado
      function removeImportedPoint(index) {
        if (confirm('Tem certeza que deseja remover este ponto importado?')) {
          // Encontrar o ponto importado no array
          const allPoints = combineAllPoints();
          const imagePointsCount = imagePoints.length;
          
          if (index >= imagePointsCount) {
            const importedIndex = index - imagePointsCount;
            importedPoints.splice(importedIndex, 1);
            importedCount = importedPoints.length;
            
            // Atualizar estatísticas
            document.getElementById("importedPoints").textContent = importedCount;
            
            // Atualizar tabela
            updateResultsTable();
            
            // Replotar pontos
            plotPointsOnMap();
            
            // Fechar popup
            map.closePopup();
            
            // Verificar se ainda há pontos para habilitar/desabilitar botões
            const totalPoints = imagePoints.length + importedPoints.length;
            if (totalPoints === 0) {
              downloadKmlBtn.disabled = true;
              downloadCsvBtn.disabled = true;
            }
          }
        }
      }

      // Atualizar tabela de resultados (incluindo pontos importados)
      function updateResultsTable() {
        resultsBody.innerHTML = "";
        
        const allPoints = combineAllPoints();
        
        allPoints.forEach((point) => {
          const currentName = renamedFiles.get(point.filename) || point.filename;
          const isRenamed = renamedFiles.has(point.filename);
          const isImported = point.imported || false;
          
          const row = resultsBody.insertRow();
          
          const nameCell = row.insertCell(0);
          if (isImported) {
            nameCell.innerHTML = `<span style="color: #9b59b6;">${currentName}</span><br><small style="color: #9b59b6; font-style: italic;">(Importado do KML)</small>`;
          } else if (isRenamed) {
            nameCell.innerHTML = `<span class="renamed-indicator">${currentName}</span><br><small class="original-name">${point.filename}</small>`;
          } else {
            nameCell.textContent = currentName;
          }
          
          row.insertCell(1).textContent = point.latitude.toFixed(8);
          row.insertCell(2).textContent = point.longitude.toFixed(8);
          row.insertCell(3).textContent = point.datetime || "N/A";
        });
      }

      // Atualizar estatísticas
      function updateStats() {
        document.getElementById("renamedImages").textContent = renamedFiles.size;
        document.getElementById("importedPoints").textContent = importedCount;
      }

      // Atualizar zonas para todos os pontos (incluindo importados)
      function atualizarZonasParaTodos(aeroportos) {
        // Atualizar pontos das imagens
        imagePoints.forEach((point, index) => {
          const zona = determinarZonaRestricao(point.latitude, point.longitude, aeroportos);
          point.droneZone = zona;
        });
        
        // Atualizar pontos importados
        importedPoints.forEach((point, index) => {
          const zona = determinarZonaRestricao(point.latitude, point.longitude, aeroportos);
          point.droneZone = zona;
        });
      }

      // Setup de eventos
      dropZone.addEventListener("dragover", (e) => {
        e.preventDefault();
        dropZone.style.backgroundColor = "rgba(52, 152, 219, 0.2)";
      });

      dropZone.addEventListener("dragleave", (e) => {
        e.preventDefault();
        dropZone.style.backgroundColor = "rgba(52, 152, 219, 0.1)";
      });

      dropZone.addEventListener("drop", (e) => {
        e.preventDefault();
        dropZone.style.backgroundColor = "rgba(52, 152, 219, 0.1)";
        handleFiles(e.dataTransfer.files);
      });

      fileInput.addEventListener("change", (e) => {
        handleFiles(e.target.files);
      });

      // Função principal para processar os arquivos
      function handleFiles(files) {
        if (!files || files.length === 0) return;

        // Reset
        imagePoints = [];
        importedPoints = [];
        originalFiles.clear();
        imageDataMap.clear();
        renamedFiles.clear();
        rodoviaCache.clear();
        airportCache.clear();
        processedImages = 0;
        imagesWithGeo = 0;
        totalImages = files.length;
        importedCount = 0;
        resultsBody.innerHTML = "";

        document.getElementById("totalImages").textContent = totalImages;
        document.getElementById("geoImages").textContent = "0";
        document.getElementById("importedPoints").textContent = "0";
        document.getElementById("renamedImages").textContent = "0";

        progressBar.style.display = "block";
        progress.style.width = "0%";
        progress.textContent = "0%";

        downloadKmlBtn.disabled = true;
        downloadCsvBtn.disabled = true;
        downloadZipBtn.disabled = true;

        if (markersLayer) {
          markersLayer.clearLayers();
        }

        if (droneZonesLayer) {
          droneZonesLayer.clearLayers();
        }

        closePreview();

        Array.from(files).forEach((file, index) => {
          if (!file.type.startsWith("image/")) {
            updateProgress();
            return;
          }

          originalFiles.set(file.name, file);

          const reader = new FileReader();
          reader.onload = function (e) {
            processImage(file, e.target.result);
          };
          reader.readAsDataURL(file);
        });
      }

      // Processa uma imagem individual
      function processImage(file, dataUrl) {
        const img = new Image();
        img.onload = function () {
          EXIF.getData(img, function () {
            let lat = null;
            let lng = null;
            let datetime = null;

            if (EXIF.getTag(this, "GPSLatitude")) {
              lat = convertDMSToDD(
                EXIF.getTag(this, "GPSLatitude"),
                EXIF.getTag(this, "GPSLatitudeRef")
              );

              lng = convertDMSToDD(
                EXIF.getTag(this, "GPSLongitude"),
                EXIF.getTag(this, "GPSLongitudeRef")
              );

              if (EXIF.getTag(this, "DateTimeOriginal")) {
                datetime = EXIF.getTag(this, "DateTimeOriginal");
              }

              if (isValidCoordinate(lat, lng)) {
                imagesWithGeo++;
                document.getElementById("geoImages").textContent = imagesWithGeo;

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                const maxSize = 800;
                let { width, height } = img;
                
                if (width > height && width > maxSize) {
                  height = (height * maxSize) / width;
                  width = maxSize;
                } else if (height > maxSize) {
                  width = (width * maxSize) / height;
                  height = maxSize;
                }
                
                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(img, 0, 0, width, height);
                
                imageDataMap.set(file.name, canvas.toDataURL('image/jpeg', 0.85));

                imagePoints.push({
                  filename: file.name,
                  latitude: lat,
                  longitude: lng,
                  datetime: datetime,
                });

                const row = resultsBody.insertRow();
                row.insertCell(0).textContent = file.name;
                row.insertCell(1).textContent = lat.toFixed(8);
                row.insertCell(2).textContent = lng.toFixed(8);
                row.insertCell(3).textContent = datetime || "N/A";
              }
            }

            updateProgress();
          });
        };
        img.src = dataUrl;
      }

      // Atualiza o progresso
      function updateProgress() {
        processedImages++;
        const percentage = Math.round((processedImages / totalImages) * 100);
        progress.style.width = percentage + "%";
        progress.textContent = percentage + "%";

        if (processedImages === totalImages) {
          const totalPoints = imagePoints.length + importedPoints.length;
          if (totalPoints > 0) {
            downloadKmlBtn.disabled = false;
            downloadCsvBtn.disabled = false;
            plotPointsOnMap();
          }
        }
      }

      // Converter coordenadas DMS para Decimal Degrees
      function convertDMSToDD(dms, ref) {
        if (!dms || dms.length !== 3) return null;

        let dd = Number(dms[0]) + Number(dms[1]) / 60 + Number(dms[2]) / 3600;

        if (ref === "S" || ref === "W") {
          dd = -dd;
        }

        return dd;
      }

      // Verifica se as coordenadas são válidas
      function isValidCoordinate(lat, lng) {
        return (
          lat !== null &&
          lng !== null &&
          !isNaN(lat) &&
          !isNaN(lng) &&
          lat >= -90 &&
          lat <= 90 &&
          lng >= -180 &&
          lng <= 180
        );
      }

      // Gera e faz download do KML
      downloadKmlBtn.addEventListener("click", () => {
        const allPoints = combineAllPoints();
        if (allPoints.length === 0) return;

        const kmlContent = generateKML();
        if (!kmlContent) return;

        const dataStr =
          "data:application/vnd.google-earth.kml+xml;charset=utf-8," +
          encodeURIComponent(kmlContent);
        const downloadAnchor = document.createElement("a");
        downloadAnchor.setAttribute("href", dataStr);
        downloadAnchor.setAttribute("download", "pontos_georreferenciados.kml");
        document.body.appendChild(downloadAnchor);
        downloadAnchor.click();
        downloadAnchor.remove();
      });

      // Gera e faz download do CSV (incluindo pontos importados)
      downloadCsvBtn.addEventListener("click", () => {
        const allPoints = combineAllPoints();
        if (allPoints.length === 0) return;

        let csvContent = "Nome do Arquivo,Nome Original,Latitude,Longitude,Data/Hora,Tipo,Renomeado,Zona Drone,Aeroporto Próximo,Distância (km)\n";

        allPoints.forEach((point) => {
          const currentName = renamedFiles.get(point.filename) || point.filename;
          const isRenamed = renamedFiles.has(point.filename);
          const isImported = point.imported || false;
          const tipo = isImported ? 'Importado' : 'Imagem';
          const droneZone = point.droneZone ? point.droneZone.descricao : '';
          const nearestAirport = point.droneZone && point.droneZone.aeroporto ? point.droneZone.aeroporto.name : '';
          const distance = point.droneZone ? point.droneZone.distancia.toFixed(1) : '';
          const originalName = isImported ? point.filename : point.filename;
          
          csvContent += `"${currentName}","${originalName}",${String(point.latitude)},${String(
            point.longitude
          )},"${point.datetime || ""}","${tipo}","${isRenamed ? 'Sim' : 'Não'}","${droneZone}","${nearestAirport}","${distance}"\n`;
        });

        const dataStr =
          "data:text/csv;charset=utf-8," + encodeURIComponent(csvContent);
        const downloadAnchor = document.createElement("a");
        downloadAnchor.setAttribute("href", dataStr);
        downloadAnchor.setAttribute("download", "pontos_georreferenciados.csv");
        document.body.appendChild(downloadAnchor);
        downloadAnchor.click();
        downloadAnchor.remove();
      });

      // Função para carregar JSZip dinamicamente
      function loadJSZip(callback) {
        if (window.JSZip) {
          callback();
          return;
        }

        const script = document.createElement("script");
        script.src = "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
        script.onload = callback;
        script.onerror = () => {
          alert("Erro ao carregar JSZip. Verifique sua conexão com a internet.");
        };

        document.head.appendChild(script);
      }

      // Gera e faz download do ZIP com fotos renomeadas
      downloadZipBtn.addEventListener("click", () => {
        if (imagePoints.length === 0) return;

        loadJSZip(() => {
          const zip = new JSZip();
          let promises = [];

          imagePoints.forEach((point) => {
            const originalFile = originalFiles.get(point.filename);
            if (originalFile) {
              const currentName = renamedFiles.get(point.filename) || point.filename;
              
              const promise = new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                  zip.file(currentName, e.target.result);
                  resolve();
                };
                reader.onerror = reject;
                reader.readAsArrayBuffer(originalFile);
              });
              
              promises.push(promise);
            }
          });

          Promise.all(promises)
            .then(() => {
              return zip.generateAsync({ type: "blob" });
            })
            .then((blob) => {
              const link = document.createElement("a");
              link.href = URL.createObjectURL(blob);
              link.download = "fotos_georreferenciadas.zip";
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
            })
            .catch((error) => {
              alert("Erro ao criar o ZIP: " + error.message);
            });
        });
      });

      // Inicializar o mapa quando a página carregar
      document.addEventListener("DOMContentLoaded", function () {
        initMap();
      });
    </script>
  </body>
</html>